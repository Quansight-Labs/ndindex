<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Multidimensional Indices" href="multidimensional-indices/index.html" /><link rel="prev" title="Integer Indices" href="integer-indices.html" />

    <link rel="shortcut icon" href="../_static/favicon.ico"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>Slices - ndindex documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=16cf08d2" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=254c7fb8" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #CCCCCC;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #CCCCCC;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #000000bd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-dark-blue);
  --color-brand-content: var(--color-brand-dark-blue);
  --color-sidebar-background: #EEEEEE;
  --color-sidebar-item-background--hover: var(--color-brand-light-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-light-blue);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ndindex  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../_static/ndindex_logo_white_bg.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../_static/ndindex_logo_dark_bg.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ndindex  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/ndindex.html">ndindex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/index-types.html">Index Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/shapetools.html">Shape Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/chunking.html">Chunking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/internal.html">Internal API</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Guide to NumPy Indexing</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Guide to NumPy Indexing</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction: What is an Index?</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer-indices.html">Integer Indices</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Slices</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="multidimensional-indices/index.html">Multidimensional Indices</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Multidimensional Indices</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/what-is-an-array.html">What is an Array?</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/tuples.html">Tuple Indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/ellipses.html">Ellipses</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/newaxis.html">newaxis</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/integer-arrays.html">Integer Array Indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/boolean-arrays.html">Boolean Array Indices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="other-topics.html">Other Topics Relevant to Indexing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../type-confusion.html">Type Confusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">ndindex Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide.html">Documentation Style Guide</a></li>
</ul>

</div></div><div class="sidebar-tree sidebar-extra">
  <ul>
    <li class="toctree-l1">
      <a class="sidebar-extra"
      href="https://github.com/Quansight-Labs/ndindex">GitHub<svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link-external" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z"></path></svg></a>
    </li>
  </ul>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/blob/main/docs/indexing-guide/slices.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/edit/main/docs/indexing-guide/slices.md" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="slices">
<h1>Slices<a class="headerlink" href="#slices" title="Link to this heading">¶</a></h1>
<p>Python’s slice syntax is one of the more confusing parts of the language, even
for experienced developers. This page carefully breaks down the rules for
slicing, and examines just what it is that makes them so confusing.</p>
<p>There are two primary aspects of slices that make them difficult to
understand: confusing conventions, and discontinuous definitions. By confusing
conventions, we mean that slice semantics have definitions that are often
difficult to reason about mathematically. These conventions were chosen for
syntactic convenience, and one can easily see for most of them how they lead
to concise notation for very common operations; nonetheless, it remains true
that they can complicate figuring out the <em>right</em> slice to use in the first
place. By discontinuous definitions, we mean that the definition of a slice
takes on fundamentally different meanings if the start, stop, or step are
negative, nonnegative, or omitted. This is again done for syntactic
convenience, but it means that as a user, you must switch your mode of
thinking about slices depending on the value of the arguments. There are no
uniform formulas that apply to all slices.</p>
<p>The <a class="reference internal" href="../index.html"><span class="doc std std-doc">ndindex</span></a> library can help with much of this, especially for
developers of libraries that consume slices. However, for end-users, the
challenge is often just to write down a slice.</p>
<p>Even though this page is a part of a larger <a class="reference internal" href="index.html"><span class="doc std std-doc">guide</span></a> on indexing NumPy
arrays, and indeed, the <a class="reference internal" href="../index.html"><span class="doc std std-doc">ndindex</span></a> library focuses on NumPy array
index semantics, this page can be treated as a standalone guide to slicing,
which should be useful for any Python programmer, even those who do not
regularly use array libraries such as NumPy. This is because everything on
this page also applies to the built-in Python sequence types like <code class="docutils literal notranslate"><span class="pre">list</span></code>,
<code class="docutils literal notranslate"><span class="pre">tuple</span></code>, and <code class="docutils literal notranslate"><span class="pre">str</span></code>, and slicing these objects is a common operation across all
types of Python code.</p>
<section id="what-is-a-slice">
<h2>What is a slice?<a class="headerlink" href="#what-is-a-slice" title="Link to this heading">¶</a></h2>
<p>In Python, a slice is a special syntax that is allowed only in an index, that
is, inside of square brackets proceeding an expression. A slice consists of
one or two colons, with either an expression or nothing on either side of each
colon. For example, the following are all valid slices on the object
<code class="docutils literal notranslate"><span class="pre">a</span></code>:<a class="footnote-reference brackets" href="#slice-name-footnote" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">:</span><span class="n">z</span><span class="p">]</span>
<span class="n">a</span><span class="p">[:]</span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">::]</span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">::</span><span class="n">z</span><span class="p">]</span>
</pre></div>
</div>
<p>Furthermore, for a slice <code class="docutils literal notranslate"><span class="pre">a[x:y:z]</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> must be
integers.<a class="footnote-reference brackets" href="#non-integer-footnote" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p>The three arguments to a slice are traditionally called <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and
<code class="docutils literal notranslate"><span class="pre">step</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
</pre></div>
</div>
<p>We will use these names throughout this guide.</p>
<p>At a high level, <strong>a slice is a convenient way to select a sequential subset
of <code class="docutils literal notranslate"><span class="pre">a</span></code></strong> (roughly, “every <code class="docutils literal notranslate"><span class="pre">step</span></code> elements between the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>”).
The exact way in which this occurs is outlined throughout this guide.</p>
<p>It is worth noting that the <code class="docutils literal notranslate"><span class="pre">x:y:z</span></code> syntax is not valid outside of square
brackets. However, slice objects can be created manually using the <code class="docutils literal notranslate"><span class="pre">slice()</span></code>
builtin (<code class="docutils literal notranslate"><span class="pre">a[x:y:z]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">a[slice(x,</span> <span class="pre">y,</span> <span class="pre">z)]</span></code>). If you want to
perform more advanced operations like arithmetic on slices, consider using
the <a class="reference internal" href="../api/index-types.html#ndindex.Slice" title="ndindex.slice.Slice"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ndindex.Slice()</span></code></span></a> object.</p>
</section>
<section id="rules">
<span id="id3"></span><h2>Rules<a class="headerlink" href="#rules" title="Link to this heading">¶</a></h2>
<p>These are the rules to keep in mind to understand how slices work. Each of
these is explained in detail below. Many of the detailed descriptions below
also outline several <em>wrong</em> rules, which are bad ways of thinking about
slices but which you may be tempted to think about as rules. The below 7 rules
are always correct.</p>
<p>In this document, “<em>nonnegative</em>” means <span class="math notranslate nohighlight">\(\geq 0\)</span> and “<em>negative</em>” means <span class="math notranslate nohighlight">\(&lt; 0\)</span>.</p>
<p>For a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code>:</p>
<ol class="arabic simple">
<li><p><strong>Slicing something never raises an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>, even if the slice is empty.
For a NumPy array, a slice always keeps the axis being sliced, even if that
means the resulting dimension will be 0 or 1.</strong> (See section <a class="reference internal" href="#subarray"><span class="std std-ref">Subarray</span></a>)</p></li>
<li><p><strong>The <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> use <em>0-based indexing</em> from the <em>beginning</em> of <code class="docutils literal notranslate"><span class="pre">a</span></code> when
they are <em>nonnegative</em>, and <em>−1-based indexing</em> from <em>end</em> of <code class="docutils literal notranslate"><span class="pre">a</span></code> when they
are <em>negative</em>.</strong> (See sections <a class="reference internal" href="#based"><span class="std std-ref">0-based</span></a> and <a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative Indices</span></a>)</p></li>
<li><p><strong>The <code class="docutils literal notranslate"><span class="pre">stop</span></code> is never included in the slice.</strong> (See section <a class="reference internal" href="#half-open"><span class="std std-ref">Half-open</span></a>)</p></li>
<li><p><strong>The <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are clipped to the bounds of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</strong> (See section
<a class="reference internal" href="#clipping"><span class="std std-ref">Clipping</span></a>)</p></li>
<li><p><strong>The slice starts at the <code class="docutils literal notranslate"><span class="pre">start</span></code> and successively adds <code class="docutils literal notranslate"><span class="pre">step</span></code> until it
reaches an index that is at or past the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and then stops without
including that <code class="docutils literal notranslate"><span class="pre">stop</span></code> index.</strong> (See sections <a class="reference internal" href="#steps"><span class="std std-ref">Steps</span></a> and
<a class="reference internal" href="#negative-steps"><span class="std std-ref">Negative Steps</span></a>)</p></li>
<li><p><strong>If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is omitted it defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</strong> (See section <a class="reference internal" href="#omitted"><span class="std std-ref">Omitted Entries</span></a>)</p></li>
<li><p><strong>If the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are omitted they extend to the beginning or end of
<code class="docutils literal notranslate"><span class="pre">a</span></code> in the direction being sliced. Slices like <code class="docutils literal notranslate"><span class="pre">a[:i]</span></code> or <code class="docutils literal notranslate"><span class="pre">a[i:]</span></code> should be
thought of as the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> being omitted, not as a colon to the
left or right of an index.</strong> (See section <a class="reference internal" href="#omitted"><span class="std std-ref">Omitted Entries</span></a>)</p></li>
</ol>
<p>Throughout this guide, we will use as an example the same prototype list as we
used in the <a class="reference internal" href="integer-indices.html#prototype-example"><span class="std std-ref">integer indexing section</span></a>:</p>
<div class="slice-diagram">
  <table>
    <tr>
      <td><pre>a</pre></td>
      <td><pre>=</pre></td>
      <td><pre>['a',</pre></td>
      <td><pre>'b',</pre></td>
      <td><pre>'c',</pre></td>
      <td><pre>'d',</pre></td>
      <td><pre>'e',</pre></td>
      <td><pre>'f',</pre></td>
      <td><pre>'g']</pre></td>
    </tr>
  </table>
</div>
<p>The list <code class="docutils literal notranslate"><span class="pre">a</span></code> has 7 elements.</p>
<p>As a reminder, the elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> are strings, but the slices on the list <code class="docutils literal notranslate"><span class="pre">a</span></code>
will always use integers. Like <a class="reference internal" href="intro.html"><span class="std std-doc">all other index types</span></a>,
<strong>the result of a slice is never based on the values of the elements, but
rather on the position of the elements in the list.</strong><a class="footnote-reference brackets" href="#dict-footnote" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
</section>
<section id="points-of-confusion">
<span id="slices-points-of-confusion"></span><h2>Points of Confusion<a class="headerlink" href="#points-of-confusion" title="Link to this heading">¶</a></h2>
<p>Before running through this guide, ensure you have a solid understanding of
how integer indexing works.. See the previous section, <a class="reference internal" href="integer-indices.html"><span class="doc std std-doc">Integer Indices</span></a>.</p>
<p>Now, let us come back to slices. The full definition of a slice could be
written down in a couple of sentences, although the discontinuous definitions
would necessitate several “if” conditions. The <a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html#slicing-and-striding">NumPy docs on
slices</a>
say</p>
<blockquote id="numpy-definition">
<div><p>The basic slice syntax is <code class="docutils literal notranslate"><span class="pre">i:j:k</span></code> where <em>i</em> is the starting index, <em>j</em> is
the stopping index, and <em>k</em> is the step ( <span class="math notranslate nohighlight">\(k\neq 0\)</span> ). This selects the <code class="docutils literal notranslate"><span class="pre">m</span></code>
elements (in the corresponding dimension) with index values <em>i, i + k, …,
i + (m - 1) k</em> where <span class="math notranslate nohighlight">\(m = q + (r\neq 0)\)</span> and <em>q</em> and <em>r</em> are the quotient and
remainder obtained by dividing <em>j - i</em> by <em>k</em>: <em>j - i = q k + r</em>, so that
<em>i + (m - 1) k &lt; j</em>.</p>
</div></blockquote>
<p>While these definitions may give a technically accurate description of slices,
they aren’t especially helpful to someone who is trying to construct a slice
from a higher level of abstraction such as “I want to select this particular
subset of my array.”<a class="footnote-reference brackets" href="#numpy-definition-footnote" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
<p>Instead, we shall examine slices by carefully reviewing all the various
aspects of their syntax and semantics that can lead to confusion, and
attempting to demystify them through simple <a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a>.</p>
<section id="subarray">
<span id="id6"></span><h3>Subarray<a class="headerlink" href="#subarray" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p><strong>A slice always produces a subarray (or sub-list, sub-tuple, sub-string,
etc.). For NumPy arrays, this means that a slice will always <em>preserve</em> the
dimension that is sliced.</strong></p>
</div></blockquote>
<p id="empty-slice">This holds true even if the slice selects only a single element, or even if it
selects no elements at all (a slice that selects no elements is called an
<em>empty slice</em>). This is also true for lists,
tuples, and strings, in the sense that a slice on a list, tuple, or string
will always produce a list, tuple, or string. This behavior is different from
<a class="reference internal" href="integer-indices.html"><span class="doc std std-doc">integer indices</span></a>, which always remove the dimension that
they index.</p>
<p>For example</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># An element of the list</span>
<span class="go">&#39;d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># A sub-list</span>
<span class="go">[&#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Empty slice</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Integer index removes the first dimension</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Slice preserves the first dimension</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>One consequence of this is that, unlike integer indices, <strong>slices will never
raise <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>, even if the slice is empty or extends past the bounds of
the array</strong>.<a class="footnote-reference brackets" href="#slice-error-footnote" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> Therefore, you cannot rely on runtime
errors to alert you to coding mistakes relating to slice bounds that are too
large. A slice cannot be “out of bounds.” See also the section on
<a class="reference internal" href="#clipping"><span class="std std-ref">clipping</span></a> below.</p>
</section>
<section id="based">
<span id="id8"></span><h3>0-based<a class="headerlink" href="#based" title="Link to this heading">¶</a></h3>
<p>For the slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code>, where the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are nonnegative
integers, the indices <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are 0-based, as in <a class="reference internal" href="integer-indices.html"><span class="doc std std-doc">integer
indexing</span></a>. However, note that although the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is 0-based,
<a class="reference internal" href="#wrong-rule-4"><span class="std std-ref">it is not included in the slice</span></a>.</p>
<p>For example:</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">3:5</span>] == ['d', 'e']</code>
  <table>
    <tr>
      <td><pre>a</pre></td>
      <td><pre>=</pre></td>
      <td><pre>['a',</pre></td>
      <td><pre> 'b',</pre></td>
      <td><pre> 'c',</pre></td>
      <td class="underline-cell"><pre> 'd',</pre></td>
      <td class="underline-cell"><pre> 'e',</pre></td>
      <td><pre> 'f',</pre></td>
      <td><pre> 'g']</pre></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
      <td class="slice-diagram-not-selected">1</td>
      <td class="slice-diagram-not-selected">2</td>
      <td class="slice-diagram-selected">3</td>
      <td class="slice-diagram-selected">4</td>
      <td class="slice-diagram-not-selected">5</td>
      <td class="slice-diagram-not-selected">6</td>
    </tr>
  </table>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>Do not be worried if you find 0-based indexing hard to get used to, or if you
find yourself forgetting about it. Even experienced Python developers (this
author included) still find themselves writing <code class="docutils literal notranslate"><span class="pre">a[3]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">a[2]</span></code> from
time to time. The best way to learn to use 0-based indexing is to practice
using it enough that you use it automatically without thinking about it.</p>
</section>
<section id="half-open">
<span id="id9"></span><h3>Half-open<a class="headerlink" href="#half-open" title="Link to this heading">¶</a></h3>
<p>Slices behave like half-open intervals. What this means is that</p>
<blockquote>
<div><p><strong>the <code class="docutils literal notranslate"><span class="pre">stop</span></code> in <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> is <em>never</em> included in the slice</strong></p>
</div></blockquote>
<p>(the exception is if <a class="reference internal" href="#omitted"><span class="std std-ref">the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is omitted</span></a>).</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">a[3:5]</span></code> slices the indices <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code>, but not <code class="docutils literal notranslate"><span class="pre">5</span></code>
(<a class="reference internal" href="#based"><span class="std std-ref">0-based</span></a>).</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">3:5</span>] == ['d', 'e']</code>
  <div>
    <table>
      <tr>
        <td><pre>a</pre></td>
        <td><pre>=</pre></td>
        <td><pre>['a',</pre></td>
        <td><pre> 'b',</pre></td>
        <td><pre> 'c',</pre></td>
        <td class="underline-cell"><pre> 'd',</pre></td>
        <td class="underline-cell"><pre> 'e',</pre></td>
        <td><pre> 'f',</pre></td>
        <td><pre> 'g']</pre></td>
      </tr>
      <tr>
        <th>index</th>
        <td></td>
        <td class="slice-diagram-not-selected">0</td>
        <td class="slice-diagram-not-selected">1</td>
        <td class="slice-diagram-not-selected">2</td>
        <td><div class="circle-blue slice-diagram-selected">3</div></td>
        <td><div class="circle-blue slice-diagram-selected">4</div></td>
        <td><div class="circle-red slice-diagram-not-selected">5</div></td>
        <td class="slice-diagram-not-selected">6</td>
      </tr>
    </table>
  </div>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>The half-open nature of slices means that you must always remember that the
<code class="docutils literal notranslate"><span class="pre">stop</span></code> slice element is not included in the slice. However, it has a few
advantages:</p>
<ul id="sanity-check">
<li><p>The maximum length of a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code>, when the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>
are nonnegative, is always <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">-</span> <span class="pre">start</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">a[i:i+n]</span></code> slices
<code class="docutils literal notranslate"><span class="pre">n</span></code> elements from <code class="docutils literal notranslate"><span class="pre">a</span></code>. The caveat “maximum” is here because if <code class="docutils literal notranslate"><span class="pre">stop</span></code>
extends beyond the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>, then <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> will only slice up to
<code class="docutils literal notranslate"><span class="pre">len(a)</span> <span class="pre">-</span> <span class="pre">start</span></code> (see <a class="reference internal" href="#clipping"><span class="std std-ref">Clipping</span></a> below). Also be careful that this is
not true when the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are negative (see
<a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative Indices</span></a> below). However, given those caveats, this is often
a very useful sanity check that a slice is correct. If you expect a slice to
have length <code class="docutils literal notranslate"><span class="pre">n</span></code> but <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">-</span> <span class="pre">start</span></code> is clearly different from <code class="docutils literal notranslate"><span class="pre">n</span></code>, then the
slice is likely wrong. Length calculations are more complicated when <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">!=</span> <span class="pre">1</span></code>; in those cases, <a class="reference internal" href="../api/index-types.html#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">len(ndindex.Slice(...))</span></code></a> can be useful.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len(a)</span></code> can be used as a <code class="docutils literal notranslate"><span class="pre">stop</span></code> value to slice to the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>. For
example, <code class="docutils literal notranslate"><span class="pre">a[1:len(a)]</span></code> slices from the second element to the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>
(this is equivalent to <code class="docutils literal notranslate"><span class="pre">a[1:]</span></code>, see <a class="reference internal" href="#omitted"><span class="std std-ref">Omitted Entries</span></a>)</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
</li>
<li><p>Consecutive slices can be concatenated to one another by making each successive
slice’s <code class="docutils literal notranslate"><span class="pre">start</span></code> the same as the previous slice’s <code class="docutils literal notranslate"><span class="pre">stop</span></code>. For example, for our
list <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">a[2:3]</span> <span class="pre">+</span> <span class="pre">a[3:5]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">a[2:5]</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>A common usage of this is to split a slice into two slices. For example, the
slice <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> can be split as <code class="docutils literal notranslate"><span class="pre">a[i:k]</span></code> and <code class="docutils literal notranslate"><span class="pre">a[k:j]</span></code>.</p>
</li>
</ul>
<p>If the <code class="docutils literal notranslate"><span class="pre">start</span></code> is on or after the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, the resulting list will be empty.
That is to say, the <code class="docutils literal notranslate"><span class="pre">stop</span></code> <em>not</em> being included takes precedence over the
<code class="docutils literal notranslate"><span class="pre">start</span></code> being included.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Recall that for NumPy arrays, a slice always <a class="reference internal" href="#subarray"><span class="std std-ref">preserves the axis being
sliced</span></a>. This applies even if the size of the resulting axis is 0 or
1.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Integer index removes the first dimension</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Slice preserves the first dimension</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Slice preserves the first dimension as an empty dimension</span>
<span class="go">(0, 2)</span>
</pre></div>
</div>
<section id="wrong-ways-of-thinking-about-half-open-semantics">
<h4>Wrong Ways of Thinking about Half-open Semantics<a class="headerlink" href="#wrong-ways-of-thinking-about-half-open-semantics" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p><strong>The proper rule to remember for half-open semantics is “the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is not
included.”</strong></p>
</div></blockquote>
<p>There are several alternative interpretations of the half-open rule, but they
are all wrong in subtle ways. To be sure, for each of these, one could “fix”
the rule by adding some conditions, “it’s this in the case where such and such
is nonnegative and that when such and such is negative, and so on.” But that’s
not the point. The goal here is to <em>understand</em> slices. Remember that one of
the reasons that slices are difficult to understand is these branching rules.
By trying to remember a rule that has branching conditions, you open yourself
up to confusion. The rule becomes much more complicated than it appears at
first glance, making it hard to remember. You may forget the “uncommon” cases
and get things wrong when they come up in practice. You might as well think
about slices using the <a class="reference internal" href="#numpy-definition"><span class="std std-ref">definition from the NumPy docs</span></a>.</p>
<p>Rather, it is best to remember the simplest possible rule that is <em>always</em>
correct. That rule is “the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is not included.” This rule is extremely
simple, and is always right, regardless of what the values of <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>,
or <code class="docutils literal notranslate"><span class="pre">step</span></code> are (the only exception is if the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is omitted, in which case,
the rule obviously doesn’t apply as-is, and so you can fallback to <a class="reference internal" href="#omitted"><span class="std std-ref">the rule
about omitted <code class="docutils literal notranslate"><span class="pre">start</span></code>/<code class="docutils literal notranslate"><span class="pre">stop</span></code></span></a>).</p>
<section id="wrong-rule-1-a-slice-a-start-stop-slices-the-half-open-interval-text-start-text-stop">
<span id="wrong-rule-1"></span><h5>Wrong Rule 1: “A slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> slices the half-open interval <span class="math notranslate nohighlight">\([\text{start}, \text{stop})\)</span>.”<a class="headerlink" href="#wrong-rule-1-a-slice-a-start-stop-slices-the-half-open-interval-text-start-text-stop" title="Link to this heading">¶</a></h5>
<p>(or equivalently, “a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> selects the elements <span class="math notranslate nohighlight">\(i\)</span> such that
<span class="math notranslate nohighlight">\(\text{start} &lt;= i &lt; \text{stop}\)</span>”)</p>
<p>This is <em>only</em> the case if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive. It also isn’t directly true
when the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are negative. For example, with a <code class="docutils literal notranslate"><span class="pre">step</span></code> of <code class="docutils literal notranslate"><span class="pre">-1</span></code>,
<code class="docutils literal notranslate"><span class="pre">a[start:stop:-1]</span></code> slices starting at <code class="docutils literal notranslate"><span class="pre">start</span></code> going in reverse order to
<code class="docutils literal notranslate"><span class="pre">stop</span></code>, but not including <code class="docutils literal notranslate"><span class="pre">stop</span></code>. Mathematically, this creates a half open
interval <span class="math notranslate nohighlight">\((\text{stop}, \text{start}]\)</span> (except reversed).</p>
<p>For example, say we believed that <code class="docutils literal notranslate"><span class="pre">a[5:3:-1]</span></code> sliced the half-open interval
<span class="math notranslate nohighlight">\([3, 5)\)</span> but in reverse order.</p>
<div class="slice-diagram">
  <code style="font-size: 16pt;">a[<span class="slice-diagram-slice">5:3:-1</span>] "==" ['e', 'd']</code>
  <table>
    <tr>
      <td><pre>a</pre></td>
      <td><pre>=</pre></td>
      <td><pre>['a',</pre></td>
      <td><pre> 'b',</pre></td>
      <td><pre> 'c',</pre></td>
      <td class="underline-cell"><pre> 'd',</pre></td>
      <td class="underline-cell"><pre> 'e',</pre></td>
      <td><pre> 'f',</pre></td>
      <td><pre> 'g']</pre></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
      <td class="slice-diagram-not-selected">1</td>
      <td class="slice-diagram-not-selected">2</td>
      <td style="background-color: >
        <div style="position: relative;">
          <span class="math notranslate nohighlight" style="position: absolute; display: flex; height: 100%; top: 0; align-items: center;">\([\)</span>
          <span class="slice-diagram-selected">3</span
        </div>
      </td>
      <td class="slice-diagram-selected">4</td>
      <td>
        <div style="position: relative;">
          <span class="slice-diagram-not-selected">5</span>
          <span class="math notranslate nohighlight" style="position: absolute; display: flex; height: 100%; align-items: center; top: 0; right: 0;">\()\)</span>
        </div>
      </td>
      <td class="slice-diagram-not-selected">6</td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td colspan="3"><div class="centered-text">(reversed)</div><div class="horizontal-line"></div></td>
      <td></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td colspan="3" class="slice-diagram-not-selected"><div class="centered-text"><b>THIS IS WRONG!</b></div></td>
      <td></td>
    </tr>
  </table>
</div>
<p>We might assume we would get</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
<span class="go">[&#39;e&#39;, &#39;d&#39;] # WRONG</span>
</pre></div>
</div>
<p>Actually, what we really get is</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>This is because the slice <code class="docutils literal notranslate"><span class="pre">5:3:-1</span></code> starts at index <code class="docutils literal notranslate"><span class="pre">5</span></code> and steps backwards to
index <code class="docutils literal notranslate"><span class="pre">3</span></code>, but not including <code class="docutils literal notranslate"><span class="pre">3</span></code> (see <a class="reference internal" href="#negative-steps"><span class="std std-ref">Negative Steps</span></a> below).</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">5:3:-1</span>] == ['f', 'e']</code>
<table>
    <tr>
      <td><pre>a</pre></td>
      <td><pre>=</pre></td>
      <td><pre>['a',</pre></td>
      <td></td>
      <td><pre> 'b',</pre></td>
      <td></td>
      <td><pre> 'c',</pre></td>
      <td></td>
      <td><pre> 'd',</pre></td>
      <td></td>
      <td class="underline-cell"><pre> 'e',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre> 'f',</pre></td>
      <td></td>
      <td><pre> 'g']</pre></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
      <td></td>
      <td class="slice-diagram-not-selected">1</td>
      <td></td>
      <td class="slice-diagram-not-selected">2</td>
      <td></td>
      <td><div class="circle-red slice-diagram-not-selected">3</div></td>
      <td class="left-arrow-cell"><div style="font-size: smaller; transform:
translateY(-12px) translateX(3px)">&minus;1</div></td>
      <td><div class="circle-blue slice-diagram-selected">4</div></td>
      <td class="left-arrow-cell"><div style="font-size: smaller; transform:
translateY(-12px) translateX(3px)">&minus;1</div></td>
      <td><div class="circle-blue slice-diagram-selected">5</div></td>
      <td></td>
      <td class="slice-diagram-not-selected">6</td>
    </tr>
</table>
</div>
</section>
<section id="wrong-rule-2-a-slice-works-like-range">
<span id="wrong-rule-2"></span><h5>Wrong Rule 2: “A slice works like <code class="docutils literal notranslate"><span class="pre">range()</span></code>.”<a class="headerlink" href="#wrong-rule-2-a-slice-works-like-range" title="Link to this heading">¶</a></h5>
<p>There are many similarities between the behaviors of slices and the behavior
of <code class="docutils literal notranslate"><span class="pre">range()</span></code>. However, they are not exactly the same. A slice
<code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code> only acts like <code class="docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> if the <code class="docutils literal notranslate"><span class="pre">start</span></code>
and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are <strong>nonnegative</strong>. If either of them are negative, the slice
wraps around and slices from the end of the list (see <a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative Indices</span></a>
below). <code class="docutils literal notranslate"><span class="pre">range()</span></code> on the other hand treats negative numbers as the actual
start and stop values for the range. For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># b is range(7), and these are the same</span>
<span class="go">[3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># Empty, because -2 is less than 3</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Indexes from 3 to the second to last (5), but not including 5</span>
<span class="go">[3, 4]</span>
</pre></div>
</div>
<p>This rule is appealing because <code class="docutils literal notranslate"><span class="pre">range()</span></code> simplifies some computations. For
example, you can index or take the <code class="docutils literal notranslate"><span class="pre">len()</span></code> of a range. If you need to perform
computations on slices, we recommend using <a class="reference internal" href="../api/index-types.html#ndindex.Slice" title="ndindex.slice.Slice"><span class="xref myst py py-class">ndindex</span></a>.
This is what it was designed for.</p>
<p>Note however, that the reverse does work: if you have a <code class="docutils literal notranslate"><span class="pre">range()</span></code> object, you
can slice it to get another <code class="docutils literal notranslate"><span class="pre">range()</span></code> object. This works without every
actually computing the range values, so it is efficient even if the actual
range would be huge.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000000000</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
<span class="go">range(999999998, 2, -15)</span>
</pre></div>
</div>
<p>So slices can be used to compute transformations on <code class="docutils literal notranslate"><span class="pre">range</span></code> objects, but
<code class="docutils literal notranslate"><span class="pre">range</span></code> objects should not be used to compute things about slices. If you want
to do that, use <a class="reference internal" href="../index.html"><span class="doc std std-doc">ndindex</span></a>.</p>
</section>
<section id="wrong-rule-3-slices-index-the-spaces-between-the-elements-of-the-list">
<span id="wrong-rule-3"></span><h5>Wrong Rule 3: “Slices index the spaces between the elements of the list.”<a class="headerlink" href="#wrong-rule-3-slices-index-the-spaces-between-the-elements-of-the-list" title="Link to this heading">¶</a></h5>
<p>This is a very common rule that is taught for both slices and integer
indexing. The reasoning goes as follows: 0-based indexing is confusing, where
the first element of a list is indexed by 0, the second by 1, and so on.
Rather than thinking about that, consider the spaces between the elements:</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">3:5</span>] == ['d', 'e']</code>
<div>
  <table>
    <tr>
      <td><pre>a =</pre></td>
      <td><pre>[</pre></td>
      <td></td>
      <td><pre>'a',</pre></td>
      <td></td>
      <td><pre>'b',</pre></td>
      <td></td>
      <td><pre>'c',</pre></td>
      <td></td>
      <td class="underline-cell"><pre>'d',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre>'e',</pre></td>
      <td></td>
      <td><pre>'f',</pre></td>
      <td></td>
      <td><pre>'g'</pre></td>
      <td></td>
      <td><pre>]</pre></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
      <td></td>
      <td class="slice-diagram-not-selected">1</td>
      <td></td>
      <td class="slice-diagram-not-selected">2</td>
      <td></td>
      <td class="slice-diagram-selected">3</td>
      <td></td>
      <td class="slice-diagram-selected">4</td>
      <td></td>
      <td class="slice-diagram-selected">5</td>
      <td></td>
      <td class="slice-diagram-not-selected">6</td>
      <td></td>
      <td class="slice-diagram-not-selected">7</td>
    </tr>
  </table>
</div>
<i>(not a great way of thinking about 0-based indexing)</i>
</div>
<p>Using this way of thinking, the first element of <code class="docutils literal notranslate"><span class="pre">a</span></code> is to the left of the
“1-divider”. An integer index <code class="docutils literal notranslate"><span class="pre">i</span></code> produces the element to the right of the
“<code class="docutils literal notranslate"><span class="pre">i</span></code>-divider”, and a slice <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> selects the elements between the <code class="docutils literal notranslate"><span class="pre">i</span></code> and
<code class="docutils literal notranslate"><span class="pre">j</span></code> dividers.</p>
<p>At first glance, this seems like a rather clever way to think about the
half-open rule. For instance, between the <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code> dividers is the subarray
<code class="docutils literal notranslate"><span class="pre">['d',</span> <span class="pre">'e']</span></code>, which is indeed what we get for <code class="docutils literal notranslate"><span class="pre">a[3:5]</span></code>. However, there are several
reasons why this way of thinking creates more confusion than it removes.</p>
<ul>
<li><p>As with <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">wrong rule 1</span></a>, it works well enough if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is
positive, but falls apart when it is negative.</p>
<p>Consider again the slice <code class="docutils literal notranslate"><span class="pre">a[5:3:-1]</span></code>. Looking at the above figure, we might
imagine it to give the same incorrect subarray that we imagined before.</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">5:3:-1</span>] "==" ['e', 'd']</code>
<div>
  <table>
    <tr>
      <td><pre>a =</pre></td>
      <td><pre>[</pre></td>
      <td></td>
      <td><pre>'a',</pre></td>
      <td></td>
      <td><pre>'b',</pre></td>
      <td></td>
      <td><pre>'c',</pre></td>
      <td></td>
      <td class="underline-cell"><pre>'d',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre>'e',</pre></td>
      <td></td>
      <td><pre>'f',</pre></td>
      <td></td>
      <td><pre>'g'</pre></td>
      <td></td>
      <td><pre>]</pre></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
      <td></td>
      <td class="slice-diagram-not-selected">1</td>
      <td></td>
      <td class="slice-diagram-not-selected">2</td>
      <td></td>
      <td class="slice-diagram-selected">3</td>
      <td></td>
      <td class="slice-diagram-selected">4</td>
      <td></td>
      <td class="slice-diagram-selected">5</td>
      <td></td>
      <td class="slice-diagram-not-selected">6</td>
      <td></td>
      <td class="slice-diagram-not-selected">7</td>
    </tr>
  </table>
</div>
<div class="slice-diagram-not-selected"><b>THIS IS WRONG!</b></div>
</div>
<p>As before, we might assume we would get</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
<span class="go">[&#39;e&#39;, &#39;d&#39;] # WRONG</span>
</pre></div>
</div>
<p>but this is incorrect! What we really get is</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>If you’ve ever espoused the “spaces between elements” way of thinking about
indices, this should give you serious pause. As the above diagram
illustrates, this rule is flat out wrong when the <code class="docutils literal notranslate"><span class="pre">step</span></code> is negative, and
there’s no clear way to salvage it. Contrast thinking about this same slice
as simply <a class="reference internal" href="#negative-steps"><span class="std std-ref">stepping backwards</span></a> from index <code class="docutils literal notranslate"><span class="pre">5</span></code> to index <code class="docutils literal notranslate"><span class="pre">3</span></code>,
but not including index <code class="docutils literal notranslate"><span class="pre">3</span></code>:</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">5:3:-1</span>] == ['f', 'e']</code>
<table>
    <tr>
      <td><pre>a</pre></td>
      <td><pre>=</pre></td>
      <td><pre>['a',</pre></td>
      <td></td>
      <td><pre> 'b',</pre></td>
      <td></td>
      <td><pre> 'c',</pre></td>
      <td></td>
      <td><pre> 'd',</pre></td>
      <td></td>
      <td class="underline-cell"><pre> 'e',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre> 'f',</pre></td>
      <td></td>
      <td><pre> 'g']</pre></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
      <td></td>
      <td class="slice-diagram-not-selected">1</td>
      <td></td>
      <td class="slice-diagram-not-selected">2</td>
      <td></td>
      <td><div class="circle-red slice-diagram-not-selected">3</div></td>
      <td class="left-arrow-cell"><div style="font-size: smaller; transform:
translateY(-12px) translateX(3px)">&minus;1</div></td>
      <td><div class="circle-blue slice-diagram-selected">4</div></td>
      <td class="left-arrow-cell"><div style="font-size: smaller; transform:
translateY(-12px) translateX(3px)">&minus;1</div></td>
      <td><div class="circle-blue slice-diagram-selected">5</div></td>
      <td></td>
      <td class="slice-diagram-not-selected">6</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td class="slice-diagram-index-label-not-selected">stop</td>
      <td></td>
      <td></td>
      <td></td>
      <td class="slice-diagram-index-label-selected">start</td>
      <td></td>
      <td></td>
    </tr>
</table>
</div>
</li>
<li><p>The rule does work when the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are negative, but only if you
think about it correctly. The correct way to think about it is to reverse
the dividers:</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">-4:-2</span>] == ['d', 'e']</code>
<div>
  <table>
    <tr>
      <td><pre>a =</pre></td>
      <td><pre>[</pre></td>
      <td></td>
      <td><pre>'a',</pre></td>
      <td></td>
      <td><pre>'b',</pre></td>
      <td></td>
      <td><pre>'c',</pre></td>
      <td></td>
      <td class="underline-cell"><pre>'d',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre>'e',</pre></td>
      <td></td>
      <td><pre>'f',</pre></td>
      <td></td>
      <td><pre>'g'</pre></td>
      <td></td>
      <td><pre>]</pre></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;7</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;6</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;5</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;4</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;3</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;2</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;1</td>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
    </tr>
  </table>
</div>
<i>(not a great way of thinking about negative indices)</i>
</div>
<p>For example, <code class="docutils literal notranslate"><span class="pre">a[-4:-2]</span></code> will give <code class="docutils literal notranslate"><span class="pre">['d',</span> <span class="pre">'e']</span></code></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>However, it would be quite easy to get confused here, as the “other” way of
thinking about negative indices (the way we are recommending) is that the
end starts at -1. So you might mistakenly imagine something like this:</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">-4:-2</span>] "==" ['e', 'f']</code>
<div>
  <table>
    <tr>
      <td><pre>a =</pre></td>
      <td><pre>[</pre></td>
      <td></td>
      <td><pre>'a',</pre></td>
      <td></td>
      <td><pre>'b',</pre></td>
      <td></td>
      <td><pre>'c',</pre></td>
      <td></td>
      <td><pre>'d',</pre></td>
      <td></td>
      <td class="underline-cell"><pre>'e',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre>'f',</pre></td>
      <td></td>
      <td><pre>'g'</pre></td>
      <td></td>
      <td><pre>]</pre></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;8</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;7</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;6</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;5</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;4</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;3</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;2</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;1</td>
    </tr>
  </table>
</div>
<div class="slice-diagram-not-selected"><b>THIS IS WRONG!</b></div>
</div>
<p>But things are even worse than that. If we combine a negative <code class="docutils literal notranslate"><span class="pre">start</span></code> and
<code class="docutils literal notranslate"><span class="pre">stop</span></code> with a negative <code class="docutils literal notranslate"><span class="pre">step</span></code>, things get even more confusing. Consider the
slice <code class="docutils literal notranslate"><span class="pre">a[-2:-4:-1]</span></code>. This gives <code class="docutils literal notranslate"><span class="pre">['f',</span> <span class="pre">'e']</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>To get this with the “spacers” idea, we have to use the above “wrong”
diagram!</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">-2:-4:-1</span>] == ['f', 'e']</code>
<div>
  <table>
    <tr>
      <td><pre>a =</pre></td>
      <td><pre>[</pre></td>
      <td></td>
      <td><pre>'a',</pre></td>
      <td></td>
      <td><pre>'b',</pre></td>
      <td></td>
      <td><pre>'c',</pre></td>
      <td></td>
      <td><pre>'d',</pre></td>
      <td></td>
      <td class="underline-cell"><pre>'e',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre>'f',</pre></td>
      <td></td>
      <td><pre>'g'</pre></td>
      <td></td>
      <td><pre>]</pre></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;8</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;7</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;6</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;5</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;4</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;3</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;2</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;1</td>
    </tr>
  </table>
</div>
<span style="color:var(--color-slice-diagram-selected);"><b>NOW RIGHT!</b></span>
</div>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">-2:-4:-1</span>] "==" ['e', 'd']</code>
<div>
  <table>
    <tr>
      <td><pre>a =</pre></td>
      <td><pre>[</pre></td>
      <td></td>
      <td><pre>'a',</pre></td>
      <td></td>
      <td><pre>'b',</pre></td>
      <td></td>
      <td><pre>'c',</pre></td>
      <td></td>
      <td class="underline-cell"><pre>'d',</pre></td>
      <td class="underline-cell"></td>
      <td class="underline-cell"><pre>'e',</pre></td>
      <td></td>
      <td><pre>'f',</pre></td>
      <td></td>
      <td><pre>'g'</pre></td>
      <td></td>
      <td><pre>]</pre></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-blue"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
      <td></td>
      <td class="vertical-bar-red"></td>
    </tr>
    <tr>
      <th>index</th>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;7</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;6</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;5</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;4</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;3</td>
      <td></td>
      <td class="slice-diagram-selected">&minus;2</td>
      <td></td>
      <td class="slice-diagram-not-selected">&minus;1</td>
      <td></td>
      <td class="slice-diagram-not-selected">0</td>
    </tr>
  </table>
</div>
<div class="slice-diagram-not-selected"><b>THIS IS WRONG!</b></div>
</div>
<p>In other words, the “right” way to think of spacers when the <code class="docutils literal notranslate"><span class="pre">start</span></code> and
<code class="docutils literal notranslate"><span class="pre">stop</span></code> are negative depends if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive or negative.</p>
<p>This is because the correct half-open rule is based on not including the
<code class="docutils literal notranslate"><span class="pre">stop</span></code>. It <em>isn’t</em> based on not including the larger end of the interval. If
the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive, the <code class="docutils literal notranslate"><span class="pre">stop</span></code> will be larger, but if it is
<a class="reference internal" href="#negative-steps"><span class="std std-ref">negative</span></a>, the <code class="docutils literal notranslate"><span class="pre">stop</span></code> will be smaller.</p>
</li>
<li><p>The rule “works” for slices, but is harder to conceptualize for integer
indices. In the divider way of thinking, an integer index <code class="docutils literal notranslate"><span class="pre">n</span></code> corresponds to
the entry to the <em>right</em> of the <code class="docutils literal notranslate"><span class="pre">n</span></code> divider. Rules that involve remembering
left or right aren’t great when it comes to memorability.</p></li>
</ul>
<ul id="fencepost">
<li><p>This rule can lead to off-by-one errors due to “the fencepost problem.” The
fencepost problem is this: say you want to build a fence that is 100 feet
long with posts spaced every 10 feet. How many fenceposts do you need?</p>
<p>The naive answer is 10, but the correct answer is 11. The reason is the
fenceposts go in between the 10 feet divisions, including at the end points.
So there is an “extra” fencepost compared to the number of fence sections.</p>
<figure class="align-default" id="id24">
<img alt="../_images/jeff-burak-lPO0VzF_4s8-unsplash.jpg" src="../_images/jeff-burak-lPO0VzF_4s8-unsplash.jpg" />
<figcaption>
<p><span class="caption-text">A section of a fence that has 6 segments and 7 fenceposts.<a class="footnote-reference brackets" href="#fencepost-jeff-burbak-footnote" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id24" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Fencepost problems are a leading cause of off-by-one errors. To think about
slices in this way is to think about lists as separated by fenceposts, and
is only begging for problems. This will especially be the case if you also
find yourself otherwise thinking about indices as pointing to list elements
themselves, rather than the divisions between them. And of course you will
think of them this way, because that’s what they actually are.</p>
</li>
</ul>
<p>Rather than trying to think about dividers between elements, it’s much simpler
to just think about the elements themselves, but being counted starting at 0.
To be sure, 0-based indexing also leads to off-by-one errors, since it is not
the usual way humans are taught to count things. Nonetheless, this is the
better way to think about things, especially as you gain practice in counting
starting at 0. As long as you apply the rule “the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is not included,” you
will get the correct results.</p>
</section>
<section id="wrong-rule-4-the-stop-of-a-slice-a-start-stop-is-1-based">
<span id="wrong-rule-4"></span><h5>Wrong Rule 4: “The <code class="docutils literal notranslate"><span class="pre">stop</span></code> of a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> is 1-based.”<a class="headerlink" href="#wrong-rule-4-the-stop-of-a-slice-a-start-stop-is-1-based" title="Link to this heading">¶</a></h5>
<p>You might try to get clever and say <code class="docutils literal notranslate"><span class="pre">a[3:5]</span></code> indexes from the 3rd element with
0-based indexing to the 5th element with 1-based indexing. Don’t do this. It
is confusing. Moreover, this rule must necessarily be reversed for negative
indices. <code class="docutils literal notranslate"><span class="pre">a[-5:-3]</span></code> indexes from the (−5)th element with −1-based
indexing to the (−3)rd element with 0-based indexing (and of course,
negative and nonnegative starts and stops can be mixed, like <code class="docutils literal notranslate"><span class="pre">a[3:-3]</span></code>). Don’t
get cute here. It isn’t worth it. The <code class="docutils literal notranslate"><span class="pre">stop</span></code> <em>is</em> 0-based; it just isn’t
included.</p>
</section>
</section>
</section>
<section id="negative-indices">
<span id="id11"></span><h3>Negative Indices<a class="headerlink" href="#negative-indices" title="Link to this heading">¶</a></h3>
<p>Negative indices in slices work the same way they do with <a class="reference internal" href="integer-indices.html"><span class="doc std std-doc">integer
indices</span></a>.</p>
<blockquote>
<div><p><strong>For <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code>, negative <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> use −1-based indexing
from the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</strong></p>
</div></blockquote>
<p>However, the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> being negative does <em>not</em> change the order of
the slicing—only the <a class="reference internal" href="#negative-steps"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">step</span></code> does that</span></a>. The other
<a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a> of slicing remain unchanged when the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are
negative. <a class="reference internal" href="#half-open"><span class="std std-ref">The <code class="docutils literal notranslate"><span class="pre">stop</span></code> is still not included</span></a>, values less than
<code class="docutils literal notranslate"><span class="pre">-len(a)</span></code> still <a class="reference internal" href="#clipping"><span class="std std-ref">clip</span></a>, and so on.</p>
<p>Positive and negative <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> can be mixed. The following slices of
<code class="docutils literal notranslate"><span class="pre">a</span></code> all produce <code class="docutils literal notranslate"><span class="pre">['d',</span> <span class="pre">'e']</span></code>:</p>
<div class="slice-diagram" style="padding-left: 1em; padding-right: 1em;">
<div style="font-size: 16pt;"><code>a[<span class="slice-diagram-slice">3:5</span>] == a[<span class="slice-diagram-slice">-4:-2</span>] == a[<span class="slice-diagram-slice">3:-2</span>] == a[<span class="slice-diagram-slice">-4:5</span>] == ['d', 'e']</code></div>
  <div>
    <table>
      <tr>
      <th></th>
        <td><pre>a</pre></td>
        <td><pre>=</pre></td>
        <td><pre>['a',</pre></td>
        <td><pre> 'b',</pre></td>
        <td><pre> 'c',</pre></td>
        <td class="underline-cell"><pre> 'd',</pre></td>
        <td class="underline-cell"><pre> 'e',</pre></td>
        <td><pre> 'f',</pre></td>
        <td><pre> 'g']</pre></td>
      </tr>
      <tr>
        <th>nonnegative index</th>
        <td></td>
        <td></td>
        <td class="slice-diagram-not-selected">0</td>
        <td class="slice-diagram-not-selected">1</td>
        <td class="slice-diagram-not-selected">2</td>
        <td><div class="circle-blue slice-diagram-selected">3</div></td>
        <td><div class="circle-blue slice-diagram-selected">4</div></td>
        <td><div class="circle-red slice-diagram-not-selected">5</div></td>
        <td class="slice-diagram-not-selected">6</td>
      </tr>
      <tr>
        <th>negative index</th>
        <td></td>
        <td></td>
        <td class="slice-diagram-not-selected">&minus;7</td>
        <td class="slice-diagram-not-selected">&minus;6</td>
        <td class="slice-diagram-not-selected">&minus;5</td>
        <td><div class="circle-blue slice-diagram-selected">&minus;4</div></td>
        <td><div class="circle-blue slice-diagram-selected">&minus;3</div></td>
        <td><div class="circle-red slice-diagram-not-selected">&minus;2</div></td>
        <td class="slice-diagram-not-selected">&minus;1</td>
      </tr>
    </table>
  </div>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>If a negative <code class="docutils literal notranslate"><span class="pre">stop</span></code> indexes an element on or before a nonnegative <code class="docutils literal notranslate"><span class="pre">start</span></code>, the
slice is empty, akin to when <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">&lt;=</span> <span class="pre">start</span></code> when both are nonnegative.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>As with <a class="reference internal" href="integer-indices.html"><span class="doc std std-doc">integer indices</span></a>, negative indices <code class="docutils literal notranslate"><span class="pre">-i</span></code> in slices
can always be replaced with <code class="docutils literal notranslate"><span class="pre">len(a)</span> <span class="pre">-</span> <span class="pre">i</span></code> (replacing <code class="docutils literal notranslate"><span class="pre">len(a)</span></code> with the size of
the given axis for NumPy arrays). So they are primarily a syntactic
convenience.</p>
<p>While negative indexing is convenient, it may introduce subtle bugs due to the
inherent discontinuity it creates. This is especially likely to happen if the
slice entries are arithmetical expressions. <strong>One should always double check
if the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> values of a slice can be negative, and if they can,
if those values produce the correct results.</strong></p>
<p id="negative-indices-example">For example, say you wanted to slice <code class="docutils literal notranslate"><span class="pre">n</span></code> values from the middle of <code class="docutils literal notranslate"><span class="pre">a</span></code>.
Something like the following would work:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>From our <a class="reference internal" href="#sanity-check"><span class="std std-ref">sanity check</span></a>, <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">+</span> <span class="pre">n//2</span> <span class="pre">-</span> <span class="pre">(mid</span> <span class="pre">-</span> <span class="pre">n//2)</span></code> does equal
<code class="docutils literal notranslate"><span class="pre">n</span></code> if <code class="docutils literal notranslate"><span class="pre">n</span></code> is even (we could find a similar expression for odd <code class="docutils literal notranslate"><span class="pre">n</span></code>, but for
now let us assume <code class="docutils literal notranslate"><span class="pre">n</span></code> is even for simplicity).</p>
<p>However, let’s look at what happens when <code class="docutils literal notranslate"><span class="pre">n</span></code> is larger than the size of <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;g&#39;]</span>
</pre></div>
</div>
<p>The result <code class="docutils literal notranslate"><span class="pre">['g']</span></code> is not the “middle eight elements of <code class="docutils literal notranslate"><span class="pre">a</span></code>.” What we likely
really wanted here was full list <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c',</span> <span class="pre">'d',</span> <span class="pre">'e',</span> <span class="pre">'f',</span> <span class="pre">'g']</span></code>.</p>
<p>What happened here? Let’s look at the slice values:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>
<span class="go">7</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">stop</span></code> slice value is out of bounds for <code class="docutils literal notranslate"><span class="pre">a</span></code>, but this just causes it to
<a class="reference internal" href="#clipping"><span class="std std-ref">clip</span></a> to the end, which is what we want.</p>
<p>But the <code class="docutils literal notranslate"><span class="pre">start</span></code> expression contains a subtraction, which causes it to become
negative. So rather than clipping to the start, it wraps around and indexes
from the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>. The resulting slice <code class="docutils literal notranslate"><span class="pre">a[-1:7]</span></code> selects everything from
<code class="docutils literal notranslate"><span class="pre">'g'</span></code> to the end of the list, which in this case is just <code class="docutils literal notranslate"><span class="pre">['g']</span></code>.</p>
<p>Unfortunately, the “correct” fix here depends on the desired behavior for each
individual slice. In some cases, the “slice from the end” behavior of negative
values is in fact what is desired. In others, you might prefer an error, so you
should add a value check or assertion. In others, you might want clipping, in
which case you could modify the expression to always be nonnegative.</p>
<p>In this example, we do want clipping. Instead of using <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">-</span> <span class="pre">n//2</span></code>, we could
manually clip with <code class="docutils literal notranslate"><span class="pre">max(mid</span> <span class="pre">-</span> <span class="pre">n//2,</span> <span class="pre">0)</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>Or we could replace the <code class="docutils literal notranslate"><span class="pre">start</span></code> with a value that is always negative. This
avoids the discontinuity problem because values that are too negative will
<a class="reference internal" href="#clipping"><span class="std std-ref">clip</span></a> to the start of the array, just as they do for the <code class="docutils literal notranslate"><span class="pre">stop</span></code>.
But this does require thinking a bit about how to translate from 0-based
indexing to −1-based indexing. In this example, the <code class="docutils literal notranslate"><span class="pre">start</span></code> becomes <code class="docutils literal notranslate"><span class="pre">-n//2</span> <span class="pre">-</span> <span class="pre">mid</span> <span class="pre">-</span> <span class="pre">1</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>It’s a good idea to play around in an interpreter and check all the corner
cases when dealing with situations like this.</p>
<p>And note that even this improved version can give unexpected results when <code class="docutils literal notranslate"><span class="pre">n</span></code>
is negative, for the exact same reasons. So value checking that the inputs are
in an expected range is not a bad idea.</p>
<p><strong>Exercise:</strong> Write a slice to index the middle <code class="docutils literal notranslate"><span class="pre">n</span></code> elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> when <code class="docutils literal notranslate"><span class="pre">n</span></code>
is odd, clipping to all of <code class="docutils literal notranslate"><span class="pre">a</span></code> if <code class="docutils literal notranslate"><span class="pre">n</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">len(a)</span></code>.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Click here to show the solution<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">Solution: <code class="docutils literal notranslate"><span class="pre">a[-n//2</span> <span class="pre">-</span> <span class="pre">mid:mid</span> <span class="pre">+</span> <span class="pre">n//2</span> <span class="pre">+</span> <span class="pre">1]</span></code>.</p>
<p class="sd-card-text">Note that this also works when <code class="docutils literal notranslate"><span class="pre">n</span></code> is even, although unlike above, <code class="docutils literal notranslate"><span class="pre">n=2</span></code> gives
<code class="docutils literal notranslate"><span class="pre">['d',</span> <span class="pre">'e']</span></code> instead of <code class="docutils literal notranslate"><span class="pre">['c',</span> <span class="pre">'d']</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">mid</span><span class="p">:</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">mid</span><span class="p">:</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">mid</span><span class="p">:</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</span>
</pre></div>
</div>
</div>
</details></section>
<section id="clipping">
<span id="id12"></span><h3>Clipping<a class="headerlink" href="#clipping" title="Link to this heading">¶</a></h3>
<p>Slices can never result in an out of bounds <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>. This differs from
<a class="reference internal" href="integer-indices.html"><span class="doc std std-doc">integer indices</span></a>, which require the index to be in bounds.
Instead, slice values <em>clip</em> to the bounds of the array.</p>
<p>The rule for clipping is this:</p>
<blockquote>
<div><p><strong>If the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> extend before the beginning or after the end of
<code class="docutils literal notranslate"><span class="pre">a</span></code>, they will clip to the bounds of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</strong></p>
</div></blockquote>
<p>For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">-100</span></code> is “clipped” to <code class="docutils literal notranslate"><span class="pre">-7</span></code>, the smallest possible negative start value
that actually selects something, and <code class="docutils literal notranslate"><span class="pre">100</span></code> is clipped down to <code class="docutils literal notranslate"><span class="pre">7</span></code>, the
smallest possible positive stop value that selects the last element.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>Of course, if we actually wanted to just select everything, we could use
<a class="reference internal" href="#omitted"><span class="std std-ref">omitted entries</span></a> (i.e., <code class="docutils literal notranslate"><span class="pre">a[:]</span></code>). The point with clipping is that the
same slice can be used on lists or arrays that are smaller than the bounds of
the slice, and it will just select “as much as it can.”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># The second and third element</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># There is no third element, so just the second</span>
<span class="go">[&#39;b&#39;]</span>
</pre></div>
</div>
<p>This behavior can be useful, but it can also bite you. Usually you really do
want to select something like “the first <span class="math notranslate nohighlight">\(n\)</span> elements, or everything if there
are fewer than <span class="math notranslate nohighlight">\(n\)</span> elements,” and a slice like <code class="docutils literal notranslate"><span class="pre">:n</span></code> will do exactly this for
any size input. But you have to be careful. Simply seeing a slice like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">a[:n]</span></code> does not mean that <code class="docutils literal notranslate"><span class="pre">x</span></code> now has <code class="docutils literal notranslate"><span class="pre">n</span></code> elements. Because of clipping
behavior, you can never rely on the length of a slice being <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">-</span> <span class="pre">start</span></code>
(<a class="reference internal" href="#sanity-check"><span class="std std-ref">for <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">=</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code> nonnegative</span></a>), unless you
are sure that the length of the input is at least that. Rather, this is the
<em>maximum</em> length of the slice. It could end up slicing something
smaller.<a class="footnote-reference brackets" href="#ndindex-calculations-footnote" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></p>
<p>The clipping behavior of slices also means that you cannot rely on runtime
checks for out of bounds slices. Simply put, there is no such thing as an
“out of bounds slice.” If you really want a bounds check, you have to do it
manually.</p>
<p>There’s a cute trick you can sometimes use that takes advantage of clipping.
By using a slice that selects a single element instead of an integer index,
you can avoid <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> when the index is out of bounds. For example,
suppose you want to implement a quick script with a rudimentary optional
command line argument (without the hassle of
<a class="reference external" href="https://docs.python.org/3/library/argparse.html">argparse</a>). This can be done
by manually parsing <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>, which is a list of the arguments of passed at
the command line, including the filename. For example, <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">script.py</span> <span class="pre">arg1</span> <span class="pre">arg2</span></code> would have <code class="docutils literal notranslate"><span class="pre">sys.argv</span> <span class="pre">==</span> <span class="pre">['script.py',</span> <span class="pre">'arg1',</span> <span class="pre">'arg2']</span></code>. Suppose you want
your script to do something special if it called as <code class="docutils literal notranslate"><span class="pre">myscript.py</span> <span class="pre">help</span></code>. You
can do something like</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Usage: myscript.py&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The problem with this code is that it fails if no command line arguments are
passed, because <code class="docutils literal notranslate"><span class="pre">sys.argv[1]</span></code> will give an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> for the out of bounds
index 1. The most obvious fix is to add a length check:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Usage: myscript.py&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>But another way would be to use a slice that gets the second element if there
is one.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;help&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Usage: myscript.py&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now if <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code> has at least two elements, the slice <code class="docutils literal notranslate"><span class="pre">sys.argv[1:2]</span></code> will be
the sublist consisting of just the second element. But if it has only one
element, i.e., the script is just run as <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">myscript.py</span></code> with no
arguments, then <code class="docutils literal notranslate"><span class="pre">sys.argv[1:2]</span></code> will be an empty list <code class="docutils literal notranslate"><span class="pre">[]</span></code>. This will fail the
<code class="docutils literal notranslate"><span class="pre">==</span></code> check without raising an exception.</p>
<p>If instead we want to only support exactly <code class="docutils literal notranslate"><span class="pre">myscript.py</span> <span class="pre">help</span></code> with no further
arguments, we could modify the check just slightly:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;help&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Usage: myscript.py&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">myscript.py</span> <span class="pre">help</span></code> would print the help message but <code class="docutils literal notranslate"><span class="pre">myscript.py</span> <span class="pre">help</span> <span class="pre">me</span></code>
would not.</p>
<p>The point here is that we are embedding both the bounds check and the element
check into the same conditional. That’s because <code class="docutils literal notranslate"><span class="pre">==</span></code> on a container type (like
a <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">str</span></code>) checks two things: if containers have the same length and
the elements are the same. When we modified the code to compare lists instead
of strings, the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">len(sys.argv)</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> check became unnecessary because it’s
already built-in to the <code class="docutils literal notranslate"><span class="pre">==</span></code> comparison.</p>
<p>This trick works especially well when working with strings. Unlike with lists,
both <a class="reference internal" href="integer-indices.html"><span class="doc std std-doc">integer </span></a> and slice indices on a string result in
<a class="reference internal" href="integer-indices.html#strings-integer-indexing"><span class="std std-ref">another string</span></a>, so changing the code logic to work
in this way often only requires adding a <code class="docutils literal notranslate"><span class="pre">:</span></code> to the index so that it is a
slice that selects a single element instead of an integer index. For example,
consider a function like</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="c1"># Wrong for a = &#39;&#39;</span>
<span class="k">def</span> <span class="nf">ends_in_punctuation</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;!&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>This function is wrong for an empty string input: <code class="docutils literal notranslate"><span class="pre">ends_in_punctuation('')</span></code>
will raise <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>. This could be fixed by adding a length check. Or we
could simply change the <code class="docutils literal notranslate"><span class="pre">a[-1]</span></code> to <code class="docutils literal notranslate"><span class="pre">a[-1:]</span></code>. This will usually be a string
consisting of the last character, but if <code class="docutils literal notranslate"><span class="pre">a</span></code> is empty it will be <code class="docutils literal notranslate"><span class="pre">''</span></code>. The
<code class="docutils literal notranslate"><span class="pre">in</span></code> check will be correct either way.<a class="footnote-reference brackets" href="#string-check-footnote" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="c1"># Better</span>
<span class="k">def</span> <span class="nf">ends_in_punctuation</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;!&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>This sort of trick may seem scary and magic, but once you have digested this
guide and become comfortable with slice semantics, it is a natural and clean
way to embed length checks into comparison logic and avoid out of bounds
corner cases.</p>
</section>
<section id="steps">
<span id="id15"></span><h3>Steps<a class="headerlink" href="#steps" title="Link to this heading">¶</a></h3>
<p>If a third integer, <code class="docutils literal notranslate"><span class="pre">k</span></code>, is provided in a slice, such as <code class="docutils literal notranslate"><span class="pre">i:j:k</span></code>, it specifies
the step size. If <code class="docutils literal notranslate"><span class="pre">k</span></code> is not provided, the step size defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>Thus far, we have considered only slices with the default step size of 1. When
the <code class="docutils literal notranslate"><span class="pre">step</span></code> is greater than 1, the slice selects every <code class="docutils literal notranslate"><span class="pre">step</span></code>-th element within
the bounds defined by the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>.</p>
<blockquote>
<div><p><strong>The proper way to think about the <code class="docutils literal notranslate"><span class="pre">step</span></code> is that the slice starts at the
<code class="docutils literal notranslate"><span class="pre">start</span></code> and successively adds <code class="docutils literal notranslate"><span class="pre">step</span></code> until it reaches an index that is at or
past the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and then stops without including that index.</strong></p>
</div></blockquote>
<p>The important thing to remember about the <code class="docutils literal notranslate"><span class="pre">step</span></code> is that its presence does not
change the fundamental <a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a> of slices that we have learned so far.
The <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> still use <a class="reference internal" href="#based"><span class="std std-ref">0-based indexing</span></a>. The <code class="docutils literal notranslate"><span class="pre">stop</span></code> is
<a class="reference internal" href="#half-open"><span class="std std-ref">never included</span></a> in the slice. <a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative</span></a> <code class="docutils literal notranslate"><span class="pre">start</span></code>
and <code class="docutils literal notranslate"><span class="pre">stop</span></code> index from the end of the list. Out of bounds <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>
still <a class="reference internal" href="#clipping"><span class="std std-ref">clip</span></a> to the beginning or end of the list. And (see below) an
<a class="reference internal" href="#omitted"><span class="std std-ref">omitted</span></a> <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> still extends to the beginning or end of
<code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Let us consider an example where the step size is <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">0:6:3</span>] == ['a', 'd']</code>
<table>
  <tr>
    <td><pre>a</pre></td>
    <td><pre>=</pre></td>
    <td><pre>[</pre></td>
    <td class="underline-cell"><pre>'a',</pre></td>
    <td></td>
    <td><pre> 'b',</pre></td>
    <td></td>
    <td><pre> 'c',</pre></td>
    <td></td>
    <td class="underline-cell"><pre> 'd',</pre></td>
    <td></td>
    <td><pre> 'e',</pre></td>
    <td></td>
    <td><pre> 'f',</pre></td>
    <td></td>
    <td><pre>'g']</pre></td>
  </tr>
  <tr>
    <th>index</th>
    <td></td>
    <td></td>
    <td><div class="slice-diagram-selected circle-blue">0</div></td>
    <td></td>
    <td class="slice-diagram-not-selected">1</td>
    <td></td>
    <td class="slice-diagram-not-selected">2</td>
    <td></td>
    <td><div class="circle-blue slice-diagram-selected">3</div></td>
    <td></td>
    <td class="slice-diagram-not-selected">4</td>
    <td></td>
    <td class="slice-diagram-not-selected">5</td>
    <td></td>
    <td><div class="circle-red slice-diagram-not-selected">6</div></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td style="vertical-align: top; color: var(--color-slice-diagram-selected)">start</td>
    <td colspan="5" class="right-arrow-curved-cell"></td>
    <td></td>
    <td colspan="5" class="right-arrow-curved-cell"></td>
    <td class="slice-diagram-index-label-not-selected">&ge; stop</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td colspan="5" style="padding-top: 0; transform: translateY(-0.7em)">+3</td>
    <td></td>
    <td colspan="5" style="padding-top: 0; transform: translateY(-0.7em)">+3</td>
    <td></td>
</table>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">start</span></code> index, <code class="docutils literal notranslate"><span class="pre">0</span></code>, is included, but the <code class="docutils literal notranslate"><span class="pre">stop</span></code> index, <code class="docutils literal notranslate"><span class="pre">6</span></code>
(corresponding to <code class="docutils literal notranslate"><span class="pre">'g'</span></code>), is <em>not</em> included, even though it is a multiple of
<code class="docutils literal notranslate"><span class="pre">3</span></code> away from the start. This is because the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is <a class="reference internal" href="#half-open"><span class="std std-ref">never
included</span></a>.</p>
<p>It can be tempting to think about the <code class="docutils literal notranslate"><span class="pre">step</span></code> in terms of modular arithmetic.
In fact, it is often the case in practice that you require a <code class="docutils literal notranslate"><span class="pre">step</span></code> greater
than 1 because you are dealing with modular arithmetic in some way. However,
this requires care.</p>
<p>Indeed, the resulting indices <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code> from the slice <code class="docutils literal notranslate"><span class="pre">a[0:6:3]</span></code> are multiples
of 3. This is because the <code class="docutils literal notranslate"><span class="pre">start</span></code> index, <code class="docutils literal notranslate"><span class="pre">0</span></code>, is a multiple of 3. Choosing a
start index that is <span class="math notranslate nohighlight">\(1 \pmod{3}\)</span> would result in all indices also being <span class="math notranslate nohighlight">\(1
\pmod{3}\)</span>.</p>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">1:6:3</span>] == ['b', 'e']</code>
<table>
  <tr>
    <td><pre>a</pre></td>
    <td><pre>=</pre></td>
    <td><pre>['a',</pre></td>
    <td></td>
    <td class="underline-cell"><pre> 'b',</pre></td>
    <td></td>
    <td><pre> 'c',</pre></td>
    <td></td>
    <td><pre> 'd',</pre></td>
    <td></td>
    <td class="underline-cell"><pre> 'e',</pre></td>
    <td></td>
    <td><pre> 'f',</pre></td>
    <td></td>
    <td><pre>'g']</pre></td>
    <td></td>
  </tr>
  <tr>
    <th>index</th>
    <td></td>
    <td class="slice-diagram-not-selected">0</td>
    <td></td>
    <td><div class="circle-blue slice-diagram-selected">1</div></td>
    <td></td>
    <td class="slice-diagram-not-selected">2</td>
    <td></td>
    <td class="slice-diagram-not-selected">3</td>
    <td></td>
    <td><div class="circle-blue slice-diagram-selected">4</div></td>
    <td></td>
    <td class="slice-diagram-not-selected">5</td>
    <td></td>
    <td class="slice-diagram-not-selected">6</td>
    <td></td>
    <td><div class="circle-red slice-diagram-not-selected"></div></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td class="slice-diagram-index-label-selected">start</td>
    <td colspan="5" class="right-arrow-curved-cell"></td>
    <td></td>
    <td colspan="5" class="right-arrow-curved-cell"></td>
    <td class="slice-diagram-index-label-not-selected">&ge; stop</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td colspan="5" style="padding-top: 0; transform: translateY(-0.7em)">+3</td>
    <td></td>
    <td colspan="5" style="padding-top: 0; transform: translateY(-0.7em)">+3</td>
    <td></td>
  </tr>
</table>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;b&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>However, be careful, as this rule is <em>only</em> true when the <code class="docutils literal notranslate"><span class="pre">start</span></code> is
nonnegative. If the <code class="docutils literal notranslate"><span class="pre">start</span></code> is negative, the value of <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">%</span> <span class="pre">step</span></code> has no
bearing on the indices chosen for the slice:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">21</span><span class="p">))[</span><span class="o">-</span><span class="mi">15</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[6, 9, 12, 15, 18]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">22</span><span class="p">))[</span><span class="o">-</span><span class="mi">15</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[7, 10, 13, 16, 19]</span>
</pre></div>
</div>
<p>In the first case, <code class="docutils literal notranslate"><span class="pre">-15</span></code> is divisible by 3 and all the indices chosen by the
slice <code class="docutils literal notranslate"><span class="pre">-15::3</span></code> were also divisible by 3 (remember that indices and values are
the same for simple ranges). But this is only because the length of the list,
<code class="docutils literal notranslate"><span class="pre">21</span></code>, also happened to be a multiple of 3. In the second example it is <code class="docutils literal notranslate"><span class="pre">22</span></code>
and the resulting indices are not multiples of <code class="docutils literal notranslate"><span class="pre">3</span></code>. This caveat also applies
when the <a class="reference internal" href="#negative-steps"><span class="std std-ref">step is negative</span></a>.</p>
<p>Another thing to be aware of is that if the <code class="docutils literal notranslate"><span class="pre">start</span></code> is <a class="reference internal" href="#clipping"><span class="std std-ref">clipped</span></a>,
<strong>the clipping occurs <em>before</em> the step</strong>. Specifically, if the <code class="docutils literal notranslate"><span class="pre">start</span></code> is
less than <code class="docutils literal notranslate"><span class="pre">len(a)</span></code>, the <code class="docutils literal notranslate"><span class="pre">step</span></code>ed values are computed as if the <code class="docutils literal notranslate"><span class="pre">start</span></code> were
<code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">101</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>Because of these two caveats, you must be careful when using negative <code class="docutils literal notranslate"><span class="pre">start</span></code>
values with a <code class="docutils literal notranslate"><span class="pre">step</span></code>, and it’s better to avoid this if
possible.<a class="footnote-reference brackets" href="#negative-steps-ndindex-footnote" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> If the <code class="docutils literal notranslate"><span class="pre">start</span></code> is nonnegative,
then it <em>will</em> be true that the sliced indices will be equal to <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">%</span> <span class="pre">step</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># All the multiples of 3 up to 19</span>
<span class="go">[0, 3, 6, 9, 12, 15, 18]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># All the numbers that are 1 (mod 3)</span>
<span class="go">[1, 4, 7, 10, 13, 16, 19]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># All the numbers that are 2 (mod 3)</span>
<span class="go">[2, 5, 8, 11, 14, 17]</span>
</pre></div>
</div>
</section>
<section id="negative-steps">
<span id="id17"></span><h3>Negative Steps<a class="headerlink" href="#negative-steps" title="Link to this heading">¶</a></h3>
<p>Recall what we said <a class="reference internal" href="#steps"><span class="std std-ref">above</span></a>:</p>
<blockquote>
<div><p><strong>The proper way to think about the <code class="docutils literal notranslate"><span class="pre">step</span></code> is that the slice starts at
<code class="docutils literal notranslate"><span class="pre">start</span></code> and successively adds <code class="docutils literal notranslate"><span class="pre">step</span></code> until it reaches an index that is at or
past the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and then stops without including that index.</strong></p>
</div></blockquote>
<p>The key thing to remember with negative <code class="docutils literal notranslate"><span class="pre">step</span></code> values is that this rule still
applies. That is, the index starts at the <code class="docutils literal notranslate"><span class="pre">start</span></code> then adds the <code class="docutils literal notranslate"><span class="pre">step</span></code> (which
makes the index smaller), and stops when it is at or past the <code class="docutils literal notranslate"><span class="pre">stop</span></code>. Here “at
or past” means “greater than or equal to” if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive and “less
than or equal to” if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is negative.</p>
<p>Think of a slice as starting at the <code class="docutils literal notranslate"><span class="pre">start</span></code> and sliding along the list,
jumping along by <code class="docutils literal notranslate"><span class="pre">step</span></code>, and spitting out elements. Once you see that you are
at or have gone past the <code class="docutils literal notranslate"><span class="pre">stop</span></code> in the direction you are going (left for
negative <code class="docutils literal notranslate"><span class="pre">step</span></code> and right for positive <code class="docutils literal notranslate"><span class="pre">step</span></code>), you stop.</p>
<p>Unlike all the above examples, when the <code class="docutils literal notranslate"><span class="pre">step</span></code> is negative, generally the
<code class="docutils literal notranslate"><span class="pre">start</span></code> will be an index <em>after</em> the <code class="docutils literal notranslate"><span class="pre">stop</span></code> (otherwise the slice will be
<a class="reference internal" href="#empty-slice"><span class="std std-ref">empty</span></a>).</p>
<p>One of the most obvious features of negative <code class="docutils literal notranslate"><span class="pre">step</span></code> values is that unlike
every other slice we have seen so far, a negative <code class="docutils literal notranslate"><span class="pre">step</span></code> selects elements in
reversed order relative to the original list. In fact, one of the most common
uses of a negative <code class="docutils literal notranslate"><span class="pre">step</span></code> is the slice <code class="docutils literal notranslate"><span class="pre">a[::-1]</span></code>, which reverses the list:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
</pre></div>
</div>
<p>It is tempting therefore to think of a negative <code class="docutils literal notranslate"><span class="pre">step</span></code> as a “reversing”
operation. However, this is a bad way of thinking about negative steps. This
is because <code class="docutils literal notranslate"><span class="pre">a[i:j:-1]</span></code> is <em>not</em> equivalent to <code class="docutils literal notranslate"><span class="pre">reversed(a[j:i:1])</span></code>. The reason
for this is basically the same as was described in <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">wrong rule
1</span></a> above. The issue is that for <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code>, the <code class="docutils literal notranslate"><span class="pre">stop</span></code>
is <em>always</em> what is <a class="reference internal" href="#half-open"><span class="std std-ref">not included</span></a>, which means if we swap <code class="docutils literal notranslate"><span class="pre">i</span></code> and
<code class="docutils literal notranslate"><span class="pre">j</span></code>, we go from “<code class="docutils literal notranslate"><span class="pre">j</span></code> is not included” to “<code class="docutils literal notranslate"><span class="pre">i</span></code> is not included”. For example,
as <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">before</span></a>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># This is not the same thing</span>
<span class="go">[&#39;e&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<p>In the first case, index <code class="docutils literal notranslate"><span class="pre">3</span></code> is not included. In the second case, index <code class="docutils literal notranslate"><span class="pre">5</span></code> is
not included.</p>
<p>Worse, this way of thinking may even lead one to imagine the completely wrong
idea that <code class="docutils literal notranslate"><span class="pre">a[i:j:-1]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">reversed(a)[j:i]</span></code> (that is, that
<code class="docutils literal notranslate"><span class="pre">step=-1</span></code> somehow “reverses and then swaps the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>”):</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">))[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># Not the same as a[5:3:-1] as shown above</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<p>Once <code class="docutils literal notranslate"><span class="pre">a</span></code> is reversed, the indices <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code> have nothing to do with the
original indices <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code>. To see why, consider a much larger list:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[5, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)))[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[96, 95]</span>
</pre></div>
</div>
<p>Instead of thinking about “reversing”, it is much more conceptually robust to
think about the slice as starting at the <code class="docutils literal notranslate"><span class="pre">start</span></code>, then moving across every
<code class="docutils literal notranslate"><span class="pre">step</span></code>-th element until reaching the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, which is not included.</p>
<p>Negative steps can of course be less than −1 as well, with similar
behavior to steps greater than 1, again, keeping in mind that the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is
not included.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;g&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<div class="slice-diagram">
<code style="font-size: 16pt;">a[<span class="slice-diagram-slice">6:0:-3</span>] == ['g', 'd']</code>
<table>
  <tr>
    <td><pre>a</pre></td>
    <td><pre>=</pre></td>
    <td><pre>['a',</pre></td>
    <td></td>
    <td><pre> 'b',</pre></td>
    <td></td>
    <td><pre> 'c',</pre></td>
    <td></td>
    <td class="underline-cell"><pre> 'd',</pre></td>
    <td></td>
    <td><pre> 'e',</pre></td>
    <td></td>
    <td><pre> 'f',</pre></td>
    <td></td>
    <td class="underline-cell"><pre>'g'</pre></td>
    <td><pre>]</pre></td>
  </tr>
  <tr>
    <th>index</th>
    <td></td>
    <td><div class="circle-red slice-diagram-not-selected">0</div></td>
    <td></td>
    <td class="slice-diagram-not-selected">1</td>
    <td></td>
    <td class="slice-diagram-not-selected">2</td>
    <td></td>
    <td><div class="circle-blue slice-diagram-selected">3</div></td>
    <td></td>
    <td class="slice-diagram-not-selected">4</td>
    <td></td>
    <td class="slice-diagram-not-selected">5</td>
    <td></td>
    <td><div class="circle-blue slice-diagram-selected">6</div></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td class="slice-diagram-index-label-not-selected">&le; stop</td>
    <td colspan="5" class="left-arrow-curved-cell"></td>
    <td></td>
    <td colspan="5" class="left-arrow-curved-cell"></td>
    <td class="slice-diagram-index-label-selected">start</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td colspan="5" style="padding-top: 0; transform: translateY(-0.7em)">&minus;3</td>
    <td></td>
    <td colspan="5" style="padding-top: 0; transform: translateY(-0.7em)">&minus;3</td>
    <td></td>
    <td></td>
</table>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">step</span></code> can never be equal to 0. This unconditionally produces an error:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">slice step cannot be zero</span>
</pre></div>
</div>
</section>
<section id="omitted-entries">
<span id="omitted"></span><h3>Omitted Entries<a class="headerlink" href="#omitted-entries" title="Link to this heading">¶</a></h3>
<p>The final point of confusion is omitted entries.<a class="footnote-reference brackets" href="#omitted-none-footnote" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a></p>
<p><strong>The best way to think about omitted entries is just that, as omitted
entries.</strong> That is, for a slice like <code class="docutils literal notranslate"><span class="pre">a[:i]</span></code>, think of it as the <code class="docutils literal notranslate"><span class="pre">start</span></code> being
omitted, and the <code class="docutils literal notranslate"><span class="pre">stop</span></code> equal to <code class="docutils literal notranslate"><span class="pre">i</span></code>. Conversely, <code class="docutils literal notranslate"><span class="pre">a[i:]</span></code> has the <code class="docutils literal notranslate"><span class="pre">start</span></code> as <code class="docutils literal notranslate"><span class="pre">i</span></code>
and the <code class="docutils literal notranslate"><span class="pre">stop</span></code> omitted. The <em>wrong way</em> to think about these is as a colon
being before or after the index <code class="docutils literal notranslate"><span class="pre">i</span></code>. Thinking about it this way will only lead
to confusion, because you won’t be thinking about <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>, but
rather trying to remember some rule based on where a colon is. But the colons
in a slice are not <em>indicators</em>; they are <em>separators</em>.</p>
<p>As to the semantic meaning of omitted entries, the easiest one is the <code class="docutils literal notranslate"><span class="pre">step</span></code>.</p>
<blockquote>
<div><p><strong>If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is omitted, it always defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</strong></p>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is omitted the second colon can also be omitted. That is to say,
the following are all completely equivalent<a class="footnote-reference brackets" href="#equivalent-slices-footnote" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">:]</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<!-- TODO: Better wording for this rule? -->
<blockquote>
<div><p><strong>For the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>, the rule is that being omitted extends the
slice all the way to the beginning or end of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the direction being
sliced.</strong></p>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive, this means <code class="docutils literal notranslate"><span class="pre">start</span></code> extends to the beginning of <code class="docutils literal notranslate"><span class="pre">a</span></code>
and <code class="docutils literal notranslate"><span class="pre">stop</span></code> extends to the end. If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is negative, this is reversed:
<code class="docutils literal notranslate"><span class="pre">start</span></code> extends to the end of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> extends to the beginning.</p>
<p>Writing down the rule in this way makes it sound more confusing than it really
is. Simply put, omitting the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> of a slice will make it slice
“as much as possible” instead.</p>
<div class="slice-diagram">
    <code style="font-size: 16pt;">a[<span class="slice-diagram-slice">:3</span>] == a[<span class="slice-diagram-slice">:3:1</span>] == ['a', 'b', 'c']</code>
    <table>
        <tr>
            <td><pre>a</pre></td>
            <td><pre>=</pre></td>
            <td><pre>[</pre></td>
            <td class="underline-cell"><pre>'a',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'b',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'c',</pre></td>
            <td></td>
            <td><pre> 'd',</pre></td>
            <td></td>
            <td><pre> 'e',</pre></td>
            <td></td>
            <td><pre> 'f',</pre></td>
            <td></td>
            <td><pre> 'g'</pre></td>
            <td><pre>]</pre></td>
        </tr>
        <tr>
            <th>index</th>
            <td></td>
            <td></td>
            <td><div class="circle-blue slice-diagram-selected">0</div></td>
            <td class="right-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(-3px)">+1</div></td>
            <td><div class="circle-blue slice-diagram-selected">1</div></td>
            <td class="right-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(-3px)">+1</div></td>
            <td><div class="circle-blue slice-diagram-selected">2</div></td>
            <td class="right-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(-3px)">+1</div></td>
            <td><div class="circle-red slice-diagram-not-selected">3</div></td>
            <td></td>
            <td class="slice-diagram-not-selected">4</td>
            <td></td>
            <td class="slice-diagram-not-selected">5</td>
            <td></td>
            <td class="slice-diagram-not-selected">6</td>
            <td></td>
        </tr>
        <tr>
            <th></th>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-selected">
                <div class="overflow-content">start (beginning)</div>
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-not-selected">stop</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
</div>
<div class="slice-diagram">
    <code style="font-size: 16pt;">a[<span class="slice-diagram-slice">3:</span>] == a[<span class="slice-diagram-slice">3::1</span>] == ['d', 'e', 'f', 'g']</code>
    <table>
        <tr>
            <td><pre>a</pre></td>
            <td><pre>=</pre></td>
            <td><pre>[</pre></td>
            <td><pre>'a',</pre></td>
            <td></td>
            <td><pre> 'b',</pre></td>
            <td></td>
            <td><pre> 'c',</pre></td>
            <td></td>
            <td class="underline-cell"><pre> 'd',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'e',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'f',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'g'</pre></td>
            <td><pre>]</pre></td>
        </tr>
        <tr>
            <th>index</th>
            <td></td>
            <td></td>
            <td class="slice-diagram-not-selected">0</td>
            <td></td>
            <td class="slice-diagram-not-selected">1</td>
            <td></td>
            <td class="slice-diagram-not-selected">2</td>
            <td></td>
            <td><div class="circle-blue slice-diagram-selected">3</div></td>
            <td class="right-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(-3px)">+1</div></td>
            <td><div class="circle-blue slice-diagram-selected">4</div></td>
            <td class="right-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(-3px)">+1</div></td>
            <td><div class="circle-blue slice-diagram-selected">5</div></td>
            <td class="right-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(-3px)">+1</div></td>
            <td><div class="circle-blue slice-diagram-selected">6</div></td>
            <td></td>
        </tr>
        <tr>
            <th></th>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-selected">start</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-selected">
                <div class="overflow-content">stop (end)</div>
            <td></td>
            </td>
        </tr>
    </table>
</div>
<div class="slice-diagram">
    <code style="font-size: 16pt;">a[<span class="slice-diagram-slice"><span class="slice-diagram-slice">:3:-1</span></span>] == ['g', 'f', 'e']</code>
    <table>
        <tr>
            <td><pre>a</pre></td>
            <td><pre>=</pre></td>
            <td><pre>[</pre></td>
            <td><pre>'a',</pre></td>
            <td></td>
            <td><pre> 'b',</pre></td>
            <td></td>
            <td><pre> 'c',</pre></td>
            <td></td>
            <td><pre> 'd',</pre></td>
            <td></td>
            <td class="underline-cell"><pre> 'e',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'f',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'g'</pre></td>
            <td><pre>]</pre></td>
        </tr>
        <tr>
            <th>index</th>
            <td></td>
            <td></td>
            <td class="slice-diagram-not-selected">0</td>
            <td></td>
            <td class="slice-diagram-not-selected">1</td>
            <td></td>
            <td class="slice-diagram-not-selected">2</td>
            <td></td>
            <td><div class="circle-red slice-diagram-not-selected">3</div></td>
            <td class="left-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(3px)">&minus;1</div></td>
            <td><div class="circle-blue slice-diagram-selected">4</div></td>
            <td class="left-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(3px)">&minus;1</div></td>
            <td><div class="circle-blue slice-diagram-selected">5</div></td>
            <td class="left-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(3px)">&minus;1</div></td>
            <td><div class="circle-blue slice-diagram-selected">6</div></td>
            <td></td>
        </tr>
        <tr>
            <th></th>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-not-selected">stop</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-selected">
                <div class="overflow-content">start (end)</div>
            </td>
            <td></td>
        </tr>
    </table>
</div>
<div class="slice-diagram">
    <code style="font-size: 16pt;">a[<span class="slice-diagram-slice">3::-1</span>] == ['d', 'c', 'b', 'a']</code>
    <table>
        <tr>
            <td><pre>a</pre></td>
            <td><pre>=</pre></td>
            <td><pre>[</pre></td>
            <td class="underline-cell"><pre>'a',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'b',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'c',</pre></td>
            <td class="underline-cell"></td>
            <td class="underline-cell"><pre> 'd',</pre></td>
            <td></td>
            <td><pre> 'e',</pre></td>
            <td></td>
            <td><pre> 'f',</pre></td>
            <td></td>
            <td><pre> 'g'</pre></td>
            <td><pre>]</pre></td>
        </tr>
        <tr>
            <th>index</th>
            <td></td>
            <td></td>
            <td><div class="circle-blue slice-diagram-selected">0</div></td>
            <td class="left-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(3px)">&minus;1</div></td>
            <td><div class="circle-blue slice-diagram-selected">1</div></td>
            <td class="left-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(3px)">&minus;1</div></td>
            <td><div class="circle-blue slice-diagram-selected">2</div></td>
            <td class="left-arrow-cell"><div style="font-size: smaller; transform: translateY(-12px) translateX(3px)">&minus;1</div></td>
            <td><div class="circle-blue slice-diagram-selected">3</div></td>
            <td></td>
            <td class="slice-diagram-not-selected">4</td>
            <td></td>
            <td class="slice-diagram-not-selected">5</td>
            <td></td>
            <td class="slice-diagram-not-selected">6</td>
            <td></td>
        </tr>
        <tr>
            <th></th>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-selected">
                <div class="overflow-content">stop (beginning)</div>
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td class="slice-diagram-index-label-selected">start</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># From the beginning to index 3 (but not including index 3)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="c1"># From index 3 to the end</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># From the end to index 3 (but not including index 3), reversed</span>
<span class="go">[&#39;g&#39;, &#39;f&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># From index 3 to the beginning, reversed</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
</pre></div>
</div>
<p>A slice with both <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> omitted, <code class="docutils literal notranslate"><span class="pre">a[:]</span></code>, therefore is just all of
<code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is a <code class="docutils literal notranslate"><span class="pre">list</span></code>, this is a convenient way of creating a (shallow) copy of
<code class="docutils literal notranslate"><span class="pre">a</span></code>.<a class="footnote-reference brackets" href="#tuple-copy-footnote" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a> On the other hand, if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a NumPy array, this is
a convenient way of creating a <a class="reference internal" href="other-topics.html#views-vs-copies"><span class="std std-ref">view</span></a> of all of <code class="docutils literal notranslate"><span class="pre">a</span></code> (which is
<em>not</em> a copy). Or more commonly, <code class="docutils literal notranslate"><span class="pre">:</span></code> is used to select an entire axis in a
<a class="reference internal" href="multidimensional-indices/index.html"><span class="std std-doc">multidimensional index</span></a>.</p>
</section>
</section>
<section id="soapbox">
<h2>Soapbox<a class="headerlink" href="#soapbox" title="Link to this heading">¶</a></h2>
<p>While this guide is opinionated about the right and wrong ways to think about
slices in Python, I have tried to stay neutral regarding the merits of the
rules themselves. But I want to take a moment to give my views on them. I have
worked with slice objects quite a bit in building ndindex, as well as just
general usage with Python and NumPy.</p>
<p>Without a doubt, Python’s slice syntax is extremely expressive and
straightforward. However, simply put, the semantic rules for slices are
completely bonkers. They lend themselves to several invalid interpretations,
which I have outlined above, and which seem valid at first glance but fall
apart in corner cases. The “correct” ways to think about slices are very
particular. I have tried to <a class="reference internal" href="#rules"><span class="std std-ref">outline</span></a> them carefully, but one gets the
impression that unless one works with slices regularly, it will be hard to
remember the “right” ways and not fallback to thinking about the “wrong” ways,
or, as most Python programmers probably do, simply “guessing and checking” and
probably not correctly handling corner cases.</p>
<p>Furthermore, the discontinuous nature of the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> parameters not
only makes it hard to remember how slices work but it also makes it <em>extremely</em>
hard to write slice arithmetic (i.e., for anyone implementing <code class="docutils literal notranslate"> <span class="pre">__getitem__</span></code>
or <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> that accepts slices matching the standard semantics). The
arithmetic is already hard enough due to the modular nature of <code class="docutils literal notranslate"><span class="pre">step</span></code>, but the
discontinuous aspect of <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> increases this tenfold. If you are
unconvinced of this, take a look at the <a class="reference external" href="https://github.com/Quansight-labs/ndindex/blob/main/ndindex/slice.py">source
code</a>
for <code class="docutils literal notranslate"><span class="pre">ndindex.Slice()</span></code>. You will see lots of nested <code class="docutils literal notranslate"><span class="pre">if</span></code>
blocks.<a class="footnote-reference brackets" href="#source-footnote" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> This is because slices have <em>fundamentally</em>
different definitions if the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, negative, or
nonnegative. Furthermore, <code class="docutils literal notranslate"><span class="pre">None</span></code> is not an integer, so one must always be
careful to either check for it first or to be certain that it cannot happen,
before performing any arithmetical operation or numerical comparison. Under
each <code class="docutils literal notranslate"><span class="pre">if</span></code> block you will see some formula or other. Many of these formulas
were difficult to come up with. In many cases they are asymmetrical in
surprising ways. It is only through the rigorous <a class="reference internal" href="../index.html#testing"><span class="std std-ref">testing</span></a> that
ndindex uses that I can have confidence the formulas are correct for all
corner cases.</p>
<p>I believe that Python’s slicing semantics could remain just as expressive
while being less confusing and easier to work with for both end-users and
developers writing slice arithmetic (a typical user of ndindex). The changes I
would make to improve the semantics would be</p>
<ol class="arabic simple">
<li><p>Remove the special meaning of negative numbers.</p></li>
<li><p>Use 1-based indexing instead of 0-based indexing.</p></li>
<li><p>Make a slice always include both the start and the stop.</p></li>
</ol>
<!-- This comment is here to force Markdown to reset the numbering -->
<ol class="arabic">
<li><p><strong>Negative numbers.</strong> The special meaning of negative numbers, to index
from the end of the list, is by far the biggest problem with Python’s slice
semantics. It introduces a fundamental discontinuity to the definition of
an index. This makes it completely impossible to write a formula for almost
anything relating to slices that will not end up having branching <code class="docutils literal notranslate"><span class="pre">if</span></code>
conditions. But the problem isn’t just for code that manipulates slices.
The <a class="reference internal" href="#negative-indices-example"><span class="std std-ref">example above</span></a> shows how negative indices
can easily lead to bugs in end-user code. Effectively, any time you have a
slice <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code>, if <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> are nontrivial expressions, they must be
checked to ensure they do not go negative. If they can be both negative and
nonnegative, it is virtually never the case that the slice will give you
what you want in both cases. This is because the discontinuity inherent in
the definition of <a class="reference internal" href="#negative-indices"><span class="std std-ref">negative indexing</span></a> disagrees with the
concept of <a class="reference internal" href="#clipping"><span class="std std-ref">clipping</span></a>. <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> will slice “as far as it can” if
<code class="docutils literal notranslate"><span class="pre">j</span></code> is “too big” (greater than <code class="docutils literal notranslate"><span class="pre">len(a)</span></code>), but it does something completely
different if <code class="docutils literal notranslate"><span class="pre">i</span></code> is “too small” as soon as “too small” means “negative”.
Clipping is a good idea. It tends to lead to behavior that gives what you
would want for slices that go out of bounds.</p>
<p>Negative indexing is, strictly speaking, a syntactic sugar only.
Slicing/indexing from the end of a list can always be done in terms of the
length of the list. <code class="docutils literal notranslate"><span class="pre">a[-x]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">a[len(a)-x]</span></code> (when using
0-based indexing), but the problem is that it is tedious to write <code class="docutils literal notranslate"><span class="pre">a</span></code>
twice, and <code class="docutils literal notranslate"><span class="pre">a</span></code> may in fact be a larger expression, so writing <code class="docutils literal notranslate"><span class="pre">a[len(a)-x]</span></code>
would require assigning it to a variable. It also becomes more complicated
when <code class="docutils literal notranslate"><span class="pre">a</span></code> is a NumPy array and the slice appears as part of a larger
multidimensional (tuple) index. However, I think it would be possible to
introduce a special syntax to mean “reversed” or “from the end the list”
indexing, and leave negative numbers to simply extend beyond the left side
of a list with clipping. For example, in <a class="reference external" href="https://julialang.org/">Julia</a>,
one can use <code class="docutils literal notranslate"><span class="pre">a[end]</span></code> to index the last element of an array (Julia also uses
1-based indexing). Since this is a moot point for Python—I don’t expect
Python’s indexing semantics to change; they are already baked into the
language—I won’t suggest any syntax. Perhaps this can inspire people
writing new languages or DSLs to come up with better semantics backed by
good syntax (again, I think Python slicing has good <em>syntax</em>. I only take
issue with some of its <em>semantics</em>).</p>
</li>
<li><p><strong>0-based vs. 1-based indexing.</strong> The suggestion to switch from 0-based to
1-based indexing is likely to be the most controversial. For many people
reading this, the notion that 0-based indexing is superior has been
preached as irreproachable gospel. I encourage you to open your mind and
try to unlearn what you have been taught and take a fresh view of the
matter. (Or don’t. These are just my opinions after all, and none of it
changes the fact that Python is what it is and isn’t going to change.)</p>
<p>0-based indexing certainly has its uses. In C, where an index is literally
a syntactic macro for adding two pointers, 0-based indexing makes sense,
since <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> literally means <code class="docutils literal notranslate"><span class="pre">*(a</span> <span class="pre">+</span> <span class="pre">i)</span></code> under those semantics. However, for
higher level languages such as Python, people think of indexing as pointing
to specific numbered elements of a collection, not as pointer arithmetic.
Every human being is taught from an early age to count from 1. If you show
someone the list “a, b, c”, they will tell you that “a” is the 1st, “b” is
the 2nd, and “c” is the 3rd. <a class="reference internal" href="integer-indices.html#fourth-sentence"><span class="std std-ref">Sentences</span></a> in this guide
like “<code class="docutils literal notranslate"><span class="pre">a[3]</span></code> selects the fourth element of <code class="docutils literal notranslate"><span class="pre">a</span></code>” sound very off, even for
those of us used to 0-based indexing. 0-based indexing requires a shift in
thinking from the way that you have been taught to count from early
childhood. Counting is a very fundamental thing for any human, but
especially so for a programmer. Forcing someone to learn a new way to do
such a foundational thing is a huge cognitive burden, and so it shouldn’t
be done without a very good reason. In a language like C, one can argue
there is a good reason, just as one can argue that it is beneficial to
learn new base number systems like base-2 and base-16 when doing certain
kinds of programming.</p>
<p>But for Python, what are the true benefits of counting starting at 0? The
main benefit is that the implementation is easier, because Python is itself
written in C, which uses 0-based indexing, so Python does not need to
handle shifting in the translation. But this has never been a valid
argument for Python semantics. The whole point of Python is to provide
higher level semantics than C, and leave those hard details of translating
them to the interpreter and library code. In fact, Python’s slices
themselves are much more complicated than what is available in C, and the
interpreter code to handle them is more than just a trivial translation to
C. Adding shifts to this translation code would not be much additional
complexity.</p>
<p>The other advantage of 0-based indexing is that it makes it easier for
people who know C to learn Python. This may have been a good reason when
Python was new, but <a class="reference external" href="https://www.tiobe.com/tiobe-index/">now more people know Python than
C</a>. A good programming language like
Python should strive to be better than its predecessors, not let itself be
dragged behind by them.</p>
<p>Even experienced programmers of languages like Python that use 0-based
indexing must occasionally stop themselves from writing something like
<code class="docutils literal notranslate"><span class="pre">a[3]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">a[2]</span></code> to get the third element of <code class="docutils literal notranslate"><span class="pre">a</span></code>. It is very
difficult to “unlearn” 1-based counting, which was not only the first way
that you learned to count, but is also the way that you and everyone else
around you continues to count outside of programming contexts.</p>
<p>When you teach a child how to count things, you teach them to enumerate the
items starting at 1. For example, 🍎🍎🍎🍎 is “4 apples” because you count
them off, “1, 2, 3, 4.” The number that is enumerated for the final object
is equal to the number of items (in technical terms, the final
<a class="reference external" href="https://en.wikipedia.org/wiki/Ordinal_number">ordinal</a> is equal to the
<a class="reference external" href="https://en.wikipedia.org/wiki/Cardinal_number">cardinal</a>). This only works
if you start at 1. If the child instead starts at 0 (“0, 1, 2, 3”), the
final ordinal (the last number spoken aloud) would not match the cardinal
(the number of items). The distinction between ordinals and cardinals is
not something most people think about often, because the convention of
counting starting at 1 makes it so that they are equal. But as programmers
in a language that rejects this elegant convention, we are forced to think
about such philosophical distinctions just to solve whatever problem we are
trying to solve.</p>
<p>In most instances (outside of programming) where a reckoning starts at 0
instead of 1, it is because it is measuring a distance. The distance from
your house to your friend’s house may be “2 miles”, but the distance from
your house to itself is “0 miles”. On the other hand, when counting or
enumerating individual objects, counting always starts at 1. The notion of
a “zeroth” object doesn’t make sense when counting, say, apples, because
you are counting the apples themselves, not some quantity relating them.</p>
<p>So the question then becomes, should indexing work like a measurement of
distance, which would naturally start at 0, or like an enumeration of
distinct terms, which would naturally start at 1? If we think of an index
as a pointer offset, as C does, then it is indeed a measurement of a
distance. But if we instead think of an indexable list as a discrete
ordered collection of items, then the notion of a measurement of distance
is harder to justify. But enumeration is a natural concept for any ordered
discrete collection.</p>
<p>What are the benefits of 0-based indexing?</p>
<ul class="simple">
<li><p>It makes translation to lower level code (like C or machine code) easier.
But as I already argued, this is not a valid argument for Python, which
aims to be high-level and abstract away translation complexities that
make coding more difficult. The translation that necessarily takes place
in the interpreter itself can afford this complexity if it means making
the language itself simpler.</p></li>
<li><p>It makes translation from code written in other languages that use
0-based indexing simpler. If Python used 1-based indexing, then to
translate a C algorithm to Python, for instance, one would have to adapt
all the places that use indexing, which would be a bug-prone task. But
Python’s primary mantra is having syntax and semantics that make code
easy to read and easy to write. Being similar to other existing languages
is second to this, and should not take priority when it conflicts with
it. Translation of code from other languages to Python does happen, but
it is much rarer than novel code written in Python. Furthermore,
automated tooling could be used to avoid translation bugs. Such tooling
would help avoid other translation bugs unrelated to indexing as well.</p></li>
<li><p>It works nicely with half-open semantics. It is true that half-open
semantics and 0-based indexing, while technically distinct, are virtually
always implemented together because they play so nicely with each other.
However, as I argue below, half-open semantics are just as absurd as
0-based indexing, and abandoning both for the more standard
closed-closed/1-based semantics is very reasonable.</p></li>
</ul>
<p>To me, the ideal indexing system defaults to 1-based, but allows starting
at any index. That way, if you are dealing with a use case where 0-based
indexing really does make more sense, you can easily use it. Indices should
also be able to start at any other number, including negative numbers
(which is another reason to remove the special meaning of negative
indices). An example of a use case where 0-based indexing truly is more
natural than 1-based indexing is polynomials. Say we have a polynomial <!--
--> <span class="math notranslate nohighlight">\(a_0 + a_1x + a_2x^2 + \cdots\)</span>. Then we can represent the coefficients
<span class="math notranslate nohighlight">\(a_0, a_1, a_2, \ldots\)</span> in a list <code class="docutils literal notranslate"><span class="pre">[a0,</span> <span class="pre">a1,</span> <span class="pre">a2,</span> <span class="pre">...]</span></code>. Since a polynomial
naturally has a 0th coefficient, it makes sense to index the list starting
at 0 (though even then, one must still be careful about off-by-one errors,
e.g., a degree-<span class="math notranslate nohighlight">\(n\)</span> polynomial has <span class="math notranslate nohighlight">\(n+1\)</span> coefficients).</p>
<p>If this seems like absurd idea, note that this is how Fortran works (see
<a class="reference external" href="https://www.fortran90.org/src/faq.html#what-is-the-most-natural-starting-index-for-numbering">https://www.fortran90.org/src/faq.html#what-is-the-most-natural-starting-index-for-numbering</a>).
In Fortran, arrays index starting at 1 by default, but any integer can be
used as a starting index. Fortran predates Python by many decades, but is
still in use today, particularly in scientific applications, and many
Python libraries themselves such as SciPy are backed by Fortran code. These
codes tend to be very mathematical and may make heavy use of indexing (for
instance, linear algebra packages like BLAS and LAPACK). Many other popular
programming languages use 1-based indexing, such as Julia, MATLAB,
Mathematica, R, Lua, and
<a class="reference external" href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)#Array_system_cross-reference_list">others</a>.
In fact, a majority of the popular programming languages that use 1-based
indexing are languages that are primarily used for scientific applications.
Scientific applications tend to make much heavier use of arrays than most
other programming tasks, and hence a heavy use of indexing.</p>
</li>
<li><p><strong>Half-open semantics.</strong> Finally, the idea of half-open semantics, where the
<code class="docutils literal notranslate"><span class="pre">stop</span></code> value of a slice is never included, is bad, for many of the same
reasons that 0-based indexing is bad. In most contexts outside of programming,
including virtually all mathematical contexts, when one sees a range of
values, it is implicitly assumed that both endpoints are included in the
range. For example, if you see a phrase like “ages 7 to 12”, “the letters A to
Z”, or “sum of the numbers from 1 to 10”, without any further qualification
you assume that both endpoints are included in the range. Half-open semantics
also break down when considering non-numeric quantities. For example, one
cannot represent the set of letters “from A to Z” except by including both
endpoints, as there is no letter after Z to not include.</p>
<p>It is simply more natural to think about a range as including both endpoints.
Half-open semantics are often tied to 0-based indexing, since it is a
convenient way to allow the range 0–N to contain N values, by not including
N.<a class="footnote-reference brackets" href="#python-history-footnote" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a> I see this as taking a bad decision (0-based
indexing) and putting a bad bandaid on it that makes it worse. But certainly
this argument goes away for 1-based indexing. The range 1–N contains N values
exactly when N <em>is</em> included in the range.</p>
<p>You might argue that there are instances in everyday life where half-open as
well as 0-based semantics are used. For example, in the West, the reckoning of
a person’s age is typically done in a way that matches half-open 0-based
indexing semantics. If has been less than 1 year since a person’s birthdate,
you might say they are “zero years old” (although typically you use a smaller
unit of measure such as months to avoid this). And if tomorrow is my 30th
birthday, then today I will say, “I am 29 years old”, even though I am
actually 29.99 years old (I may continue to say “I am 29 years old” tomorrow,
but at least today no one could accuse me of lying). This matches the
“half-open” semantics used by slices. The end date of an age, the birthday, is
not accounted for until it has passed. This example shows that half-open
semantics do indeed go nicely with 0-based counting, and it’s indeed typically
good to use one when using the other. But age is a distance. It is the
distance in time since a person’s birthdate. So 0-based indexing makes sense
for it. Half-open semantics play nicely with age not just because it lets us
lie to ourselves about being younger than we really are, but because age is a
continuous quantity which is reckoned by integer values for convenience. Since
people rarely concern themselves with fractional ages, they must increment an
age counter at some point, and doing so on a birthday, which leads to a
“half-open” semantic, makes sense. But a collection of items like a list,
array, or string in Python usually does not represent a continuous quantity
which is discretized, but rather a quantity that is naturally discrete. So
while half-open 0-indexed semantics are perfectly reasonable for human ages,
the same argument doesn’t make sense for collections in Python.</p>
<p>When it comes to indexing, half-open semantics are problematic for a few
reasons:</p>
<ul>
<li><p>A commonly touted benefit of half-open slicing semantics is that you can
“glue” half-open intervals together. For example, <code class="docutils literal notranslate"><span class="pre">a[0:N]</span> <span class="pre">+</span> <span class="pre">a[N:M]</span></code> is
the same as <code class="docutils literal notranslate"><span class="pre">a[0:M]</span></code>. But <code class="docutils literal notranslate"><span class="pre">a[1:N]</span> <span class="pre">+</span> <span class="pre">a[N+1:M]</span></code> is just as clear. People
are perfectly used to adding 1 to get to the next term in a sequence, and
it is easier to see that <code class="docutils literal notranslate"><span class="pre">[1:N]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N+1:M]</span></code> are non-overlapping if
they do not share endpoint values. Ranges that include both endpoints are
standard in both everyday language and mathematics. <span class="math notranslate nohighlight">\(\sum_{i=1}^n\)</span> means
a summation from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span> inclusive. Formulas like <span class="math notranslate nohighlight">\(\sum_{i=1}^n a_i =
\sum_{i=1}^k a_i + \sum_{i=k+1}^n a_i\)</span> are natural to anyone who has
studied enough mathematics. If you were to say “the first <span class="math notranslate nohighlight">\(n\)</span> numbers are
<span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n+1\)</span>; the next <span class="math notranslate nohighlight">\(n\)</span> numbers are <span class="math notranslate nohighlight">\(n+1\)</span> to <span class="math notranslate nohighlight">\(2n+1\)</span>”, or “‘the 70s’
refers to the years 1970–1980”, imagining “to” and “–” to mean
half-open semantics, anyone would tell you were wrong.</p></li>
<li><p>Another benefit of half-open intervals is that they allow the range <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code>
to contain <span class="math notranslate nohighlight">\(j - i\)</span> elements (assuming <span class="math notranslate nohighlight">\(0 \leq i \leq j\)</span> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is large
enough). I tout this myself in the guide above, since it is a useful <a class="reference internal" href="#sanity-check"><span class="std std-ref">sanity
check</span></a>. However, as useful as it is, it isn’t worth the more
general confusion caused by half-open semantics. I contend people are
perfectly used to the usual <a class="reference internal" href="#fencepost"><span class="std std-ref">fencepost</span></a> offset that a range
<span class="math notranslate nohighlight">\(i\ldots j\)</span> contains <span class="math notranslate nohighlight">\(j - i + 1\)</span> numbers. Half-open semantics replace this
fencepost error with more subtle ones, which arise from forgetting that the
range doesn’t include the endpoint, unlike most natural ranges that occur in
day-to-day life. See <a class="reference internal" href="#wrong-rule-3"><span class="std std-ref">wrong rule 3</span></a> above for an example of how
half-open semantics can lead to subtle fencepost errors.</p>
<p>It is true that including both endpoints in range can lead to <a class="reference internal" href="#fencepost"><span class="std std-ref">fencepost
errors</span></a>. But the fencepost problem is fundamentally unavoidable. A
100 foot fence truly has one more fencepost than fence lengths. The best way
to deal with the fencepost problem is not to try to change the way we count
fenceposts, so that somehow 11 fenceposts is really only
10.<a class="footnote-reference brackets" href="#fencepost-footnote" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a> It is rather to reuse the most natural and intuitive
way of thinking about the problem, which occurs both in programming and
non-programming contexts, which is that certain quantities, like the number of
elements in a range <span class="math notranslate nohighlight">\(1\ldots N\)</span>, will require an extra “<span class="math notranslate nohighlight">\(+\,1\)</span>” to be correct.</p>
</li>
</ul>
<ul>
<li><p>Half-open semantics become particularly confusing when the step is negative.
This is because one must remember that the end that is not included in the
half-open interval is the second index in the slice, <em>not</em> the larger index
(see wrong rules <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">1</span></a> and <a class="reference internal" href="#wrong-rule-3"><span class="std std-ref">3</span></a> above). Were both
endpoints included, this confusion would be impossible, because positive and
negative steps would be symmetric in this regard.</p></li>
<li><p>Half-open semantics are generally undesirable to apply to extensions to
slicing on non-integer labels. For example, the pandas
<a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc" title="(in pandas v2.2.2)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">loc</span></code></a> attribute allows slicing
string labels (like <code class="docutils literal notranslate"><span class="pre">df.loc['a':'f']</span></code>), but this syntax always includes
both ends. This is because when you slice on labels, you probably aren’t
thinking about which label comes before or after the one you want, and
you might not even know. But this same reasoning also applies to
integers. You’re probably thinking about the index that you want to slice
up to, not the one before or after it.</p>
<p>Furthermore, if label slicing used half-open semantics, to slice to the end
of the sequence, you’d have to use an <a class="reference internal" href="#omitted"><span class="std std-ref">omitted</span></a> <code class="docutils literal notranslate"><span class="pre">end</span></code>, instead of
just using the last label. With integers you can get away with this because
<a class="reference external" href="https://en.wikipedia.org/wiki/Archimedean_property">there is always a bigger
integer</a>, but this
property doesn’t apply to other types of label objects.</p>
</li>
</ul>
<p>In general, half-open semantics are naïvely superior because they have some
properties that appear to be nice (easy unions, no +1s in length formulas).
But the “niceness” of these properties ignores the fact that most people
are already used to closed-closed intervals from mathematics and from
everyday life, and so are used to accounting for them already. So while
these properties are nice, they also break the natural intuition of how
ranges work. Half-open semantics are also closely tied to 0-based indexing,
which as I argued above, is itself problematic for many of the same
reasons.</p>
</li>
</ol>
<p>Again, there is no way Python itself can change any of these things at this
point. It would be way too big of a change to the language, far bigger than
any change that was made as part of Python 3 (and the Python developers have
already stated that they will never do a big breaking change like Python 3
again). But I hope I can inspire new languages and DSLs that include slicing
semantics to be written in clearer ways. And I also hope that I can break some
of the cognitive dissonance that leads people to believe that the Python
slicing rules are superior, despite the endless confusion that they provide.</p>
<p>Finally, I believe that simply understanding that Python has made these
decisions, whether you agree with them or not, will help you to remember the
slicing <a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a>, and that’s my true goal here.</p>
<p class="rubric">Footnotes</p>
<!-- Footnotes are written inline above but markdown will put them here at the
end of the document. -->
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="slice-name-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Sometimes people call any kind of index <code class="docutils literal notranslate"><span class="pre">a[idx]</span></code> a
<em>slice</em>. However, this sort of nomenclature is confusing, since there are many
<a class="reference internal" href="index.html"><span class="doc std std-doc">valid possibilities</span></a> of <code class="docutils literal notranslate"><span class="pre">idx</span></code> that are not <code class="docutils literal notranslate"><span class="pre">slice</span></code> objects. It’s
better to use the word <em>index</em> to refer to an arbitrary object that can index
an array or sequence, and reserve the word <em>slice</em> for <code class="docutils literal notranslate"><span class="pre">slice</span></code> instances, which
are just one type of <em>index</em>.</p>
</aside>
<aside class="footnote brackets" id="non-integer-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Non-integer <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and <code class="docutils literal notranslate"><span class="pre">step</span></code> are
syntatically allowed by Python, but the built-in types (<code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>,
<code class="docutils literal notranslate"><span class="pre">str</span></code>) and NumPy arrays do not allow them. There are other libraries that
make use of this feature. For instance, the Pandas
<a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc" title="(in pandas v2.2.2)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">loc</span></code></a> attribute allows
slicing with strings corresponding to labels. The semantics of such
extensions to slicing may not necessarily correspond to the semantics
outlined in this guide.</p>
</aside>
<aside class="footnote brackets" id="dict-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>If you are looking for something that allows non-integer
indices or that indexes by value, you may want a <code class="docutils literal notranslate"><span class="pre">dict</span></code>. Despite using similar
syntax, <code class="docutils literal notranslate"><span class="pre">dict</span></code>s do not allow slicing.</p>
</aside>
<aside class="footnote brackets" id="numpy-definition-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p>This formulation actually isn’t particularly
helpful for formulating higher level slice formulas such as the ones used
by ndindex either. Plus it fails to account for <a class="reference internal" href="#clipping"><span class="std std-ref">some of the
details</span></a> discussed on this page.</p>
</aside>
<aside class="footnote brackets" id="slice-error-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">5</a><span class="fn-bracket">]</span></span>
<p>A slice might raise another exception, though, if it
is completely invalid, e.g., <code class="docutils literal notranslate"><span class="pre">a[1.0:]</span></code> and <code class="docutils literal notranslate"><span class="pre">a[::0]</span></code> raise <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> and
<code class="docutils literal notranslate"><span class="pre">ValueError</span></code>, respectively.</p>
</aside>
<aside class="footnote brackets" id="fencepost-jeff-burbak-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">6</a><span class="fn-bracket">]</span></span>
<p>Image credit <a class="reference external" href="https://unsplash.com/photos/lPO0VzF_4s8">Jeff Burak via
Unsplash</a>. The image is of
Chautauqua Park in Boulder, Colorado.</p>
</aside>
<aside class="footnote brackets" id="ndindex-calculations-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">7</a><span class="fn-bracket">]</span></span>
<p>ndindex can help in calculations here:
<a class="reference internal" href="../api/index-types.html#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">len(ndindex.Slice(...))</span></code></a> can be used to compute
the <em>maximum</em> length of a slice. If the shape or length of the input is known,
<a class="reference internal" href="../api/index-types.html#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">len(ndindex.Slice(...).reduce(shape))</span></code></a> will
compute the true length of the slice. Of course, if you already have a list or
a NumPy array, you can just slice it and check the shape. Slicing a NumPy
array always produces a <a class="reference internal" href="other-topics.html#views-vs-copies"><span class="std std-ref">view on the array</span></a>, so it is an
inexpensive operation. Slicing a <code class="docutils literal notranslate"><span class="pre">list</span></code> does make a copy, but it’s a shallow
copy so it isn’t particularly expensive either.</p>
</aside>
<aside class="footnote brackets" id="string-check-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">8</a><span class="fn-bracket">]</span></span>
<p>As an aside, the <code class="docutils literal notranslate"><span class="pre">in</span></code> check would be <em>wrong</em> if we
instead wrote <code class="docutils literal notranslate"><span class="pre">a[-1:]</span> <span class="pre">in</span> <span class="pre">'.!?'</span></code>. The two forms of comparison are not
equivalent.</p>
</aside>
<aside class="footnote brackets" id="negative-steps-ndindex-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">9</a><span class="fn-bracket">]</span></span>
<p>If you do need to use a negative start
with a step, <a class="reference internal" href="../api/index-types.html#ndindex.Slice" title="ndindex.slice.Slice"><span class="xref myst py py-class">ndindex</span></a> can be used to help compute
things to avoid making mistakes.</p>
</aside>
<aside class="footnote brackets" id="omitted-none-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">10</a><span class="fn-bracket">]</span></span>
<p><code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>, or <code class="docutils literal notranslate"><span class="pre">step</span></code> may also be <code class="docutils literal notranslate"><span class="pre">None</span></code>, which
is syntactically equivalent to them being omitted. That is to say, <code class="docutils literal notranslate"><span class="pre">a[::]</span></code> is
a syntactic shorthand for <code class="docutils literal notranslate"><span class="pre">a[None:None:None]</span></code>. It is rare to see <code class="docutils literal notranslate"><span class="pre">None</span></code> in a
slice. This is only relevant for code that consumes slices, such as a
<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> method on an object. The <code class="docutils literal notranslate"><span class="pre">slice()</span></code> object corresponding to
<code class="docutils literal notranslate"><span class="pre">a[::]</span></code> is <code class="docutils literal notranslate"><span class="pre">slice(None,</span> <span class="pre">None,</span> <span class="pre">None)</span></code>. <a class="reference internal" href="../api/index-types.html#ndindex.Slice" title="ndindex.slice.Slice"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ndindex.Slice()</span></code></span></a> also uses
<code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate omitted entries in the same way.</p>
</aside>
<aside class="footnote brackets" id="equivalent-slices-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">11</a><span class="fn-bracket">]</span></span>
<p>Strictly speaking <code class="docutils literal notranslate"><span class="pre">a[i:j:1]</span></code> creates <code class="docutils literal notranslate"><span class="pre">slice(i,</span> <span class="pre">j,</span> <span class="pre">1)</span></code> whereas <code class="docutils literal notranslate"><span class="pre">a[i:j:]</span></code> and <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> produce <code class="docutils literal notranslate"><span class="pre">slice(i,</span> <span class="pre">j,</span> <span class="pre">None)</span></code>. This
only matters if you are implementing <code class="docutils literal notranslate"><span class="pre">a.__getitem__</span></code>. The ndindex
<a class="reference internal" href="../api/index-types.html#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">Slice.reduce()</span></code></span></a> method can be used to
normalize slices do you don’t have to worry about these kinds of
distinctions.</p>
</aside>
<aside class="footnote brackets" id="tuple-copy-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">12</a><span class="fn-bracket">]</span></span>
<p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is a <code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">str</span></code>, there is little point to
copying <code class="docutils literal notranslate"><span class="pre">a</span></code> since these are immutable types, meaning that a shallow copy
of <code class="docutils literal notranslate"><span class="pre">a</span></code> and the original <code class="docutils literal notranslate"><span class="pre">a</span></code> are effectively indistinguishable.</p>
</aside>
<aside class="footnote brackets" id="source-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">13</a><span class="fn-bracket">]</span></span>
<p>To be sure, I make no claims that the source of any
function in ndindex cannot be simplified. In writing ndindex, I have primarily
focused on making the logic correct, and less on making it elegant. I welcome
any pull requests that simplifies the logic of a function. The extensive
<a class="reference internal" href="../index.html#testing"><span class="std std-ref">testing</span></a> should ensure that any rewritten function remains correct.</p>
</aside>
<aside class="footnote brackets" id="python-history-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id22">14</a><span class="fn-bracket">]</span></span>
<p>In fact, the original reason that Python uses
0-based indexing is that Guido preferred the half-open semantics, which only
work out well when combined with 0-based indexing
(<a class="reference external" href="https://web.archive.org/web/20190321101606/https://plus.google.com/115212051037621986145/posts/YTUxbXYZyfi">reference</a>).</p>
</aside>
<aside class="footnote brackets" id="fencepost-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">15</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://betterexplained.com/articles/learning-how-to-count-avoiding-the-fencepost-problem/">This
article</a>
has a nice writeup of why the fencepost problem exists. It’s related to
the difference between measurement and enumeration that I touched on
earlier.</p>
</aside>
</aside>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="multidimensional-indices/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Multidimensional Indices</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="integer-indices.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Integer Indices</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2020, Quansight Labs
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/Quansight-Labs/ndindex" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Slices</a><ul>
<li><a class="reference internal" href="#what-is-a-slice">What is a slice?</a></li>
<li><a class="reference internal" href="#rules">Rules</a></li>
<li><a class="reference internal" href="#points-of-confusion">Points of Confusion</a><ul>
<li><a class="reference internal" href="#subarray">Subarray</a></li>
<li><a class="reference internal" href="#based">0-based</a></li>
<li><a class="reference internal" href="#half-open">Half-open</a><ul>
<li><a class="reference internal" href="#wrong-ways-of-thinking-about-half-open-semantics">Wrong Ways of Thinking about Half-open Semantics</a><ul>
<li><a class="reference internal" href="#wrong-rule-1-a-slice-a-start-stop-slices-the-half-open-interval-text-start-text-stop">Wrong Rule 1: “A slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> slices the half-open interval <span class="math notranslate nohighlight">\([\text{start}, \text{stop})\)</span>.”</a></li>
<li><a class="reference internal" href="#wrong-rule-2-a-slice-works-like-range">Wrong Rule 2: “A slice works like <code class="docutils literal notranslate"><span class="pre">range()</span></code>.”</a></li>
<li><a class="reference internal" href="#wrong-rule-3-slices-index-the-spaces-between-the-elements-of-the-list">Wrong Rule 3: “Slices index the spaces between the elements of the list.”</a></li>
<li><a class="reference internal" href="#wrong-rule-4-the-stop-of-a-slice-a-start-stop-is-1-based">Wrong Rule 4: “The <code class="docutils literal notranslate"><span class="pre">stop</span></code> of a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> is 1-based.”</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#negative-indices">Negative Indices</a></li>
<li><a class="reference internal" href="#clipping">Clipping</a></li>
<li><a class="reference internal" href="#steps">Steps</a></li>
<li><a class="reference internal" href="#negative-steps">Negative Steps</a></li>
<li><a class="reference internal" href="#omitted-entries">Omitted Entries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#soapbox">Soapbox</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=4e2eecee"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script>window.MathJax = {"TeX": {"equationNumbers": {"autoNumber": "AMS"}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>