<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="Other Topics Relevant to Indexing" href="../other-topics.html" /><link rel="prev" title="Integer Array Indices" href="integer-arrays.html" />

    <link rel="shortcut icon" href="../../_static/favicon.ico"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>Boolean Array Indices - ndindex documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=16cf08d2" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=e072bb5a" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #CCCCCC;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #CCCCCC;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #000000bd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-dark-blue);
  --color-brand-content: var(--color-brand-dark-blue);
  --color-sidebar-background: #EEEEEE;
  --color-sidebar-item-background--hover: var(--color-brand-light-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-light-blue);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">ndindex  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../_static/ndindex_logo_white_bg.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../_static/ndindex_logo_dark_bg.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ndindex  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../api/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/ndindex.html">ndindex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/index-types.html">Index Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/shapetools.html">Shape Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/chunking.html">Chunking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/internal.html">Internal API</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../index.html">Guide to NumPy Indexing</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Guide to NumPy Indexing</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../intro.html">Introduction: What is an Index?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer-indices.html">Integer Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slices.html">Slices</a></li>
<li class="toctree-l2 current has-children"><a class="reference internal" href="index.html">Multidimensional Indices</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Multidimensional Indices</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="what-is-an-array.html">What is an Array?</a></li>
<li class="toctree-l3"><a class="reference internal" href="tuples.html">Tuple Indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="ellipses.html">Ellipses</a></li>
<li class="toctree-l3"><a class="reference internal" href="newaxis.html">newaxis</a></li>
<li class="toctree-l3"><a class="reference internal" href="integer-arrays.html">Integer Array Indices</a></li>
<li class="toctree-l3 current current-page"><a class="current reference internal" href="#">Boolean Array Indices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../other-topics.html">Other Topics Relevant to Indexing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../type-confusion.html">Type Confusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">ndindex Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../style-guide.html">Documentation Style Guide</a></li>
</ul>

</div></div><div class="sidebar-tree sidebar-extra">
  <ul>
    <li class="toctree-l1">
      <a class="sidebar-extra"
      href="https://github.com/Quansight-Labs/ndindex">GitHub<svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link-external" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z"></path></svg></a>
    </li>
  </ul>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/blob/main/docs/indexing-guide/multidimensional-indices/boolean-arrays.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/edit/main/docs/indexing-guide/multidimensional-indices/boolean-arrays.md" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="boolean-array-indices">
<h1>Boolean Array Indices<a class="headerlink" href="#boolean-array-indices" title="Link to this heading">¶</a></h1>
<p>The final index type is boolean arrays. Boolean array indices are also
sometimes called <em>masks</em>,<a class="footnote-reference brackets" href="#mask-footnote" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> because they “mask out” elements of
the array.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this section, as with <a class="reference internal" href="integer-arrays.html"><span class="std std-doc">the previous</span></a>, do not confuse the
<em>array being indexed</em> with the <em>array that is the index</em>. The former can be
anything and have any dtype. It is only the latter that is restricted to being
integer or boolean.</p>
</div>
<p>A boolean array index specifies which elements of an array should be selected
and which should not be selected.</p>
<p>The simplest and most common case is where a boolean array index has the same
shape as the array being indexed, and is the sole index (i.e., not part of a
larger <a class="reference internal" href="tuples.html"><span class="std std-doc">tuple index</span></a>).</p>
<p>Consider the array:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
<p>Suppose we want to select the elements <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, and <code class="docutils literal notranslate"><span class="pre">4</span></code>: to do so, we create a
boolean array of the same shape as <code class="docutils literal notranslate"><span class="pre">a</span></code> which is <code class="docutils literal notranslate"><span class="pre">True</span></code> in the positions where
those elements are and <code class="docutils literal notranslate"><span class="pre">False</span></code> everywhere else.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="go">array([1, 3, 4])</span>
</pre></div>
</div>
<p>From this we can see a few things:</p>
<ul class="simple">
<li><p>The result of indexing with the boolean mask is a 1-D array. If we think
about it, this is the only possibility. A boolean index could select any
number of elements. In this case, it selected 3 elements, but it could
select as few as 0 and as many as 9 elements from <code class="docutils literal notranslate"><span class="pre">a</span></code>. So there would be no
way to return a higher dimensional shape or for the shape of the result to
be somehow related to the shape of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
<li><p>The selected elements are “in order” (<a class="reference internal" href="#boolean-array-c-order"><span class="std std-ref">more on what this means
later</span></a>).</p></li>
</ul>
<p>However, these details are usually not important. This is because an array
indexed by a boolean array is typically used indirectly, such as on the
left-hand side of an assignment.</p>
<p>A typical use case of boolean indexing involves creating a boolean mask using
the array itself with operators that return boolean arrays, such as relational
operators (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>), logical operators (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code> (and),
<code class="docutils literal notranslate"><span class="pre">|</span></code> (or), <code class="docutils literal notranslate"><span class="pre">~</span></code> (not), <code class="docutils literal notranslate"><span class="pre">^</span></code> (xor)), and boolean functions (e.g.,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.isnan.html#numpy.isnan" title="(in NumPy v1.26)"><code class="xref py py-data docutils literal notranslate"><span class="pre">isnan()</span></code></a> or
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.isinf.html#numpy.isinf" title="(in NumPy v1.26)"><code class="xref py py-data docutils literal notranslate"><span class="pre">isinf()</span></code></a>).</p>
<p>Consider an array of the integers from -10 to 10:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([-10,  -9,  -8,  -7,  -6,  -5,  -4,  -3,  -2,  -1,   0,   1,   2,</span>
<span class="go">         3,   4,   5,   6,   7,   8,   9,  10])</span>
</pre></div>
</div>
<p>Say we want to select the elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> that are both positive and odd. The
boolean array <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> represents which elements are positive and the boolean
array <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">1</span></code> represents which elements are odd. So our mask would be</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Note the careful use of parentheses to match <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#operator-precedence">Python operator
precedence</a>.
Masks must use the logical operators <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, and <code class="docutils literal notranslate"><span class="pre">~</span></code> so that they can
operate on arrays. They cannot use the Python keywords <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, and <code class="docutils literal notranslate"><span class="pre">not</span></code>,
because they don’t work on arrays.</p>
<p>Our <code class="docutils literal notranslate"><span class="pre">mask</span></code> is just an array of booleans:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([False, False, False, False, False, False, False, False, False,</span>
<span class="go">       False, False,  True, False,  True, False,  True, False,  True,</span>
<span class="go">       False,  True, False])</span>
</pre></div>
</div>
<p>To get the actual matching elements, we need to index <code class="docutils literal notranslate"><span class="pre">a</span></code> with the mask:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([1, 3, 5, 7, 9])</span>
</pre></div>
</div>
<p>Often, one will see the <code class="docutils literal notranslate"><span class="pre">mask</span></code> written directly in the index, like</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span>
<span class="go">array([1, 3, 5, 7, 9])</span>
</pre></div>
</div>
<p>Suppose we want to set these elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">-100</span></code> (i.e., to “mask” them
out). This can be done easily with an indexing
assignment<a class="footnote-reference brackets" href="#indexing-assignment-footnote" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ -10,   -9,   -8,   -7,   -6,   -5,   -4,   -3,   -2,   -1,    0,</span>
<span class="go">       -100,    2, -100,    4, -100,    6, -100,    8, -100,   10])</span>
</pre></div>
</div>
<p>One common use case of this sort of thing is to mask out <code class="docutils literal notranslate"><span class="pre">nan</span></code> entries with a
finite number, like <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([        nan,         nan,         nan,         nan,         nan,</span>
<span class="go">       -0.58778666,  0.51082562,  1.02165125,  1.35812348,  1.60943791])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,</span>
<span class="go">       -0.58778666,  0.51082562,  1.02165125,  1.35812348,  1.60943791])</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">np.isnan(x)</span></code> returns a boolean array of the same shape as <code class="docutils literal notranslate"><span class="pre">x</span></code> that is
<code class="docutils literal notranslate"><span class="pre">True</span></code> if the corresponding element is <code class="docutils literal notranslate"><span class="pre">nan</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Note that for this kind of use case, the actual shape of <code class="docutils literal notranslate"><span class="pre">a[mask]</span></code> is
irrelevant. The important thing is that it is some subset of <code class="docutils literal notranslate"><span class="pre">a</span></code>, which is
then assigned to, mutating only those elements of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>It’s important to not be fooled by this way of constructing a mask. Even
though the <em>expression</em> <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">&amp;</span> <span class="pre">(a</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">1)</span></code> depends on <code class="docutils literal notranslate"><span class="pre">a</span></code>, the resulting
<em>array itself</em> does not—it is just an array of booleans. <strong>Boolean array
indexing, as with <a class="reference internal" href="../intro.html"><span class="std std-doc">all other types of indexing</span></a>, does not depend
on the values of the array, only in the positions of its elements.</strong></p>
<p>This distinction might feel overly pedantic, but it matters once you realize
that a mask created with one array can be used on another array, so long as it
has the same shape. It is common to have multiple arrays representing
different data about the same set of points. You may want to select a subset
of one array based on the values of the corresponding points in another array.</p>
<p>For example, suppose we want to plot the function <span class="math notranslate nohighlight">\(f(x) = 4x\sin(x) -
\frac{x^2}{4} - 2x\)</span> on <span class="math notranslate nohighlight">\([-10,10]\)</span>. We can set <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">np.linspace(-10,</span> <span class="pre">10)</span></code> and
compute the array expression:</p>
<!-- myst doesn't work with ```{plot}, and furthermore, if the two plot
directives are put in separate eval-rst blocks, the same plot is copied to
both. -->
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="c1"># 10000 evenly spaced points between -10 and 10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="c1"># our function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;matplotlib.collections.PathCollection object at ...&gt;</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="A plot of 4*x*np.sin(x) - x**2/4 - 2*x from -10 to 10. The curve crosses the x-axis several times at irregular intervals." class="plot-directive" src="../../_images/plot-1.svg" /></figure>
<p>If we want to show only those x values that are positive, we could easily do
this by modifying the <code class="docutils literal notranslate"><span class="pre">linspace</span></code> call that created <code class="docutils literal notranslate"><span class="pre">x</span></code>. But what if we
want to show only those <code class="docutils literal notranslate"><span class="pre">y</span></code> values that are positive? The only way to do
this is to select them using a mask:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;matplotlib.collections.PathCollection object at ...&gt;</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="A plot of only the parts of 4*x*np.sin(x) - x**2/4 - 2*x that are above the x-axis." class="plot-directive" src="../../_images/plot-2.svg" /></figure>
<p>Here we are using the mask <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> to select the corresponding values from
<em>both</em> the <code class="docutils literal notranslate"><span class="pre">x</span></code> and the <code class="docutils literal notranslate"><span class="pre">y</span></code> arrays. Since the same mask is used on both arrays,
the values corresponding to this mask in both arrays will be selected. With
<code class="docutils literal notranslate"><span class="pre">x[y</span> <span class="pre">&gt;</span> <span class="pre">0]</span></code>, even though the mask itself is not strictly created <em>from</em> <code class="docutils literal notranslate"><span class="pre">x</span></code>, it
still makes sense as a mask for the array <code class="docutils literal notranslate"><span class="pre">x</span></code>. In this case, the mask selects
a nontrivial subset of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Using a boolean array mask created from a different array is very common. For
example, in <a class="reference external" href="https://scikit-image.org/">scikit-image</a>, an image is represented
as an array of pixel values. Masks can be used to select a subset of the
image. A mask based on the pixel values (e.g., all red pixels) would depend on
the array, but a mask based on a geometric shape independent of the pixel
values, such as a
<a class="reference external" href="https://scikit-image.org/docs/stable/auto_examples/numpy_operations/plot_camera_numpy.html">circle</a>,
would not. In that case, the mask would just be a circular arrangement of
<code class="docutils literal notranslate"><span class="pre">True</span></code>s and <code class="docutils literal notranslate"><span class="pre">False</span></code>s. As another example, in machine learning, if <code class="docutils literal notranslate"><span class="pre">group</span></code> is
an array with group numbers and <code class="docutils literal notranslate"><span class="pre">X</span></code> is an array of features with repeated
measurements per group, one can select the features for a single group to do
cross-validation like <code class="docutils literal notranslate"><span class="pre">X[group</span> <span class="pre">==</span> <span class="pre">0]</span></code>.</p>
<section id="advanced-notes">
<h2>Advanced Notes<a class="headerlink" href="#advanced-notes" title="Link to this heading">¶</a></h2>
<p>As <a class="reference internal" href="integer-arrays.html#integer-arrays-advanced-notes"><span class="std std-ref">with integer array indices</span></a>, the above
section provides the basic gist of boolean array indexing, but there are some
advanced semantics described below, which can be skipped by new NumPy users.</p>
<section id="result-shape">
<span id="boolean-array-result-shape"></span><h3>Result Shape<a class="headerlink" href="#result-shape" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p><strong>A boolean array index will remove as many dimensions as the index has, and
replace them with a single flat dimension, which has size equal to the
number of <code class="docutils literal notranslate"><span class="pre">True</span></code> elements in the index.</strong></p>
</div></blockquote>
<p>The shape of the boolean array index must exactly match the dimensions being
replaced, or the index will result in an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<p>For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Matches the first two dimensions of a</span>
<span class="go">(2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="c1"># The number of True elements in idx</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># The (2, 3) in a.shape is replaced with count_nonzero(idx)</span>
<span class="go">(5, 4)</span>
</pre></div>
</div>
<p>This means that the final shape of an array indexed with a boolean mask
depends on the value of the mask, specifically, the number of <code class="docutils literal notranslate"><span class="pre">True</span></code> values in
it. It is easy to construct array expressions with boolean masks where the
size of the array cannot be determined until runtime. For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="c1"># Seeded so this example reproduces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1"># A shape (3, 4) array of 0s and 1s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Could be any size from 0 to 12</span>
<span class="go">(7,)</span>
</pre></div>
</div>
<p>However, even if the number of elements in an indexed array is not
determinable until runtime, the <em>number of dimensions</em> is determinable. This
is because a boolean mask acts as a flattening operation. All the dimensions
of the boolean array index are removed from the indexed array and replaced
with a single dimension. Only the <em>size</em> of this dimension cannot be
determined, unless the number of <code class="docutils literal notranslate"><span class="pre">True</span></code> elements in the index is known.</p>
<p>This detail means that sometimes code that uses boolean array indexing can be
difficult to reason about statically, because the array shapes are inherently
unknowable until runtime and may depend on data. For this reason, array
libraries that build computational graphs from array expressions without
evaluating them, such as
<a class="reference external" href="https://jax.readthedocs.io/en/latest/index.html">JAX</a> or <a class="reference external" href="https://docs.dask.org/en/stable/array.html">Dask
Array</a>, may have limited or no
support for boolean array indexing.</p>
</section>
<section id="result-order">
<span id="boolean-array-c-order"></span><h3>Result Order<a class="headerlink" href="#result-order" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p><strong>The order of the elements selected by a boolean array index <code class="docutils literal notranslate"><span class="pre">idx</span></code>
corresponds to the elements being iterated in C order.</strong></p>
</div></blockquote>
<p>C order iterates the array <code class="docutils literal notranslate"><span class="pre">a</span></code> so that the last axis varies the fastest,
like <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">2)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">1)</span></code>, etc.</p>
<p>For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="go">array([ 0,  2,  3,  5,  8,  9, 11])</span>
</pre></div>
</div>
<p>In this example, the elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> are ordered <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">...</span></code> in C order, which
is why in the final indexed array <code class="docutils literal notranslate"><span class="pre">a[idx]</span></code>, they are still in sorted order. C
order also corresponds to reading the elements of the array in the order that
NumPy prints them, from left to right, ignoring the brackets and commas.</p>
<p>C ordering is always used, even when the underlying memory is not C-ordered
(see <a class="reference internal" href="../other-topics.html#c-vs-fortran-ordering"><span class="std std-ref">C vs. Fortran Ordering</span></a> for more details on C array ordering).</p>
</section>
<section id="masking-a-subset-of-dimensions">
<h3>Masking a Subset of Dimensions<a class="headerlink" href="#masking-a-subset-of-dimensions" title="Link to this heading">¶</a></h3>
<p>It is possible to use a boolean mask to select only a subset of the dimensions
of <code class="docutils literal notranslate"><span class="pre">a</span></code>. For example, let’s take a shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3,</span> <span class="pre">4)</span></code> array <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>

<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
</pre></div>
</div>
<p>Say we want to select the elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> that are greater than 5, but only in
the first subarray along the first dimension (only the elements from 0 to 11).
We can create a mask on only that subarray:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4)</span>
</pre></div>
</div>
<p>Then, apply it to that same subarray:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="p">]</span>
<span class="go">array([ 6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="tuples.html"><span class="std std-doc">tuple</span></a> index <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">mask)</span></code> works just like any other tuple
index: it selects the subarray <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> along the first axis, then applies the
<code class="docutils literal notranslate"><span class="pre">mask</span></code> to the remaining dimensions. The shape of <code class="docutils literal notranslate"><span class="pre">mask</span></code>, <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code>, matches
those remaining dimensions (by construction), so the index is valid.</p>
<p>Masking a subset of dimension is not as common as masking the entire array
<code class="docutils literal notranslate"><span class="pre">a</span></code>, but it does happen. Remember that we can always think of an array as an
“array of subarrays”. For instance, suppose we have a video with 1920 x 1080
pixels and 500 frames. This might be represented as an array of shape <code class="docutils literal notranslate"><span class="pre">(500,</span> <span class="pre">1080,</span> <span class="pre">1920,</span> <span class="pre">3)</span></code>, where the final dimension, 3, represents the 3 RGB color
values of a pixel. We can think of this array as 500 <code class="docutils literal notranslate"><span class="pre">(1080,</span> <span class="pre">1920,</span> <span class="pre">3)</span></code>
“frames”. Or as 500 x 1080 x 1920 3-tuple “pixels”. Or we could slice along
the last dimension and think of it as 3 <code class="docutils literal notranslate"><span class="pre">(500,</span> <span class="pre">1080,</span> <span class="pre">1920)</span></code> video “channels”,
one for each primary color.</p>
<p>In each case, we imagine that our array is really an array (or a stack or
batch) of subarrays, where some of our dimensions are the “stacking”
dimensions and some of them are the array dimensions. This way of thinking is
also common when doing linear algebra on arrays. The last two dimensions
(typically) are considered matrices, and the leading dimensions are batch
dimensions. An array of shape <code class="docutils literal notranslate"><span class="pre">(10,</span> <span class="pre">5,</span> <span class="pre">4)</span></code> might be thought of as ten 5 x 4
matrices. NumPy linear algebra functions like <code class="docutils literal notranslate"><span class="pre">solve</span></code> and the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> matmul
operator will automatically operate on the last two dimensions of an array.</p>
<p>So, how does this relate to using a boolean array index to select only a
subset of the array dimensions? Well, we might want to use a boolean index to
select only along the inner “subarray” dimensions, and pretend like the outer
“batching” dimensions are our “array”.</p>
<p>For example, say we have an image represented in
<a class="reference external" href="https://scikit-image.org/">scikit-image</a> as a 3-D array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
<span class="gp">... </span>    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">... </span>    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">astronaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="s2">&quot;Original Image&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="An image of an astronaut, which is represented as a shape (512, 512, 3) array." class="plot-directive" src="../../_images/astronaut-1.svg" /></figure>
<p>Now, suppose we want to increase the saturation of this image. We can do this
by converting the image to <a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV space</a> and increasing the saturation
value (the second value in the last dimension, which should always be between
0 and 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsv_image</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2hsv</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Add 0.3 to the saturation, clipping the values to the range [0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsv_image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">hsv_image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Convert back to RGB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">saturated_image</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">hsv2rgb</span><span class="p">(</span><span class="n">hsv_image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imshow</span><span class="p">(</span><span class="n">saturated_image</span><span class="p">,</span> <span class="s2">&quot;Saturated Image (Naive)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="An image of an astronaut with increased saturation. The lighter parts of the image appear washed out." class="plot-directive" src="../../_images/astronaut-2.svg" /></figure>
<p>However, this ends up looking bad and washed out, because the whole image now
has a minimum saturation of 0.3. A better approach would be to select the
pixels that already have a saturation above some threshold, and increase the
saturation of only those pixels:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hsv_image</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2hsv</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Mask only those pixels whose saturation is &gt; 0.6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">high_sat_mask</span> <span class="o">=</span> <span class="n">hsv_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Increase the saturation of those pixels by 0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsv_image</span><span class="p">[</span><span class="n">high_sat_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">hsv_image</span><span class="p">[</span><span class="n">high_sat_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Convert back to RGB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enhanced_color_image</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">hsv2rgb</span><span class="p">(</span><span class="n">hsv_image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imshow</span><span class="p">(</span><span class="n">enhanced_color_image</span><span class="p">,</span> <span class="s2">&quot;Saturated Image&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="An image of an astronaut with increased saturation. The image does not appear washed out." class="plot-directive" src="../../_images/astronaut-3.svg" /></figure>
<p>Here, <code class="docutils literal notranslate"><span class="pre">hsv_image.shape</span></code> is <code class="docutils literal notranslate"><span class="pre">(512,</span> <span class="pre">512,</span> <span class="pre">3)</span></code>, so our mask <code class="docutils literal notranslate"><span class="pre">hsv_image[:,</span> <span class="pre">:,</span> <span class="pre">1]</span> <span class="pre">&gt;</span> <span class="pre">0.6</span></code> has shape <code class="docutils literal notranslate"><span class="pre">(512,</span> <span class="pre">512)</span></code>, i.e., the shape of the first two dimensions. In
other words, the mask has one value for each pixel, either <code class="docutils literal notranslate"><span class="pre">True</span></code> if the
saturation is <code class="docutils literal notranslate"><span class="pre">&gt;</span> <span class="pre">0.6</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> if it isn’t. To add 0.3 to only those pixels
above the threshold, we mask the original array with <code class="docutils literal notranslate"><span class="pre">hsv_image[high_sat_mask,</span> <span class="pre">1]</span></code>. The <code class="docutils literal notranslate"><span class="pre">high_sat_mask</span></code> part of the index selects only those pixel values
that have high saturation, and the <code class="docutils literal notranslate"><span class="pre">1</span></code> in the final dimension selects the
saturation channel for those pixels.</p>
</section>
<section id="nonzero-equivalence">
<span id="id3"></span><h3><code class="docutils literal notranslate"><span class="pre">nonzero()</span></code> Equivalence<a class="headerlink" href="#nonzero-equivalence" title="Link to this heading">¶</a></h3>
<p>Another way to think about boolean array indices is based on the
<code class="docutils literal notranslate"><span class="pre">np.nonzero()</span></code> function. <code class="docutils literal notranslate"><span class="pre">np.nonzero(x)</span></code> returns a tuple of arrays of integer
indices where <code class="docutils literal notranslate"><span class="pre">x</span></code> is nonzero, or in the case where <code class="docutils literal notranslate"><span class="pre">x</span></code> is boolean, where <code class="docutils literal notranslate"><span class="pre">x</span></code>
is True. For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="go">(array([0, 0, 0, 1, 2, 2, 2]), array([0, 2, 3, 1, 0, 1, 3]))</span>
</pre></div>
</div>
<p>The first array in the tuple corresponds to indices for the first dimension;
the second array to the second dimension, and so on. If this seems familiar,
it’s because this is exactly how we saw that <a class="reference internal" href="integer-arrays.html#multidimensional-integer-indices"><span class="std std-ref">multidimensional integer array
indices</span></a> worked. Indeed, there is a basic
equivalence between the two:</p>
<blockquote>
<div><p><strong>A boolean array index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is the same as if you replaced <code class="docutils literal notranslate"><span class="pre">idx</span></code> with the
result of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero" title="(in NumPy v1.26)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.nonzero(idx)</span></code></a> (unpacking
the tuple), using the rules for <a class="reference internal" href="integer-arrays.html"><span class="std std-doc">integer array indices</span></a>
outlined previously.</strong></p>
</div></blockquote>
<p>Note, however, that this rule <em>does not</em> apply to <a class="reference internal" href="#d-boolean-index"><span class="std std-ref">0-dimensional boolean
indices</span></a>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="go">array([ 0,  2,  3,  5,  8,  9, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="go">(array([0, 0, 0, 1, 2, 2, 2]), array([0, 2, 3, 1, 0, 1, 3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">]</span> <span class="c1"># this is the same as a[idx]</span>
<span class="go">array([ 0,  2,  3,  5,  8,  9, 11])</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">np.nonzero(idx)</span></code> returns two integer array indices, one for each
dimension of <code class="docutils literal notranslate"><span class="pre">idx</span></code>. These indices each have <code class="docutils literal notranslate"><span class="pre">7</span></code> elements, one for each
<code class="docutils literal notranslate"><span class="pre">True</span></code> element of <code class="docutils literal notranslate"><span class="pre">idx</span></code>, and they select (in C order), the corresponding
elements. Another way to think of this is that <code class="docutils literal notranslate"><span class="pre">idx[np.nonzero(idx)]</span></code> will
always return an array of <code class="docutils literal notranslate"><span class="pre">np.count_nonzero(idx)</span></code> <code class="docutils literal notranslate"><span class="pre">True</span></code>s, because
<code class="docutils literal notranslate"><span class="pre">np.nonzero(idx)</span></code> is exactly the integer array indices that select the
<code class="docutils literal notranslate"><span class="pre">True</span></code> elements of <code class="docutils literal notranslate"><span class="pre">idx</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
<span class="go">array([ True,  True,  True,  True,  True,  True,  True])</span>
</pre></div>
</div>
<p>What this all means is that all the rules that are outlined previously about
<a class="reference internal" href="integer-arrays.html"><span class="std std-doc">integer array indices</span></a>, e.g., <a class="reference internal" href="integer-arrays.html#integer-array-broadcasting"><span class="std std-ref">how they
broadcast</span></a> or <a class="reference internal" href="integer-arrays.html#integer-arrays-combined-with-basic-indices"><span class="std std-ref">combine together with
slices</span></a>, all also apply to boolean
array indices after this transformation. This also specifies how boolean array
indices and integer array indices combine
together.<a class="footnote-reference brackets" href="#combining-integer-and-boolean-indices-footnote" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>Effectively, a boolean array index can be combined with other boolean or
integer array indices by first converting the boolean index into integer
indices (one for each dimension of the boolean index) that select each <code class="docutils literal notranslate"><span class="pre">True</span></code>
element of the index, and then broadcasting them all to a common shape.</p>
<p>The ndindex method
<a class="reference internal" href="../../api/index-types.html#ndindex.Tuple.broadcast_arrays" title="ndindex.Tuple.broadcast_arrays"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">Tuple.broadcast_arrays()</span></code></span></a> (as well as
<a class="reference internal" href="../../api/index-types.html#ndindex.Tuple.expand" title="ndindex.Tuple.expand"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">expand()</span></code></span></a>) will convert boolean array indices into
integer array indices via <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero" title="(in NumPy v1.26)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.nonzero()</span></code></a> and broadcast
array indices together into a canonical form.</p>
</section>
<section id="boolean-scalar-indices">
<span id="d-boolean-index"></span><h3>Boolean Scalar Indices<a class="headerlink" href="#boolean-scalar-indices" title="Link to this heading">¶</a></h3>
<p>A 0-dimensional boolean index (i.e., just the scalar <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>) is a
little special. The <a class="reference internal" href="#nonzero-equivalence"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">np.nonzero</span></code> rule</span></a> stated above does
not actually apply. This is because <code class="docutils literal notranslate"><span class="pre">np.nonzero</span></code> exhibits odd behavior with
0-D arrays. <code class="docutils literal notranslate"><span class="pre">np.nonzero(a)</span></code> usually returns a tuple with as many arrays as
dimensions of <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]))</span>
<span class="go">(array([0]),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]]))</span>
<span class="go">(array([0]), array([0]))</span>
</pre></div>
</div>
<p>But for a 0-D array, <code class="docutils literal notranslate"><span class="pre">np.nonzero(a)</span></code> doesn’t return an empty tuple, but
rather the same thing as
<code class="docutils literal notranslate"><span class="pre">np.nonzero(np.array([a]))</span></code>:<a class="footnote-reference brackets" href="#nonzero-deprecated-footnote" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
<!-- TODO: Update this text when NumPy 2.0 is released. -->
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span> 
<span class="go">(array([], dtype=int64),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span> 
<span class="go">(array([0]),)</span>
</pre></div>
</div>
<p>However, the key point—that a <a class="reference internal" href="#boolean-array-result-shape"><span class="std std-ref">boolean array index removes <code class="docutils literal notranslate"><span class="pre">idx.ndim</span></code>
dimensions from <code class="docutils literal notranslate"><span class="pre">a</span></code> and replaces them with a single dimension with size equal
to the number of <code class="docutils literal notranslate"><span class="pre">True</span></code> elements</span></a>—remains true.
Here, <code class="docutils literal notranslate"><span class="pre">idx.ndim</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>, because <code class="docutils literal notranslate"><span class="pre">array(True)</span></code> and <code class="docutils literal notranslate"><span class="pre">array(False)</span></code> have shape
<code class="docutils literal notranslate"><span class="pre">()</span></code>. Thus, these indices “remove” 0 dimensions and add a single dimension of
size 1 for <code class="docutils literal notranslate"><span class="pre">True</span></code> or 0 for <code class="docutils literal notranslate"><span class="pre">False</span></code>. Hence, if <code class="docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="docutils literal notranslate"><span class="pre">(s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>,
then <code class="docutils literal notranslate"><span class="pre">a[True]</span></code> has shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>, and <code class="docutils literal notranslate"><span class="pre">a[False]</span></code> has shape <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># as above</span>
<span class="go">(2, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 2, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(0, 2, 5)</span>
</pre></div>
</div>
<p>This is different from what <code class="docutils literal notranslate"><span class="pre">a[np.nonzero(True)]</span></code> would
return:<a class="footnote-reference brackets" href="#nonzero-scalar-footnote" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p>
<!-- TODO: Update this when NumPy 2.0 is released. -->
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="kc">True</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span> 
<span class="go">(1, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="kc">False</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span> 
<span class="go">(0, 5)</span>
</pre></div>
</div>
<p>The scalar boolean behavior may seem like an odd corner case. You might wonder
why NumPy supports using a <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> as an index, especially since it
has slightly different semantics than higher dimensional boolean arrays.</p>
<p>The reason scalar booleans are supported is that they are a natural
generalization of n-D boolean array indices. While the <code class="docutils literal notranslate"><span class="pre">np.nonzero()</span></code> rule
does not hold for them, the more general rule about replacing
<code class="docutils literal notranslate"><span class="pre">idx.ndim</span></code> dimensions a single dimension does.</p>
<p>Consider the most common case of using a boolean index: masking some subset of
the entire array. This typically looks something like
<code class="docutils literal notranslate"><span class="pre">a[some_boolean_expression_on_a]</span> <span class="pre">=</span> <span class="pre">mask_value</span></code>. For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-1,  1],</span>
<span class="go">       [ 1, -1]])</span>
</pre></div>
</div>
<p>Here, we set all the <code class="docutils literal notranslate"><span class="pre">0</span></code> elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">-1</span></code>. We do this by creating the
boolean mask <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">0</span></code>, which is a boolean expression created from <code class="docutils literal notranslate"><span class="pre">a</span></code>. Our
mask might be a lot more complicated in general, but it still is usually the
case that our mask is constructed from <code class="docutils literal notranslate"><span class="pre">a</span></code>, and thus has the exact same shape
as <code class="docutils literal notranslate"><span class="pre">a</span></code>. Therefore, <code class="docutils literal notranslate"><span class="pre">a[mask]</span></code> is a 1 dimensional array with
<code class="docutils literal notranslate"><span class="pre">np.count_nonzero(mask)</span></code> elements. In this example, this doesn’t actually
matter because we are using the mask as the left-hand side of an assignment.
As long as the right-hand side is broadcast compatible with <code class="docutils literal notranslate"><span class="pre">a[mask]</span></code>, it will
be fine. In this case, it works because <code class="docutils literal notranslate"><span class="pre">-1</span></code> is a scalar, which is always
broadcast compatible with everything, but more generally we could index the
right-hand side with the exact same mask index to ensure it is exactly the
same shape as the left-hand side.</p>
<p>In particular, note that <code class="docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">==</span> <span class="pre">0]</span> <span class="pre">=</span> <span class="pre">-1</span></code> works no matter what the shape or
dimensionality of <code class="docutils literal notranslate"><span class="pre">a</span></code> is, and no matter how many <code class="docutils literal notranslate"><span class="pre">0</span></code> entries it has. Above
it had 2 dimensions and two <code class="docutils literal notranslate"><span class="pre">0</span></code>s, but it would also work if it were
1-dimensional:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([-1,  1, -1,  1])</span>
</pre></div>
</div>
<p>Or if it had no actual <code class="docutils literal notranslate"><span class="pre">0</span></code>s:<a class="footnote-reference brackets" href="#d-mask-footnote" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([1, 1, 2])</span>
</pre></div>
</div>
<p>But even if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a 0-D array, i.e., a single scalar value, we would expect
this sort of thing to still work, since, as we said, <code class="docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">==</span> <span class="pre">0]</span> <span class="pre">=</span> <span class="pre">-1</span></code> should
work for <em>any</em> array. And indeed, it does:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array(-1)</span>
</pre></div>
</div>
<p>Consider what happened here. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">0</span></code> is the a 0-D array <code class="docutils literal notranslate"><span class="pre">array(True)</span></code>.
<code class="docutils literal notranslate"><span class="pre">a[True]</span></code> is a 1-D array containing the single True value corresponding to
the mask, i.e., <code class="docutils literal notranslate"><span class="pre">array([0])</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([0])</span>
</pre></div>
</div>
<p>This then gets assigned the value <code class="docutils literal notranslate"><span class="pre">-1</span></code>, which as a scalar, gets broadcasted
to the entire array, thereby replacing this single <code class="docutils literal notranslate"><span class="pre">0</span></code> value with <code class="docutils literal notranslate"><span class="pre">-1</span></code>. The
<code class="docutils literal notranslate"><span class="pre">0</span></code> in the masked array corresponds to the same <code class="docutils literal notranslate"><span class="pre">0</span></code> in memory as <code class="docutils literal notranslate"><span class="pre">a</span></code>, so the
assignment mutates it to <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>If our 0-D <code class="docutils literal notranslate"><span class="pre">a</span></code> was not <code class="docutils literal notranslate"><span class="pre">0</span></code>, then <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">0</span></code> would be <code class="docutils literal notranslate"><span class="pre">array(False)</span></code>. Then <code class="docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">==</span> <span class="pre">0]</span></code> would be a 1-D array containing no values, i.e., a shape <code class="docutils literal notranslate"><span class="pre">(0,)</span></code> array:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(0,)</span>
</pre></div>
</div>
<p>In this case, <code class="docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">==</span> <span class="pre">0]</span> <span class="pre">=</span> <span class="pre">-1</span></code> would assign <code class="docutils literal notranslate"><span class="pre">-1</span></code> to all the values in <code class="docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">==</span> <span class="pre">0]</span></code>, which would be no values, so <code class="docutils literal notranslate"><span class="pre">a</span></code> would remain unchanged:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array(1)</span>
</pre></div>
</div>
<p>The point is that the underlying logic works out so that <code class="docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">==</span> <span class="pre">0]</span> <span class="pre">=</span> <span class="pre">-1</span></code>
always does what you’d expect: every <code class="docutils literal notranslate"><span class="pre">0</span></code> value in <code class="docutils literal notranslate"><span class="pre">a</span></code> is replaced with <code class="docutils literal notranslate"><span class="pre">-1</span></code>
<em>regardless</em> of the shape of <code class="docutils literal notranslate"><span class="pre">a</span></code>, including if that shape is <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
<p class="rubric">Footnotes</p>
<!-- Footnotes are written inline above but markdown will put them here at the
end of the document. -->
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="mask-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Not to be confused with <a class="reference external" href="https://numpy.org/doc/stable/reference/maskedarray.html" title="(in NumPy v1.26)"><span class="xref std std-doc">NumPy masked arrays</span></a>.</p>
</aside>
<aside class="footnote brackets" id="indexing-assignment-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>All the indexing rules discussed in this
guide apply when the indexed array is on the left-hand side of an <code class="docutils literal notranslate"><span class="pre">=</span></code>
assignment. The elements of the array that are selected by the index are
assigned in-place to the array or number on the right-hand side.</p>
</aside>
<aside class="footnote brackets" id="combining-integer-and-boolean-indices-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>Combining an integer array
and boolean array index together is not common, as the shape of the
integer array index would have to be broadcast compatible with the number
of <code class="docutils literal notranslate"><span class="pre">True</span></code> elements in the boolean array.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])]</span>
<span class="go">array([0, 7, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">shape mismatch: indexing arrays could not be broadcast together with shapes (3,) (4,)</span>
</pre></div>
</div>
<p>It’s not impossible for this to come up in practice, but like many of the
advanced indexing semantics discussed here, it’s mostly supported for the
sake of completeness.</p>
</aside>
<aside class="footnote brackets" id="nonzero-deprecated-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p>In NumPy 2.0, calling <code class="docutils literal notranslate"><span class="pre">nonzero()</span></code> on a 0-D
array is deprecated, and in NumPy 2.1 it will result in an error,
precisely due to this odd behavior.</p>
</aside>
<aside class="footnote brackets" id="nonzero-scalar-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">5</a><span class="fn-bracket">]</span></span>
<p>But note that this also wouldn’t work if
<code class="docutils literal notranslate"><span class="pre">np.nonzero(True)</span></code> returned the empty tuple <code class="docutils literal notranslate"><span class="pre">()</span></code>. In fact, there’s no
generic index that <code class="docutils literal notranslate"><span class="pre">np.nonzero()</span></code> could return that would be equivalent
to the actual indexing behavior of a boolean scalar, especially for
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</aside>
<aside class="footnote brackets" id="d-mask-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">6</a><span class="fn-bracket">]</span></span>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">0</span></code> is <code class="docutils literal notranslate"><span class="pre">array([False,</span> <span class="pre">False,</span> <span class="pre">False])</span></code>, and <code class="docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">==</span> <span class="pre">0]</span></code> is an empty array of shape <code class="docutils literal notranslate"><span class="pre">(0,)</span></code>. The reason
this works is that the right-hand side of the assignment is a scalar,
i.e., NumPy casts it to an array of shape <code class="docutils literal notranslate"><span class="pre">()</span></code>. The shape <code class="docutils literal notranslate"><span class="pre">()</span></code> broadcasts
with the shape <code class="docutils literal notranslate"><span class="pre">(0,)</span></code> to the shape <code class="docutils literal notranslate"><span class="pre">(0,)</span></code>, and so this is what gets
assigned, i.e., “nothing” (of shape <code class="docutils literal notranslate"><span class="pre">(0,)</span></code>) gets assigned to “nothing” (of
matching shape <code class="docutils literal notranslate"><span class="pre">(0,)</span></code>). This is one reason why <a class="reference internal" href="../other-topics.html#broadcasting"><span class="std std-ref">broadcasting
rules</span></a> apply even to dimensions of size 0.</p>
</aside>
</aside>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../other-topics.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Other Topics Relevant to Indexing</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="integer-arrays.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Integer Array Indices</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2020, Quansight Labs
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/Quansight-Labs/ndindex" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Boolean Array Indices</a><ul>
<li><a class="reference internal" href="#advanced-notes">Advanced Notes</a><ul>
<li><a class="reference internal" href="#result-shape">Result Shape</a></li>
<li><a class="reference internal" href="#result-order">Result Order</a></li>
<li><a class="reference internal" href="#masking-a-subset-of-dimensions">Masking a Subset of Dimensions</a></li>
<li><a class="reference internal" href="#nonzero-equivalence"><code class="docutils literal notranslate"><span class="pre">nonzero()</span></code> Equivalence</a></li>
<li><a class="reference internal" href="#boolean-scalar-indices">Boolean Scalar Indices</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=4e2eecee"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script>window.MathJax = {"TeX": {"equationNumbers": {"autoNumber": "AMS"}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>