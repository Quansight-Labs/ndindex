<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Type Confusion" href="../type-confusion.html" /><link rel="prev" title="Boolean Array Indices" href="multidimensional-indices/boolean-arrays.html" />

    <link rel="shortcut icon" href="../_static/favicon.ico"/><!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>Other Topics Relevant to Indexing - ndindex documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=6ad9bad0" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=254c7fb8" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #CCCCCC;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #CCCCCC;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #000000bd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-dark-blue);
  --color-brand-content: var(--color-brand-dark-blue);
  --color-sidebar-background: #EEEEEE;
  --color-sidebar-item-background--hover: var(--color-brand-light-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-light-blue);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ndindex  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../_static/ndindex_logo_white_bg.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../_static/ndindex_logo_dark_bg.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ndindex  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/ndindex.html">ndindex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/index-types.html">Index Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/shapetools.html">Shape Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/chunking.html">Chunking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/internal.html">Internal API</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Guide to NumPy Indexing</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Guide to NumPy Indexing</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction: What is an Index?</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer-indices.html">Integer Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="slices.html">Slices</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="multidimensional-indices/index.html">Multidimensional Indices</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Multidimensional Indices</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/what-is-an-array.html">What is an Array?</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/tuples.html">Tuple Indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/ellipses.html">Ellipses</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/newaxis.html">newaxis</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/integer-arrays.html">Integer Array Indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="multidimensional-indices/boolean-arrays.html">Boolean Array Indices</a></li>
</ul>
</li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Other Topics Relevant to Indexing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../type-confusion.html">Type Confusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">ndindex Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide.html">Documentation Style Guide</a></li>
</ul>

</div></div><div class="sidebar-tree sidebar-extra">
  <ul>
    <li class="toctree-l1">
      <a class="sidebar-extra"
      href="https://github.com/Quansight-Labs/ndindex">GitHub<svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link-external" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z"></path></svg></a>
    </li>
  </ul>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/blob/main/docs/indexing-guide/other-topics.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/edit/main/docs/indexing-guide/other-topics.md" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="other-topics-relevant-to-indexing">
<h1>Other Topics Relevant to Indexing<a class="headerlink" href="#other-topics-relevant-to-indexing" title="Link to this heading">¶</a></h1>
<p>There is a great deal of functionality in NumPy, and most of it is
out-of-scope for this guide. However, a few additional features are useful to
understand in order to fully utilize indexing to its fullest potential, or as
important caveats to be aware of when doing indexing operations.</p>
<section id="broadcasting">
<span id="id1"></span><h2>Broadcasting<a class="headerlink" href="#broadcasting" title="Link to this heading">¶</a></h2>
<p>Broadcasting is a powerful abstraction that applies to all operations in
NumPy. It allows arrays with mismatched shapes to be combined together as if
one or more of their dimensions were simply repeated the appropriate number of
times.</p>
<p>Normally, when we perform an operation on two arrays with the same shape, it
does what we’d expect, i.e., the operation is applied to each corresponding
element of each array. For example, if <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are both <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code> arrays,
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> results in a <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code> array with the sum of the corresponding
elements.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">103</span><span class="p">,</span> <span class="mi">104</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">array([[102, 104],</span>
<span class="go">       [106, 108]])</span>
</pre></div>
</div>
<p>However, you may have noticed that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> don’t always have to be two
arrays with the same shape. For example, you can add a single scalar element
to an array, and it will add it to each element.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">array([[2, 3],</span>
<span class="go">       [4, 5]])</span>
</pre></div>
</div>
<p>In the above example, we can think of the scalar <code class="docutils literal notranslate"><span class="pre">1</span></code> as a shape <code class="docutils literal notranslate"><span class="pre">()</span></code> array,
whereas <code class="docutils literal notranslate"><span class="pre">x</span></code> is a shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code> array. Thus, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> do not have the same
shape, but <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> is allowed via repeating <code class="docutils literal notranslate"><span class="pre">1</span></code> across every element of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
This means NumPy is taking <code class="docutils literal notranslate"><span class="pre">1</span></code> and treating it as if it were the shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code> array <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">1],</span> <span class="pre">[1,</span> <span class="pre">1]]</span></code>.</p>
<p>Broadcasting is a generalization of this behavior. Specifically, instead of
repeating just a single number into an array, we can repeat just some
dimensions of an array into a bigger array. For example, here we multiply <code class="docutils literal notranslate"><span class="pre">x</span></code>,
a shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code> array, with <code class="docutils literal notranslate"><span class="pre">y</span></code>, a shape <code class="docutils literal notranslate"><span class="pre">(2,)</span></code> array. <code class="docutils literal notranslate"><span class="pre">y</span></code> is virtually
repeated into a shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code> array with each element of the last dimension
repeated 3 times.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">*</span><span class="n">y</span>
<span class="go">array([[ 0,  4],</span>
<span class="go">       [ 0,  8],</span>
<span class="go">       [ 0, 12]])</span>
</pre></div>
</div>
<p>We can see how broadcasting works using <code class="docutils literal notranslate"><span class="pre">np.broadcast_to</span></code></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [0, 2],</span>
<span class="go">       [0, 2]])</span>
</pre></div>
</div>
<p>This is what the array <code class="docutils literal notranslate"><span class="pre">y</span></code> looks like before it is combined with <code class="docutils literal notranslate"><span class="pre">x</span></code>. Although
note that broadcasting is implemented efficiently, so that the “repeated”
elements actually refer to the same objects in memory. See <a class="reference internal" href="#views-vs-copies"><span class="std std-ref">Views vs. Copies</span></a>
and <a class="reference internal" href="#strides"><span class="std std-ref">Strides</span></a> below.</p>
<p>Broadcasting always happens automatically in NumPy whenever two arrays with
different shapes are combined using any function or operator, assuming those
shapes are broadcast compatible. The rule for broadcast compatibility is that
the shorter of the shapes are prepended with length 1 dimensions so that they
have the same number of dimensions. Then any dimensions that are size <code class="docutils literal notranslate"><span class="pre">1</span></code> in a
shape are replaced with the corresponding size in the other shape. The other
non-<code class="docutils literal notranslate"><span class="pre">1</span></code> sizes must be equal or broadcasting is not allowed.</p>
<p>In the above example, we broadcast <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code> with <code class="docutils literal notranslate"><span class="pre">(2,)</span></code> by first extending
<code class="docutils literal notranslate"><span class="pre">(2,)</span></code> to <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2)</span></code> then broadcasting the size <code class="docutils literal notranslate"><span class="pre">1</span></code> dimension to the
corresponding size in the other shape, <code class="docutils literal notranslate"><span class="pre">3</span></code>, giving a broadcasted shape of <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code>. In more advanced examples, both shapes may have broadcasted dimensions.
For instance, <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">1)</span></code> can broadcast with <code class="docutils literal notranslate"><span class="pre">(2,)</span></code> to create <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code>. The first
shape repeats the first axis 2 times along the second axis, while the second
shape inserts a new axis at the beginning that repeats 3 times.</p>
<p>We can think of <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2)</span></code> as a “stack” of 3 shape <code class="docutils literal notranslate"><span class="pre">(2,)</span></code> arrays. Just as the
scalar <code class="docutils literal notranslate"><span class="pre">1</span></code> got repeated to match the full shape of <code class="docutils literal notranslate"><span class="pre">a</span></code> above, the shape <code class="docutils literal notranslate"><span class="pre">(2,)</span></code>
array <code class="docutils literal notranslate"><span class="pre">y</span></code> gets repeated into a <code class="docutils literal notranslate"><span class="pre">(3,)</span></code> “stack” so it matches the shape of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Additionally, size <code class="docutils literal notranslate"><span class="pre">1</span></code> dimensions are a signal to NumPy that that dimension is
allowed to be repeated, or broadcasted, when used with another array where
the other dimensions match.</p>
<p>It can be useful to think of broadcasting as repeating “stacks” of smaller
arrays in this way. The automatic prepending rule lets you automatically treat
array “stacking” along the last dimension, which is the most common, but the
size <code class="docutils literal notranslate"><span class="pre">1</span></code> dimension rule allows these stacks to be along any dimensions of
the array, not just the last ones.</p>
<p>When it comes to indexing, one of the most useful types of index for use with
broadcasting is <a class="reference internal" href="multidimensional-indices/newaxis.html"><span class="std std-doc">newaxis</span></a>, which lets
you easily insert size <code class="docutils literal notranslate"><span class="pre">1</span></code> dimensions into an array to make the broadcastable
in a specific way. See <a class="reference internal" href="multidimensional-indices/newaxis.html#where-newaxis-is-used"><span class="std std-ref">Where newaxis is Used</span></a>.</p>
<p>See the <a class="reference external" href="https://numpy.org/doc/stable/user/basics.broadcasting.html">NumPy
documentation</a> for
more examples of broadcasting.</p>
</section>
<section id="views-vs-copies">
<span id="id2"></span><h2>Views vs. Copies<a class="headerlink" href="#views-vs-copies" title="Link to this heading">¶</a></h2>
<p>There is an important distinction between basic indices (i.e.,
<a class="reference internal" href="integer-indices.html"><span class="std std-doc">integers</span></a>, <a class="reference internal" href="slices.html"><span class="std std-doc">slices</span></a>,
<a class="reference internal" href="multidimensional-indices/ellipses.html"><span class="std std-doc">ellipses</span></a>,
<a class="reference internal" href="multidimensional-indices/newaxis.html"><span class="std std-doc">newaxis</span></a>) and <a class="reference internal" href="multidimensional-indices/index.html#advanced-indices"><span class="std std-ref">advanced
indices</span></a> (i.e., <a class="reference internal" href="multidimensional-indices/integer-arrays.html"><span class="std std-doc">integer array
indices</span></a> and <a class="reference internal" href="multidimensional-indices/boolean-arrays.html"><span class="std std-doc">boolean array
indices</span></a>) in NumPy that must be
noted in some situations. Specifically, basic indices always create a <strong>view</strong>
into an array<a class="footnote-reference brackets" href="#view-scalar-footnote" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, while advanced indices always create a
<strong>copy</strong> of the underlying array. <a class="reference internal" href="multidimensional-indices/tuples.html"><span class="std std-doc">Tuple</span></a>
indices (i.e., multidimensional indices) will create a view if they do not
contain an advanced index and a copy if they do.</p>
<p>A <strong>view</strong> is a special type of array whose data points to another array. This
means that if you mutate the data in one array, the other array will also have
that data mutated as well. For example,</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># b is a view of a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7]],</span>

<span class="go">       [[ 8,  9, 10, 11],</span>
<span class="go">        [12, 13, 14, 15]],</span>

<span class="go">       [[16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Mutating b also mutates a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[ 0,  0,  0,  0],</span>
<span class="go">        [ 4,  5,  6,  7]],</span>

<span class="go">       [[ 0,  0,  0,  0],</span>
<span class="go">        [12, 13, 14, 15]],</span>

<span class="go">       [[ 0,  0,  0,  0],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
</pre></div>
</div>
<p>Mutating <code class="docutils literal notranslate"><span class="pre">b</span></code> also changed <code class="docutils literal notranslate"><span class="pre">a</span></code>, because both arrays point to the same memory.</p>
<p>Note that this behavior is exactly the opposite of the way Python lists work.
With Python lists, <code class="docutils literal notranslate"><span class="pre">a[:]</span></code> is a shorthand to copy <code class="docutils literal notranslate"><span class="pre">a</span></code>. But with NumPy, <code class="docutils literal notranslate"><span class="pre">a[:]</span></code>
creates a view into <code class="docutils literal notranslate"><span class="pre">a</span></code> (to copy an array with NumPy, use <code class="docutils literal notranslate"><span class="pre">a.copy()</span></code>). Python
lists do not have a notion of views.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1"># list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span> <span class="c1"># a copy of a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Modifies b but not a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[0, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1"># NumPy array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span> <span class="c1"># A view of a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Modifies both b and a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># A copy of a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Only modifies c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([-1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 2, 3])</span>
</pre></div>
</div>
<p>Views don’t just come from indexing. For instance, when you reshape an array,
that also creates a view.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[[ 0,  0,  0,  0],</span>
<span class="go">        [ 0,  0,  0,  0]],</span>

<span class="go">       [[ 8,  9, 10, 11],</span>
<span class="go">        [12, 13, 14, 15]],</span>

<span class="go">       [[16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 0,  0,  0,  0,  0,  0,  0,  0,  8,  9, 10, 11, 12, 13, 14, 15, 16,</span>
<span class="go">       17, 18, 19, 20, 21, 22, 23])</span>
</pre></div>
</div>
<p>Many other operations also create views, for example
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.transpose.html"><code class="docutils literal notranslate"><span class="pre">np.transpose</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.T.html"><code class="docutils literal notranslate"><span class="pre">a.T</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ravel.html"><code class="docutils literal notranslate"><span class="pre">np.ravel</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.broadcast.html"><code class="docutils literal notranslate"><span class="pre">broadcast</span></code></a>,
and
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.view.html"><code class="docutils literal notranslate"><span class="pre">a.view</span></code></a>.<a class="footnote-reference brackets" href="#view-functions-footnote" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p>To check if an array is a view, check <code class="docutils literal notranslate"><span class="pre">a.base</span></code>. It will be <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is not
a view and will point to the base array otherwise. A view of a view will have
the same base as the original array.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="c1"># a is not a view</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">a</span> <span class="c1"># b is a view of a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">a</span> <span class="c1"># c is a further view of a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In contrast, an advanced index will always create a copy (even if it would be
possible to represent it as a view). This includes any <a class="reference internal" href="multidimensional-indices/tuples.html"><span class="std std-doc">tuple
index</span></a> (i.e., multidimensional index) that
contains at least one array index.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">a</span> <span class="c1"># b is a view of a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="c1"># c is not (it is a copy)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Whether an array is a view or a copy matters for two reasons:</p>
<ol class="arabic">
<li><p>If you ever mutate the array, if it is a view, it will also mutate the data
in the base array, as shown above. Be aware that views affect mutations in
both directions: if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a view, mutating it will also mutate whichever
array it is a view on, but conversely, even if <code class="docutils literal notranslate"><span class="pre">a</span></code> is not a view, mutating
it will modify any other arrays which are views into <code class="docutils literal notranslate"><span class="pre">a</span></code>. And while you can
check if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a view by looking at <code class="docutils literal notranslate"><span class="pre">a.base</span></code>, there is no easy way to
check if <code class="docutils literal notranslate"><span class="pre">a</span></code> has other views pointing at it. The only way to know is to
analyze the program and check any array which is created from <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>It’s best to minimize mutations in the presence of views, or to restrict
them to a controlled part of the code, to avoid unexpected “<a class="reference external" href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">action at a
distance</a>”
bugs.</p>
<p>Note that you can always ensure that <code class="docutils literal notranslate"><span class="pre">a</span></code> is a new array that isn’t a view
and doesn’t have any views pointing to it by copying it, using <code class="docutils literal notranslate"><span class="pre">a.copy()</span></code>.</p>
</li>
<li><p>Even if you don’t mutate data, views are important because they are more
efficient. A view is a relatively cheap thing to make, even if the array is
large. It also saves on memory usage.</p>
<p>For example, here we have an array with about 800 kB of data, and it takes
over 200x longer to copy it than to create a view (using
<a class="reference external" href="https://ipython.org/">IPython</a>’s <code class="docutils literal notranslate"><span class="pre">%timeit</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>In [1]: import numpy as np

In [2]: a = np.arange(100000, dtype=np.float64)

In [3]: %timeit a.copy()
25.9 µs ± 645 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)

In [4]: %timeit a[:]
127 ns ± 1.62 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)
</pre></div>
</div>
</li>
</ol>
</section>
<section id="strides">
<span id="id5"></span><h2>Strides<a class="headerlink" href="#strides" title="Link to this heading">¶</a></h2>
<p>The reason so many types of indexing into arrays can be represented as a
<a class="reference internal" href="#views-vs-copies"><span class="std std-ref">view</span></a> without creating a copy is that NumPy arrays aren’t
merely a pointer to a blob of memory. They are a pointer along with something
called <em>strides</em>. The strides tell NumPy how many bytes to skip in memory
along each axis to get to the next element of the array along that dimension.
This along with the <em>memory offset</em> (the address in physical memory of the
first byte of data), the <em>shape</em>, and the <em>itemsize</em> (the number of bytes each
element takes up, which depends on the <em>dtype</em>) exactly determines how the
corresponding memory is organized into an array. For example, let’s start with
a flat 1-dimensional array with <code class="docutils literal notranslate"><span class="pre">24</span></code> elements whose itemsize is 8 (an <code class="docutils literal notranslate"><span class="pre">int64</span></code>
takes up 8 bytes). Its strides is <code class="docutils literal notranslate"><span class="pre">(8,)</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(8,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(24,)</span>
</pre></div>
</div>
<p>Now let’s create a view <code class="docutils literal notranslate"><span class="pre">b</span></code>, which is <code class="docutils literal notranslate"><span class="pre">a</span></code> reshaped to shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">2,</span> <span class="pre">4)</span></code>. <code class="docutils literal notranslate"><span class="pre">b</span></code>
uses the exact same memory as <code class="docutils literal notranslate"><span class="pre">a</span></code> (which is just <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">...</span> <span class="pre">23</span></code>). Its itemsize
is the same because it has the same dtype, but its strides and shape are
different.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7]],</span>

<span class="go">       [[ 8,  9, 10, 11],</span>
<span class="go">        [12, 13, 14, 15]],</span>

<span class="go">       [[16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(64, 32, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 4)</span>
</pre></div>
</div>
<p>This tells NumPy that to get the next element in the first dimension of <code class="docutils literal notranslate"><span class="pre">b</span></code>,
it needs to skip 64 bytes. That’s because the first dimension contains 2*4=8
items each, corresponding to the sizes of the second and third dimensions, and
each item is 8 bytes, so 8*8=64. For example, the next element in the first
dimension after <code class="docutils literal notranslate"><span class="pre">0</span></code> (index <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>) is <code class="docutils literal notranslate"><span class="pre">8</span></code> (index <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>), which sits
exactly 64 bytes after it in memory. Similarly, to get the next element in the
second dimension, it should skip 32 bytes (4 elements).</p>
<p>The memory offset of an array can be accessed using <code class="docutils literal notranslate"><span class="pre">a.ctypes.data</span></code>. This is
the address in physical memory where the data (<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">...</span> <span class="pre">23</span></code>) lives. <code class="docutils literal notranslate"><span class="pre">a</span></code>
and <code class="docutils literal notranslate"><span class="pre">b</span></code> have the same memory offset because they both start with the same
first element:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">105553170825216</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">105553170825216</span>
</pre></div>
</div>
<p>When we slice off the beginning of the array, we can see that all this does is
move the memory offset forward, and adjust the shape correspondingly.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">105553170825232</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(22,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">strides</span> <span class="c1"># the strides are the same</span>
<span class="go">(8,)</span>
</pre></div>
</div>
<p>Specifically, it moves it by <code class="docutils literal notranslate"><span class="pre">2*8</span></code> (where remember <code class="docutils literal notranslate"><span class="pre">8</span></code> is <code class="docutils literal notranslate"><span class="pre">a.itemsize</span></code>):</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">16</span>
</pre></div>
</div>
<p>Here the strides are the same. Similarly, if we slice off the end of the
array, all it needs to do is adjust the shape. The memory offset is the same,
because it still starts at the same place in memory.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span> <span class="c1"># the memory offset is the same</span>
<span class="go">105553170825216</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span> <span class="c1"># the strides are the same</span>
<span class="go">(8,)</span>
</pre></div>
</div>
<p>If we instead slice with a step, this adjusts the strides. For instance
<code class="docutils literal notranslate"><span class="pre">a[::2]</span></code> will double the strides, making it skip every other element (but the
offset will be again unchanged because it still starts at the first element of
<code class="docutils literal notranslate"><span class="pre">a</span></code>):</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(16,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span> <span class="c1"># the memory offset is the same</span>
<span class="go">105553170825216</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(12,)</span>
</pre></div>
</div>
<p>If we use a <em>negative</em> step, the strides will become negative. This will cause
NumPy to work backwards in memory as it accesses the elements of the array.
The memory offset also changes here so that it starts with the last element of
<code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(-16,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">105553170825400</span>
</pre></div>
</div>
<p>From this, you are hopefully convinced that every possible slice is just a
manipulation of the memory offset, shape, and strides. It’s not hard to see
that this also applies to integer indices (which just removes the stride for
the corresponding axis, adjusting the shape and memory offset accordingly) and
newaxis (which just adds <code class="docutils literal notranslate"><span class="pre">0</span></code> to the strides):</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(64, 32, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(32, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(0, 64, 32, 8)</span>
</pre></div>
</div>
<p>This is why <a class="reference internal" href="multidimensional-indices/index.html#basic-indices"><span class="std std-ref">basic indexing</span></a> always produces a
<a class="reference internal" href="#views-vs-copies"><span class="std std-ref">view</span></a>: because it can always be represented as a
manipulation of the strides (plus shape and offset).</p>
<p>Another important fact about strides is that <a class="reference internal" href="#broadcasting"><span class="std std-ref">broadcasting</span></a> can
be achieved by manipulating the strides, namely by using a <code class="docutils literal notranslate"><span class="pre">0</span></code> stride to
repeat the same data along a given axis.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 12, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(192, 16, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 12, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(0, 16, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you’ve ever used <code class="docutils literal notranslate"><span class="pre">broadcast_to()</span></code>, you might have noticed that it returns a
read-only array. That’s because writing into it would not do what you’d
expect, since the repeated elements literally refer to the same memory.</p>
<p>This shows why <a class="reference internal" href="#broadcasting"><span class="std std-ref">broadcasting</span></a> is so powerful: it can be done
without any actual copy of the data. When you perform an operation on two
arrays, the broadcasting is implicit, but even explicitly creating a
broadcasted array is cheap, because all it does is create a view with
different strides.</p>
<p>You can also manually create a view with any strides you want using <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html">stride
tricks</a>.
Most views that you would want to create can be made with a combination of
indexing, <code class="docutils literal notranslate"><span class="pre">reshape</span></code>, <code class="docutils literal notranslate"><span class="pre">broadcast_to</span></code>, and <code class="docutils literal notranslate"><span class="pre">transpose</span></code>, but it’s possible to use
strides to represent some things which are not so easy to do with just these
functions, for example, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.sliding_window_view.html">sliding
windows</a>
and <a class="reference external" href="https://stackoverflow.com/a/43087507/161801">convolutions</a>. However, if
you do use stride tricks, be careful of the caveats (see the <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html">notes section of
the <code class="docutils literal notranslate"><span class="pre">as_strided</span></code>
docs</a>).</p>
</section>
<section id="c-vs-fortran-ordering">
<span id="id6"></span><h2>C vs. Fortran Ordering<a class="headerlink" href="#c-vs-fortran-ordering" title="Link to this heading">¶</a></h2>
<p>NumPy has an internal distinction between C order and Fortran
order.<a class="footnote-reference brackets" href="#c-order-footnote" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> C-ordered arrays are stored in memory such that the
last axis varies the fastest. For example, if <code class="docutils literal notranslate"><span class="pre">a</span></code> has 3 dimensions, then its
elements are stored in memory like <code class="docutils literal notranslate"><span class="pre">a[0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">a[0,</span> <span class="pre">0,</span> <span class="pre">1],</span> <span class="pre">a[0,</span> <span class="pre">0,</span> <span class="pre">2],</span> <span class="pre">...,</span> <span class="pre">a[0,</span> <span class="pre">1,</span> <span class="pre">0],</span> <span class="pre">a[0,</span> <span class="pre">1,</span> <span class="pre">1],</span> <span class="pre">a[0,</span> <span class="pre">1,</span> <span class="pre">2],</span> <span class="pre">...</span></code>. Fortran ordering is the opposite:
the elements are stored in memory so that the first axis varies fastest, like
<code class="docutils literal notranslate"><span class="pre">a[0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">a[1,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">a[2,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">...,</span> <span class="pre">a[0,</span> <span class="pre">1,</span> <span class="pre">0],</span> <span class="pre">a[1,</span> <span class="pre">1,</span> <span class="pre">0],</span> <span class="pre">a[2,</span> <span class="pre">1,</span> <span class="pre">0]</span> <span class="pre">...</span></code>.</p>
<p>The most important thing to note about C and Fortran ordering for our purposes
is that</p>
<blockquote>
<div><p><strong>the internal ordering of an array does not change any indexing
semantics.</strong></p>
</div></blockquote>
<p>The same index will select the same elements on <code class="docutils literal notranslate"><span class="pre">a</span></code> regardless of whether it
uses C or Fortran ordering internally.</p>
<p>More generally, the actual memory layout of an array has no bearing on
indexing semantics. Indexing operates on the logical abstraction of the array
as presented to the user, even if the true memory doesn’t look anything like
that because the array is a <a class="reference internal" href="#views-vs-copies"><span class="std std-ref">view</span></a> or has some other layout
due to <a class="reference internal" href="#strides"><span class="std std-ref">stride tricks</span></a>.</p>
<p>In particular, this also applies to <a class="reference internal" href="multidimensional-indices/boolean-arrays.html"><span class="std std-doc">boolean array
indices</span></a>. A boolean mask always
<a class="reference internal" href="multidimensional-indices/boolean-arrays.html#boolean-array-c-order"><span class="std std-ref">selects the elements in C order</span></a>, even if the
underlying arrays use Fortran ordering.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_f</span> <span class="c1"># a_f looks the same as a, but the internal memory is ordered differently</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="c1"># It doesn&#39;t matter if the index array is Fortran-ordered either</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="c1"># These are all the same</span>
<span class="go">array([1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="go">array([1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx_f</span><span class="p">]</span>
<span class="go">array([1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_f</span><span class="p">[</span><span class="n">idx_f</span><span class="p">]</span>
<span class="go">array([1, 3, 4])</span>
</pre></div>
</div>
<div class="admonition-aside admonition">
<p class="admonition-title">Aside</p>
<p>If you read the previous section on <a class="reference internal" href="#strides"><span class="std std-ref">strides</span></a>, you may have guessed
that the difference between C-ordered and Fortran-ordered arrays is a
difference of…strides!</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(24, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_f</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(8, 24)</span>
</pre></div>
</div>
<p>In a C-ordered array the strides decrease and in a Fortran-ordered array they
increase, because a smaller stride corresponds to “faster varying”.</p>
</div>
<p><strong>What ordering <em>does</em> affect is the performance of certain operations.</strong> In
particular, the ordering determines whether it is more optimal to index along
the first or last axes of an array. For example, <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> selects the first
subarray along the first axis (recall that <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> is a <a class="reference internal" href="#views-vs-copies"><span class="std std-ref">view</span></a>
into <code class="docutils literal notranslate"><span class="pre">a</span></code>, so it references the exact same memory as <code class="docutils literal notranslate"><span class="pre">a</span></code>). For a C-ordered
array, which is the default, this subarray is contiguous in memory. This is
because the indices on the last axes vary the fastest (i.e., are next to each
other in memory), so selecting a subarray of the first axis picks elements
which are still contiguous. Conversely, for a Fortran-ordered array, <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> is
not contiguous, but <code class="docutils literal notranslate"><span class="pre">a[...,</span> <span class="pre">0]</span></code> is.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">contiguous</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">contiguous</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_f</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">contiguous</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Operating on contiguous memory allows the CPU to place the entire memory block
in the cache at once, and is more performant as a result. The performance
difference won’t be noticeable for our small example <code class="docutils literal notranslate"><span class="pre">a</span></code> above, as it is small
enough to fit entirely in the cache, but it becomes significant for larger
arrays. Compare the time to sum along <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> or <code class="docutils literal notranslate"><span class="pre">a[...,</span> <span class="pre">0]</span></code> for a
3-dimensional array <code class="docutils literal notranslate"><span class="pre">a</span></code> with a million elements using C and Fortran ordering
(using <a class="reference external" href="https://ipython.org/">IPython</a>’s <code class="docutils literal notranslate"><span class="pre">%timeit</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>In [1]: import numpy as np

In [2]: a = np.ones((100, 100, 100)) # a has C order (the default)

In [3]: %timeit np.sum(a[0])
8.57 µs ± 121 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)

In [4]: %timeit np.sum(a[..., 0])
24.2 µs ± 1.29 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)

In [5]: a_f = np.asarray(a, order=&#39;F&#39;)

In [6]: %timeit np.sum(a_f[0])
26.3 µs ± 952 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)

In [7]: %timeit np.sum(a_f[..., 0])
8.6 µs ± 130 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
</pre></div>
</div>
<p>Summing along contiguous memory (<code class="docutils literal notranslate"><span class="pre">a[0]</span></code> for C ordering and <code class="docutils literal notranslate"><span class="pre">a[...,</span> <span class="pre">0]</span></code> for
Fortran ordering) is about 3x faster.</p>
<p>NumPy indexing semantics generally favor using C ordering, as it does not
require an ellipsis to select contiguous subarrays. C ordering also matches
the <a class="reference internal" href="multidimensional-indices/what-is-an-array.html"><span class="std std-doc">list-of-lists intuition</span></a> of
an array, since an array like <code class="docutils literal notranslate"><span class="pre">[[0,</span> <span class="pre">1],</span> <span class="pre">[2,</span> <span class="pre">3]]</span></code> is stored in memory as
literally <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3</span></code> with C ordering. It also aligns well with NumPy’s
<a class="reference internal" href="#broadcasting"><span class="std std-ref">broadcasting</span></a> rules, where broadcasted dimensions are prepended
by default, allowing one to think of an array as a “stack” of contiguous
subarrays.</p>
<p>C ordering is the default in NumPy when creating arrays with functions like
<code class="docutils literal notranslate"><span class="pre">asarray</span></code>, <code class="docutils literal notranslate"><span class="pre">ones</span></code>, <code class="docutils literal notranslate"><span class="pre">arange</span></code>, and so on. One typically only switches to
Fortran ordering when calling certain Fortran codes, or when creating an
array from another memory source that produces Fortran-ordered data.</p>
<p>Regardless of which ordering you are using, it is worth structuring your data
so that operations are done on contiguous memory when possible.</p>
<p class="rubric">Footnotes</p>
<!-- Footnotes are written inline above but markdown will put them here at the
end of the document. -->
</section>
</section>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="view-scalar-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<!-- This is the only way to cross reference a footnote across documents -->
<p id="view-scalar-footnote-ref">There is one exception to this rule, which is that an
index that would return a scalar returns a copy, since scalars are
supposed to be immutable.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">np.int64(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="go">array(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="view-functions-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p>Some of these functions will sometimes return a
copy because returning a view is not possible. For example, it is not
always possible to represent a reshape as a <a class="reference internal" href="#strides"><span class="std std-ref">strides</span></a>
manipulation if the strides are already non-contiguous.</p>
</aside>
<aside class="footnote brackets" id="c-order-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">3</a><span class="fn-bracket">]</span></span>
<p>C ordering and Fortran ordering are also sometimes
“row-major” and “column-major” ordering, respectively. However, this
terminology is confusing when the array has more than two axes or when it
does not represent a mathematical matrix. It’s better to think of ordering
in terms of which axes vary the fastest—the last for C ordering and the
first for Fortran ordering. Also, I don’t know about you, but I can never
remember which is supposed to be “row-” and “column-” major, but I do
remember how array indexing works in C, so just thinking about that requires
no mnemonic.</p>
</aside>
</aside>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../type-confusion.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Type Confusion</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="multidimensional-indices/boolean-arrays.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Boolean Array Indices</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2020, Quansight Labs
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/Quansight-Labs/ndindex" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Other Topics Relevant to Indexing</a><ul>
<li><a class="reference internal" href="#broadcasting">Broadcasting</a></li>
<li><a class="reference internal" href="#views-vs-copies">Views vs. Copies</a></li>
<li><a class="reference internal" href="#strides">Strides</a></li>
<li><a class="reference internal" href="#c-vs-fortran-ordering">C vs. Fortran Ordering</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    </body>
</html>