<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Type Confusion" href="type-confusion.html" /><link rel="prev" title="API Reference" href="api.html" />

    <link rel="shortcut icon" href="_static/favicon.ico"/><meta name="generator" content="sphinx-5.3.0, furo 2022.09.29"/>
        <title>Slices - ndindex documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #CCCCCC;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #CCCCCC;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #000000bd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-brand-primary: var(--color-brand-dark-blue);
  --color-brand-content: var(--color-brand-dark-blue);
  --color-sidebar-background: #EEEEEE;
  --color-sidebar-item-background--hover: var(--color-brand-light-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-light-blue);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">ndindex  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="_static/ndindex_logo_white_bg.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="_static/ndindex_logo_dark_bg.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ndindex  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-confusion.html">Type Confusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">ndindex Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Documentation Style Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="slices">
<span id="slices-docs"></span><h1>Slices<a class="headerlink" href="#slices" title="Permalink to this heading">#</a></h1>
<p>Python’s slice syntax is one of the more confusing parts of the language, even
to experienced developers. In this page, I carefully break down the rules for
slicing, and examine just what it is that makes it so confusing.</p>
<p>There are two primary aspects of slices that make them difficult to
understand: confusing conventions, and discontinuous definitions. By confusing
conventions, we mean that slice semantics have definitions that are often
difficult to reason about mathematically. These conventions were chosen for
syntactic convenience, and one can easily see for most of them how they lead
to concise notation for very common operations, but it remains nonetheless
true that they can make figuring out the <em>right</em> slice to use in the first
place complicated. By discontinuous definitions, we mean that the definition
of a slice takes on fundamentally different meanings if the start, stop, or
step are negative, nonnegative, or omitted. This again is done for syntactic
convenience, but it means that as a user, you must switch your mode of
thinking about slices depending on value of the arguments. There are no
uniform formulas that apply to all slices.</p>
<p>The <a class="reference internal" href="index.html"><span class="doc std std-doc">ndindex</span></a> library can help with much of this, especially for people
developing libraries that consume slices. But for end-users the challenge is
often just to write down a slice. Even if you rarely work with NumPy arrays,
you will most likely require slices to select parts of lists or strings as
part of the normal course of Python coding.</p>
<p>ndindex focuses on NumPy array index semantics, but everything on this page
equally applies to sliceable Python builtin objects like lists, tuples, and
strings. This is because on a single dimension, NumPy slice semantics are
identical to the Python slice semantics (NumPy only begins to differ from
Python for multi-dimensional indices).</p>
<section id="what-is-a-slice">
<h2>What is a slice?<a class="headerlink" href="#what-is-a-slice" title="Permalink to this heading">#</a></h2>
<p>In Python, a slice is a special syntax that is allowed only in an index, that
is, inside of square brackets proceeding an expression. A slice consists of
one or two colons, with either an expression or nothing on either side of each
colon. For example, the following are all valid slices on the object <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">:</span><span class="n">z</span><span class="p">]</span>
<span class="n">a</span><span class="p">[:]</span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">::]</span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">::</span><span class="n">z</span><span class="p">]</span>
</pre></div>
</div>
<p>Furthermore, for a slice <code class="docutils literal notranslate"><span class="pre">a[x:y:z]</span></code>, if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a Python built-in object or a
NumPy array, there is an additional semantic restriction, which is that the
expressions <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> must be integers.</p>
<p>The three arguments to a slice are traditionally called <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and
<code class="docutils literal notranslate"><span class="pre">step</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
</pre></div>
</div>
<p>We will use these names throughout this guide.</p>
<p>It is worth noting that the <code class="docutils literal notranslate"><span class="pre">x:y:z</span></code> syntax is not valid outside of square
brackets. However, slice objects can be created manually using the <code class="docutils literal notranslate"><span class="pre">slice()</span></code>
builtin (<code class="docutils literal notranslate"><span class="pre">a[x:y:z]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">a[slice(x,</span> <span class="pre">y,</span> <span class="pre">z)]</span></code>). If you want to
perform more advanced operations like arithmetic on slices, consider using
the <a class="reference internal" href="api.html#slice-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">ndindex.Slice()</span></code></span></a> object.</p>
</section>
<section id="rules">
<span id="id1"></span><h2>Rules<a class="headerlink" href="#rules" title="Permalink to this heading">#</a></h2>
<p>These are the rules to keep in mind to understand how slices work. Each of
these is explained in detail below. Many of the detailed descriptions below
also outline several <em>wrong</em> rules, which are bad ways of thinking about
slices but which you may be tempted to think about as rules. The below 7 rules
are always correct.</p>
<p>In this document, “<em>nonnegative</em>” means <span class="math notranslate nohighlight">\(\geq 0\)</span> and “<em>negative</em>” means <span class="math notranslate nohighlight">\(&lt; 0\)</span>.</p>
<p>For a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code>:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> use <strong>0-based indexing</strong> from the <strong>beginning</strong> of <code class="docutils literal notranslate"><span class="pre">a</span></code>
when they are <strong>nonnegative</strong>, and <strong>−1-based indexing</strong> from <strong>end</strong> of
<code class="docutils literal notranslate"><span class="pre">a</span></code> when they are <strong>negative</strong>. (See sections <a class="reference internal" href="#based"><span class="std std-ref">0-based</span></a> and
<a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative Indices</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stop</span></code> is never included in the slice. (See section <a class="reference internal" href="#half-open"><span class="std std-ref">Half-open</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are clipped to the bounds of <code class="docutils literal notranslate"><span class="pre">a</span></code>. (See section <a class="reference internal" href="#clipping"><span class="std std-ref">Clipping</span></a>)</p></li>
<li><p>The slice starts at <code class="docutils literal notranslate"><span class="pre">start</span></code> and successively adds <code class="docutils literal notranslate"><span class="pre">step</span></code> until it reaches
an index that is at or past <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and then stops without including that
<code class="docutils literal notranslate"><span class="pre">stop</span></code> index. (See sections <a class="reference internal" href="#steps"><span class="std std-ref">Steps</span></a> and <a class="reference internal" href="#negative-steps"><span class="std std-ref">Negative Steps</span></a>)</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">step</span></code> is omitted it defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>. (See section <a class="reference internal" href="#omitted"><span class="std std-ref">Omitted Entries</span></a>)</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are omitted they extend to the beginning or end of <code class="docutils literal notranslate"><span class="pre">a</span></code>
in the direction being sliced. Slices like <code class="docutils literal notranslate"><span class="pre">a[:i]</span></code> or <code class="docutils literal notranslate"><span class="pre">a[i:]</span></code> should be
though of as the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> being omitted, not as a colon to the
left or right of an index. (See section <a class="reference internal" href="#omitted"><span class="std std-ref">Omitted Entries</span></a>)</p></li>
<li><p>Slicing something never raises an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>, even if the slice is empty.
For a NumPy array, a slice always keeps the axis being sliced, even if that
means the resulting dimension will be 0 or 1. (See section <a class="reference internal" href="#subarray"><span class="std std-ref">Subarray</span></a>)</p></li>
</ol>
</section>
<section id="integer-indices">
<span id="id2"></span><h2>Integer indices<a class="headerlink" href="#integer-indices" title="Permalink to this heading">#</a></h2>
<p>To understand slices, it is good to first review how integer indices work.
Throughout this guide, we will use as an example this prototype list:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[
a = [\mathtt{\textsf{'}a\textsf{'}},\ \mathtt{\textsf{'}b\textsf{'}},\ \mathtt{\textsf{'}c\textsf{'}},\
\mathtt{\textsf{'}d\textsf{'}},\ \mathtt{\textsf{'}e\textsf{'}},\ \mathtt{\textsf{'}f\textsf{'}},\ \mathtt{\textsf{'}g\textsf{'}}]
\]</div>
</div>
<p>The list <code class="docutils literal notranslate"><span class="pre">a</span></code> has 7 elements.</p>
<p>The elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> are strings, but the indices and slices on the list <code class="docutils literal notranslate"><span class="pre">a</span></code>
will always use integers. An index or slice is never based on the value of the
elements, but rather the position of the elements in the list.<a class="footnote-reference brackets" href="#dict-footnote" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>An integer index picks a single element from the list <code class="docutils literal notranslate"><span class="pre">a</span></code>. For NumPy arrays,
integer indices pick a subarray corresponding to a particular element from a
given axis (and as a result, an integer index always reduces the
dimensionality of an array by one).</p>
<p id="fourth-sentence">The key thing to remember about indexing in Python, both for integer and
slice indexing, is that it is 0-based. This means that the indices start
at 0. This is the case for all <strong>nonnegative</strong> indices.
For example, <code class="docutils literal notranslate"><span class="pre">a[3]</span></code> would pick the <strong>fourth</strong> element of <code class="docutils literal notranslate"><span class="pre">a</span></code>, in this case, <code class="docutils literal notranslate"><span class="pre">'d'</span></code>.</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[3] == 'd'</code>
$$
\begin{aligned}
\begin{array}{r c c c c c c c}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    & \color{#EE0000}{1\phantom{,}}
    & \color{#EE0000}{2\phantom{,}}
    & \color{#5E5EFF}3{\phantom{,}}
    & \color{#EE0000}{4\phantom{,}}
    & \color{#EE0000}{5\phantom{,}}
    & \color{#EE0000}{6\phantom{,}}\\
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">&#39;d&#39;</span>
</pre></div>
</div>
<p>0-based indexing is different from how people typically count things, which is
1-based (1, 2, 3, …). Thinking in terms of 0-based indexing requires some
practice.</p>
<p>For <strong>negative</strong> integers, indices index from the end of the list. These
indices are necessarily 1-based (or rather, −1-based), since <code class="docutils literal notranslate"><span class="pre">0</span></code> already
refers to the first element of the list. <code class="docutils literal notranslate"><span class="pre">-1</span></code> chooses the last element, <code class="docutils literal notranslate"><span class="pre">-2</span></code>
the second-to-last, and so on. For example, <code class="docutils literal notranslate"><span class="pre">a[-3]</span></code> picks the
<strong>third-to-last</strong> element of <code class="docutils literal notranslate"><span class="pre">a</span></code>, in this case, <code class="docutils literal notranslate"><span class="pre">'e'</span></code>:</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[-3] == 'e'</code>
$$
\begin{aligned}
\begin{array}{r c c c c c c c}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{-7\phantom{,}}
    & \color{#EE0000}{-6\phantom{,}}
    & \color{#EE0000}{-5\phantom{,}}
    & \color{#EE0000}{-4\phantom{,}}
    & \color{#5E5EFF}{-3\phantom{,}}
    & \color{#EE0000}{-2\phantom{,}}
    & \color{#EE0000}{-1\phantom{,}}\\
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
<span class="go">&#39;e&#39;</span>
</pre></div>
</div>
<p>An equivalent way to think about negative indices is that an index
<code class="docutils literal notranslate"><span class="pre">a[-i]</span></code> picks <code class="docutils literal notranslate"><span class="pre">a[len(a)</span> <span class="pre">-</span> <span class="pre">i]</span></code>, that is, you can subtract the negative
index off of the size of <code class="docutils literal notranslate"><span class="pre">a</span></code> (for a NumPy array, replace <code class="docutils literal notranslate"><span class="pre">len(a)</span></code>
with the size of the axis being sliced). For example, <code class="docutils literal notranslate"><span class="pre">len(a)</span></code> is <code class="docutils literal notranslate"><span class="pre">7</span></code>, so
<code class="docutils literal notranslate"><span class="pre">a[-3]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">a[7</span> <span class="pre">-</span> <span class="pre">3]</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">7</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span>
<span class="go">&#39;e&#39;</span>
</pre></div>
</div>
<p>Therefore, negative indices are primarily a syntactic convenience that
allows one to specify parts of a list that would otherwise need to be
specified in terms of the size of the list.</p>
<p>If an integer index is greater than or equal to the size of the list, or less
than negative the size of the list (<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">len(a)</span></code> or <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">-len(a)</span></code>), then it
is out of bounds and will raise an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">list index out of range</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">list index out of range</span>
</pre></div>
</div>
</section>
<section id="points-of-confusion">
<h2>Points of Confusion<a class="headerlink" href="#points-of-confusion" title="Permalink to this heading">#</a></h2>
<p>Now let us come back to slices. The full definition of a slice could be
written down in a couple of sentences, although the discontinuous definitions
would necessitate several “if” conditions. The <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.indexing.html">NumPy
docs</a> on slices
say</p>
<blockquote id="numpy-definition">
<div><p>The basic slice syntax is <code class="docutils literal notranslate"><span class="pre">i:j:k</span></code> where <em>i</em> is the starting index, <em>j</em> is
the stopping index, and <em>k</em> is the step ( <span class="math notranslate nohighlight">\(k\neq 0\)</span> ). This selects the <code class="docutils literal notranslate"><span class="pre">m</span></code>
elements (in the corresponding dimension) with index values <em>i, i + k, …,
i + (m - 1) k</em> where <span class="math notranslate nohighlight">\(m = q + (r\neq 0)\)</span> and <em>q</em> and <em>r</em> are the quotient and
remainder obtained by dividing <em>j - i</em> by <em>k</em>: <em>j - i = q k + r</em>, so that
<em>i + (m - 1) k &lt; j</em>.</p>
</div></blockquote>
<p>While definitions like this may give a technically accurate description of
slices, they aren’t especially helpful to someone who is trying to construct a
slice from a higher level of abstraction such as “I want to select this
particular subset of my array”.<a class="footnote-reference brackets" href="#numpy-definition-footnote" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p>Instead, we shall examine slices by carefully going over all the various
aspects of the syntax and semantics that can lead to confusion, and attempting
to demystify them through simple <a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a>.</p>
<section id="subarray">
<span id="id5"></span><h3>Subarray<a class="headerlink" href="#subarray" title="Permalink to this heading">#</a></h3>
<blockquote>
<div><p><strong>A slice always produces a subarray (or sub-list, sub-tuple, sub-string,
etc.). For NumPy arrays, this means that a slice will always <em>preserve</em> the
dimension that is sliced.</strong></p>
</div></blockquote>
<p>This is true even if the slice chooses only a single element, or even if it
chooses no elements. This is also true for lists, tuples, and strings, in the
sense that a slice on a list, tuple, or string will always produce a list,
tuple, or string. This behavior is different from integer indices, which
always remove the dimension that they index.</p>
<p>For example</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">&#39;d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[&#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Empty slice</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Integer index removes the first dimension</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Slice preserves the first dimension</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>One consequence of this is that, unlike integer indices, <strong>slices will never
raise <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>, even if the slice is empty</strong>. Therefore you cannot rely on
runtime errors to alert you to coding mistakes relating to slice bounds that
are too large. A slice cannot be “out of bounds.” See the section on
<a class="reference internal" href="#clipping"><span class="std std-ref">clipping</span></a> below.</p>
</section>
<section id="based">
<span id="id6"></span><h3>0-based<a class="headerlink" href="#based" title="Permalink to this heading">#</a></h3>
<p>For the slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code>, with <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> nonnegative integers,
the indices <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are 0-based, just as with <a class="reference internal" href="#integer-indices"><span class="std std-ref">integer
indexing</span></a> (although one should be careful that even though
<code class="docutils literal notranslate"><span class="pre">stop</span></code> is 0-based, it is not included in the slice, see <a class="reference internal" href="#half-open"><span class="std std-ref">below</span></a>).</p>
<p>For example:</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[3:5] == ['d', 'e']</code>
$$
\begin{aligned}
\begin{array}{r c c c c c c c}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    & \color{#EE0000}{1\phantom{,}}
    & \color{#EE0000}{2\phantom{,}}
    & \color{#5E5EFF}{3\phantom{,}}
    & \color{#5E5EFF}{4\phantom{,}}
    & \color{#EE0000}{5\phantom{,}}
    & \color{#EE0000}{6\phantom{,}}\\
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>Do not be worried if you find 0-based indexing hard to get used to, or if you
find yourself forgetting about it. Even experienced Python developers (this
author included) still find themselves writing <code class="docutils literal notranslate"><span class="pre">a[3]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">a[2]</span></code> from
time to time. The best way to learn to use 0-based indexing is to practice
using it enough that you use it automatically without thinking about it.</p>
</section>
<section id="half-open">
<span id="id7"></span><h3>Half-open<a class="headerlink" href="#half-open" title="Permalink to this heading">#</a></h3>
<p>Slices behave like half-open intervals. What this means is that the <code class="docutils literal notranslate"><span class="pre">stop</span></code> in
<code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> is <em>never</em> included in the slice (the exception is if the
<code class="docutils literal notranslate"><span class="pre">stop</span></code> is omitted, see <a class="reference internal" href="#omitted"><span class="std std-ref">below</span></a>).</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">a[3:5]</span></code> slices the indices <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code>, but not <code class="docutils literal notranslate"><span class="pre">5</span></code>
(<a class="reference internal" href="#based"><span class="std std-ref">0-based</span></a>).</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[3:5] == ['d', 'e']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r c c c c c c c}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    & \color{#EE0000}{1\phantom{,}}
    & \color{#EE0000}{2\phantom{,}}
    & \color{#5E5EFF}{\enclose{circle}{3}}
    & \color{#5E5EFF}{\enclose{circle}{4}}
    & \color{#EE0000}{\enclose{circle}{5}}
    & \color{#EE0000}{6\phantom{,}}\\
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>The half-open nature of slices means that you must always remember that the
<code class="docutils literal notranslate"><span class="pre">stop</span></code> slice element is not included in the slice. However, it has a few
advantages:</p>
<ul id="sanity-check">
<li><p>The maximum length of a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code>, when <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are
nonnegative, is always <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">-</span> <span class="pre">start</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">a[i:i+n]</span></code> will slice
<code class="docutils literal notranslate"><span class="pre">n</span></code> elements from <code class="docutils literal notranslate"><span class="pre">a</span></code>. The caveat “maximum” is here because if <code class="docutils literal notranslate"><span class="pre">stop</span></code>
extends beyond the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>, then <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> will only slice up
to <code class="docutils literal notranslate"><span class="pre">len(a)</span> <span class="pre">-</span> <span class="pre">start</span></code> (see <a class="reference internal" href="#clipping"><span class="std std-ref">Clipping</span></a> below). Also be careful that this
is only true when <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are nonnegative (see
<a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative Indices</span></a> below). However, given those caveats, this is often
a very useful sanity check that a slice is correct. If you expect a slice to
have length <code class="docutils literal notranslate"><span class="pre">n</span></code> but <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">-</span> <span class="pre">start</span></code> is clearly different from <code class="docutils literal notranslate"><span class="pre">n</span></code>, then the
slice is likely wrong. Length calculations are more complicated when <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">!=</span> <span class="pre">1</span></code>; in those cases, <a class="reference internal" href="api.html#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">len(ndindex.Slice(...))</span></code></a> can be useful.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len(a)</span></code> can be used as a <code class="docutils literal notranslate"><span class="pre">stop</span></code> value to slice to the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>. For
example, <code class="docutils literal notranslate"><span class="pre">a[1:len(a)]</span></code> slices from the second element to the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>
(this is equivalent to <code class="docutils literal notranslate"><span class="pre">a[1:]</span></code>, see <a class="reference internal" href="#omitted"><span class="std std-ref">Omitted Entries</span></a>)</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
</li>
<li><p>Consecutive slices can be appended to one another by making each successive
slice’s <code class="docutils literal notranslate"><span class="pre">start</span></code> the same as the previous slice’s <code class="docutils literal notranslate"><span class="pre">stop</span></code>. For example, for our
list <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">a[2:3]</span> <span class="pre">+</span> <span class="pre">a[3:5]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">a[2:5]</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>A common usage of this is to split a slice into two slices. For example, the
slice <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> can be split as <code class="docutils literal notranslate"><span class="pre">a[i:k]</span></code> and <code class="docutils literal notranslate"><span class="pre">a[k:j]</span></code>.</p>
</li>
</ul>
<section id="wrong-ways-of-thinking-about-half-open-semantics">
<h4>Wrong Ways of Thinking about Half-open Semantics<a class="headerlink" href="#wrong-ways-of-thinking-about-half-open-semantics" title="Permalink to this heading">#</a></h4>
<blockquote>
<div><p><strong>The proper rule to remember for half-open semantics is “the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is not
included”.</strong></p>
</div></blockquote>
<p>There are several alternative ways that one might think of slice semantics,
but they are all wrong in subtle ways. To be sure, for each of these, one
could “fix” the rule by adding some conditions, “it’s this in the case where
such and such is nonnegative and that when such and such is negative, and so
on”. But that’s not the point. The goal here is to <em>understand</em> slices.
Remember that one of the reasons that slices are difficult to understand is
these branching rules. By trying to remember a rule that has branching
conditions, you open yourself up to confusion. The rule becomes much more
complicated than it appears at first glance, making it hard to remember. You
may forget the “uncommon” cases and get things wrong when they come up in
practice. You might as well think about slices using the <a class="reference internal" href="#numpy-definition"><span class="std std-ref">definition from the
NumPy docs</span></a>.</p>
<p>Rather, it is best to remember the simplest rule possible that is <em>always</em>
correct. That rule is, “the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is not included”. This rule is extremely
simple, and is always right, regardless of what the values of <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>,
or <code class="docutils literal notranslate"><span class="pre">step</span></code> are. The only exception is if <code class="docutils literal notranslate"><span class="pre">stop</span></code> is omitted. In this case, the
rule obviously doesn’t apply as-is, and so you can fallback to the rule about
omitted <code class="docutils literal notranslate"><span class="pre">start</span></code>/<code class="docutils literal notranslate"><span class="pre">stop</span></code> (see <a class="reference internal" href="#omitted"><span class="std std-ref">Omitted Entries</span></a> below).</p>
<p id="wrong-rule-1"><strong style="font-size:120%;" style="font-size:120%;">Wrong Rule 1: “a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> slices the half-open interval
<span class="math notranslate nohighlight">\([\text{start}, \text{stop})\)</span> (equivalently, a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> picks the
elements <code class="docutils literal notranslate"><span class="pre">i</span></code> such that <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">stop</span></code>).” <a class="headerlink"
href="#wrong-rule-1" title="Permalink to this headline">¶</a> </strong></p>
<p>This is <em>only</em> the case if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive. It also isn’t directly true
for negative <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code>. For example, with a <code class="docutils literal notranslate"><span class="pre">step</span></code> of <code class="docutils literal notranslate"><span class="pre">-1</span></code>,
<code class="docutils literal notranslate"><span class="pre">a[start:stop:-1]</span></code> slices starting at <code class="docutils literal notranslate"><span class="pre">start</span></code> going in reverse order to
<code class="docutils literal notranslate"><span class="pre">stop</span></code>, but not including <code class="docutils literal notranslate"><span class="pre">stop</span></code>. Mathematically, this creates a half open
interval <span class="math notranslate nohighlight">\((\text{stop}, \text{start}]\)</span> (except reversed).</p>
<p>For example, say way believed that <code class="docutils literal notranslate"><span class="pre">a[5:3:-1]</span></code> sliced the half-open interval
<span class="math notranslate nohighlight">\([3, 5)\)</span> but in reverse order.</p>
<!-- TODO: improve this -->
<div style="text-align:center;" >
<code style="font-size: 16pt;">a[5:3:-1] "==" ['e', 'd']</code>
<div style="font-size: 16pt;color:#EE0000;">(WRONG)</div>
$$
\begin{aligned}
\begin{array}{r c c c c c c c}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    & \color{#EE0000}{1\phantom{,}}
    & \color{#EE0000}{2\phantom{,}}
    & \color{#5E5EFF}{3\phantom{,}}
    & \color{#5E5EFF}{4\phantom{,}}
    & \color{#EE0000}{5\phantom{,}}
    & \color{#EE0000}{6\phantom{,}}\\
\color{#EE0000}{\text{WRONG}}&
    &
    &
    & [\phantom{3,}
    &
    & )
    & \\
\end{array}\\
\small{\text{(reversed)}}\hspace{3.5em}
\end{aligned}
$$
</div>
<p>We might assume we would get</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="c1"># WRONG</span>
</pre></div>
</div>
<p>Actually, what we really get is</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>This is because the slice <code class="docutils literal notranslate"><span class="pre">5:3:-1</span></code> starts at index <code class="docutils literal notranslate"><span class="pre">5</span></code> and steps backwards to
index <code class="docutils literal notranslate"><span class="pre">3</span></code>, but not including <code class="docutils literal notranslate"><span class="pre">3</span></code> (see <a class="reference internal" href="#negative-steps"><span class="std std-ref">Negative Steps</span></a> below).</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[5:3:-1] == ['f', 'e']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r r r r r r r}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{\textsf{'},}}
    & \color{#EE0000}{1\phantom{\textsf{'},}}
    & \color{#EE0000}{2\phantom{\textsf{'},}}
    & \color{#EE0000}{\enclose{circle}{3}\phantom{,}}
    & \leftarrow\color{#5E5EFF}{\enclose{circle}{4}\phantom{,}}
    & \leftarrow\color{#5E5EFF}{\enclose{circle}{5}\phantom{,}}
    & \color{#EE0000}{6\phantom{\textsf{'},}}\\
\end{array}
\end{aligned}
$$
</div>
<p id="wrong-rule-2"><strong style="font-size:120%;">Wrong Rule 2: “A slice works like <code class="docutils literal notranslate"><span class="pre">range()</span></code>.” <a class="headerlink"
href="#wrong-rule-2" title="Permalink to this headline">¶</a> </strong></p>
<p>There are many similarities between the behaviors of slices and the behavior
of <code class="docutils literal notranslate"><span class="pre">range()</span></code>. However, they do not behave the same. A slice
<code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code> only acts like <code class="docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> if <code class="docutils literal notranslate"><span class="pre">start</span></code> and
<code class="docutils literal notranslate"><span class="pre">stop</span></code> are <strong>nonnegative</strong>. If either of them are negative, the slice wraps
around and slices from the end of the list (see <a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative Indices</span></a>
below). <code class="docutils literal notranslate"><span class="pre">range()</span></code> on the other hand treats negative numbers as the actual
start and stop values for the range. For example:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># b is range(7), and these are the same</span>
<span class="go">[3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># Empty, because -2 is less than 3</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Indexes from 3 to the second to last (5)</span>
<span class="go">[3, 4]</span>
</pre></div>
</div>
<p>This rule is tempting because <code class="docutils literal notranslate"><span class="pre">range()</span></code> makes some computations easy. For
example, you can index or take the <code class="docutils literal notranslate"><span class="pre">len()</span></code> of a range. If you want to perform
computations on slices, we recommend using <a class="reference internal" href="api.html#slice-api"><span class="std std-ref">ndindex</span></a>. This is what
it was designed for.</p>
<p id="wrong-rule-3"><strong style="font-size:120%;">Wrong Rule 3: “Slices index the spaces between the elements of the list.”<a class="headerlink"
href="#wrong-rule-3" title="Permalink to this headline">¶</a> </strong></p>
<p>This is a very common rule that is taught for both slices and integer
indexing. The reasoning goes as follows: 0-based indexing is confusing, where
the first element of a list is indexed by 0, the second by 1, and so on.
Rather than thinking about that, consider the spaces between the elements:</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[3:5] == ['d', 'e']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r r r r r r r r r r r r r r r r r}
a = & [&\phantom{|}&\mathtt{\textsf{'}a\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}b\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}c\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}d\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}e\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}f\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}g\textsf{'}}&\phantom{|}&]&\\
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}\\
\color{#EE0000}{\text{index}}
    &
    & \color{#EE0000}{0}
    &
    & \color{#EE0000}{1}
    &
    & \color{#EE0000}{2}
    &
    & \color{#5E5EFF}{3}
    &
    & \color{#5E5EFF}{4}
    &
    & \color{#5E5EFF}{5}
    &
    & \color{#EE0000}{6}
    &
    & \color{#EE0000}{7}\\
\end{array}\\
\end{aligned}
$$
<i>(not a great way of thinking about indices)</i>
</div>
<p>Using this way of thinking, the first element of <code class="docutils literal notranslate"><span class="pre">a</span></code> is to the left of
the “1-divider”. An integer index <code class="docutils literal notranslate"><span class="pre">i</span></code> produces the element to the right of the
“<code class="docutils literal notranslate"><span class="pre">i</span></code>-divider”, and a slice <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> picks the elements between the <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>
dividers.</p>
<p>At first glance, this seems like a rather clever way to think about the
half-open rule. For instance, between the <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code> dividers is the subarray
<code class="docutils literal notranslate"><span class="pre">['d',</span> <span class="pre">'e']</span></code>, which is indeed what we get for <code class="docutils literal notranslate"><span class="pre">a[3:5]</span></code>. However, there are several
reasons why this way of thinking creates more confusion than it removes.</p>
<ul>
<li><p>As with <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">wrong rule 1</span></a>, it works well enough if the step is
positive, but falls apart when it is negative.</p>
<p>Consider again the slice <code class="docutils literal notranslate"><span class="pre">a[5:3:-1]</span></code>. Looking at the above figure, we might
imagine it to give the same incorrect subarray that we imagined before.</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[5:3:-1] "==" ['e', 'd']</code>
<div style="font-size: 16pt;color:#EE0000;">(WRONG)</div>
$$
\require{enclose}
\begin{aligned}
\begin{array}{c}
\begin{array}{r r r r r r r r r r r r r r r r r r}
  a = & [&\phantom{|}&\mathtt{\textsf{'}a\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}b\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}c\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}d\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}e\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}f\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}g\textsf{'}}&\phantom{|}&]&\\
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}\\
\color{#EE0000}{\text{index}}
    &
    & \color{#EE0000}{0}
    &
    & \color{#EE0000}{1}
    &
    & \color{#EE0000}{2}
    &
    & \color{#5E5EFF}{3}
    &
    & \color{#5E5EFF}{4}
    &
    & \color{#5E5EFF}{5}
    &
    & \color{#EE0000}{6}
    &
    & \color{#EE0000}{7}\\
\end{array}\\
\small{\color{#EE0000}{\textbf{THIS IS WRONG!}}}
\end{array}
\end{aligned}
$$
</div>
<p>As before, we might assume we would get</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="c1"># WRONG</span>
</pre></div>
</div>
<p>but this is incorrect! What we really get is</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>If you’ve ever espoused the “spaces between elements” way of thinking about
indices, this should give you serious pause. One can see from the above
diagram that there is clearly no way to salvage this rule to see <code class="docutils literal notranslate"><span class="pre">a[5:3:-1]</span></code>
as giving <code class="docutils literal notranslate"><span class="pre">['f',</span> <span class="pre">'e']</span></code>. Contrast the same slice when simply thinking about
it as stepping backwards from index <code class="docutils literal notranslate"><span class="pre">5</span></code> to index <code class="docutils literal notranslate"><span class="pre">3</span></code>, but not including
index <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[5:3:-1] == ['f', 'e']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r c c c c c c c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, && \mathtt{\textsf{'}b\textsf{'}}, && \mathtt{\textsf{'}c\textsf{'}}, && \mathtt{\textsf{'}d\textsf{'}}, && \mathtt{\textsf{'}e\textsf{'}}, && \mathtt{\textsf{'}f\textsf{'}}, && \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    &
    & \color{#EE0000}{1\phantom{,}}
    &
    & \color{#EE0000}{2\phantom{,}}
    &
    & \color{#EE0000}{\enclose{circle}{3}}
    &
    & \color{#5E5EFF}{\enclose{circle}{4}}
    &
    & \color{#5E5EFF}{\enclose{circle}{5}}
    &
    & \color{#EE0000}{6\phantom{,}}\\
    &
    & \phantom{\leftarrow}
    &
    & \phantom{\leftarrow}
    &
    & \phantom{\leftarrow}
    & \color{#EE0000}{-1}
    & \leftarrow
    & \color{#5E5EFF}{-1}
    & \leftarrow
    & \color{#5E5EFF}{\text{start}}
\end{array}
\end{aligned}
$$
</div>
</li>
<li><p>The rule does work for negative <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>, but only if you think
about it correctly. The correct way to think about it is to reverse the
indices:</p>
<div style="text-align:center" >
<code style="font-size: 16pt;">a[-4:-2] == ['d', 'e']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{c}
\begin{array}{r r r r r r r r r r r r r r r r r r}
  a = & [&\phantom{|}&\mathtt{\textsf{'}a\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}b\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}c\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}d\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}e\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}f\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}g\textsf{'}}&\phantom{|}&]&\\
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}\\
\color{#EE0000}{\text{index}}
    &
    & \color{#EE0000}{-7}
    &
    & \color{#EE0000}{-6}
    &
    & \color{#EE0000}{-5}
    &
    & \color{#5E5EFF}{-4}
    &
    & \color{#5E5EFF}{-3}
    &
    & \color{#5E5EFF}{-2}
    &
    & \color{#EE0000}{-1}
    &
    & \color{#EE0000}{0}\\
\end{array}\\
\small{\text{(not a great way of thinking about negative indices)}}
\end{array}
\end{aligned}
$$
</div>
<p>For example, <code class="docutils literal notranslate"><span class="pre">a[-4:-2]</span></code> will give <code class="docutils literal notranslate"><span class="pre">['d',</span> <span class="pre">'e']</span></code></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>However, it would be quite easy to get confused here, as the “other” way of
thinking about negative indices (the way we are recommending) is that the
end starts at -1. So you might mistakenly imagine something like this:</p>
<div style="text-align:center" >
<code style="font-size: 16pt;">a[-4:-2] "==" ['e', 'f']</code>
<div style="font-size: 16pt;color:#EE0000;">(WRONG)</div>
$$
\require{enclose}
\begin{aligned}
\begin{array}{c}
\begin{array}{r r r r r r r r r r r r r r r r r r}
  a = & [&\phantom{|}&\mathtt{\textsf{'}a\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}b\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}c\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}d\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}e\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}f\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}g\textsf{'}}&\phantom{|}&]&\\
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#EE0000}{|}\\
\color{#EE0000}{\text{index}}
    &
    & \color{#EE0000}{-8}
    &
    & \color{#EE0000}{-7}
    &
    & \color{#EE0000}{-6}
    &
    & \color{#EE0000}{-5}
    &
    & \color{#5E5EFF}{-4}
    &
    & \color{#5E5EFF}{-3}
    &
    & \color{#5E5EFF}{-2}
    &
    & \color{#EE0000}{-1}\\
\end{array}\\
\small{\color{#EE0000}{\textbf{THIS IS WRONG!}}}
\end{array}
\end{aligned}
$$
</div>
<p>But things are even worse than that. If we combine negative <code class="docutils literal notranslate"><span class="pre">start</span></code> and
<code class="docutils literal notranslate"><span class="pre">stop</span></code> and negative <code class="docutils literal notranslate"><span class="pre">step</span></code>, things get even more confusing. Consider the
slice <code class="docutils literal notranslate"><span class="pre">a[-2:-4:-1]</span></code>. This gives <code class="docutils literal notranslate"><span class="pre">['f',</span> <span class="pre">'e']</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>To get this with the “spacers” idea, we have to use the above “wrong”
diagram:</p>
<div style="text-align:center" >
<code style="font-size: 16pt;">a[-2:-4:-1] == ['f', 'e']</code>
<div style="font-size: 16pt;color:#5E5EFF;">NOW RIGHT!</div>
$$
\require{enclose}
\begin{aligned}
\begin{array}{c}
\begin{array}{r r r r r r r r r r r r r r r r r r}
  a = & [&\phantom{|}&\mathtt{\textsf{'}a\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}b\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}c\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}d\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}e\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}f\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}g\textsf{'}}&\phantom{|}&]&\\
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#EE0000}{|}\\
\color{#EE0000}{\text{index}}
    &
    & \color{#EE0000}{-8}
    &
    & \color{#EE0000}{-7}
    &
    & \color{#EE0000}{-6}
    &
    & \color{#EE0000}{-5}
    &
    & \color{#5E5EFF}{-4}
    &
    & \color{#5E5EFF}{-3}
    &
    & \color{#5E5EFF}{-2}
    &
    & \color{#EE0000}{-1}\\
\end{array}\\
\small{\text{(not a great way of thinking about negative indices)}}
\end{array}
\end{aligned}
$$
</div>
<div style="text-align:center" >
<code style="font-size: 16pt;">a[-2:-4:-1] "==" ['e', 'd']</code>
<div style="font-size: 16pt;color:#EE0000;">(WRONG)</div>
$$
\require{enclose}
\begin{aligned}
\begin{array}{c}
\begin{array}{r r r r r r r r r r r r r r r r r r}
  a = & [&\phantom{|}&\mathtt{\textsf{'}a\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}b\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}c\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}d\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}e\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}f\textsf{'}}, &\phantom{|}& \mathtt{\textsf{'}g\textsf{'}}&\phantom{|}&]&\\
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#5E5EFF}{|}
    &
    & \color{#EE0000}{|}
    &
    & \color{#EE0000}{|}\\
\color{#EE0000}{\text{index}}
    &
    & \color{#EE0000}{-7}
    &
    & \color{#EE0000}{-6}
    &
    & \color{#EE0000}{-5}
    &
    & \color{#5E5EFF}{-4}
    &
    & \color{#5E5EFF}{-3}
    &
    & \color{#5E5EFF}{-2}
    &
    & \color{#EE0000}{-1}
    &
    & \color{#EE0000}{0}\\
\end{array}\\
\small{\color{#EE0000}{\textbf{THIS IS WRONG!}}}
\end{array}
\end{aligned}
$$
</div>
<p>In other words, the “right” way to think of spacers with negative <code class="docutils literal notranslate"><span class="pre">start</span></code>
and <code class="docutils literal notranslate"><span class="pre">stop</span></code> depends if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive or negative.</p>
<p>This is because the correct half-open rule is based on not including the
<code class="docutils literal notranslate"><span class="pre">stop</span></code>. It <em>isn’t</em> based on not including the larger end of the interval. If
the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive, the <code class="docutils literal notranslate"><span class="pre">stop</span></code> will be larger, but if it is
<a class="reference internal" href="#negative-steps"><span class="std std-ref">negative</span></a>, the <code class="docutils literal notranslate"><span class="pre">start</span></code> will be larger.</p>
</li>
<li><p>The rule “works” for slices, but is harder to imagine for integer indices.
In the divider way of thinking, an integer index <code class="docutils literal notranslate"><span class="pre">n</span></code> corresponds to the
entry to the <em>right</em> of the <code class="docutils literal notranslate"><span class="pre">n</span></code> divider. Rules that involve remembering left
or right aren’t great when it comes to memorability.</p></li>
</ul>
<ul id="fencepost">
<li><p>This rule leads to off-by-one errors due to “fencepost” errors. The
fencepost problem is this: say you want to build a fence that is 100 feet
long with posts spaced every 10 feet. How many fenceposts do you need?</p>
<p>The naive answer is 10, but the correct answer is 11. The reason is the
fenceposts go in between the 10 feet divisions, including at the end points.
So there is an “extra” fencepost compared to the number of fence sections.</p>
<figure class="align-default" id="id17">
<img alt="_images/jeff-burak-lPO0VzF_4s8-unsplash.jpg" src="_images/jeff-burak-lPO0VzF_4s8-unsplash.jpg" />
<figcaption>
<p><span class="caption-text">A section of a fence that has 6 segments and 7 fenceposts.<a class="footnote-reference brackets" href="#fencepost-jeff-burbak-footnote" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id17" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Fencepost problems are a leading cause of off-by-one errors. Thinking about
slices in this way is to think about lists as separated by fenceposts, and
is only begging for problems. This will especially be the case if you still
find yourself otherwise thinking about indices as pointing to list elements
themselves, rather than the divisions between them. And given the behavior
of negative slices and integer indices under this model, one can hardly
blame you for doing so (see the previous two bullet points).</p>
</li>
</ul>
<p>Rather than trying to think about dividers between elements, it’s much simpler
to just think about the elements themselves, but being counted starting at 0.
To be sure, 0-based indexing itself leads to off-by-one errors, since it is
not the usually way humans are taught to count things, but this is nonetheless
the best way to think about things, especially as you gain practice in
counting that way. As long as you apply the rule “the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is not included,”
you will get the correct results.</p>
<p id="wrong-rule-4"><strong style="font-size:120%;">Wrong Rule 4: “The <code class="docutils literal notranslate"><span class="pre">stop</span></code> of a slice <code class="docutils literal notranslate"><span class="pre">a[start:stop]</span></code> is 1-based.”<a class="headerlink"
href="#wrong-rule-4" title="Permalink to this headline">¶</a> </strong></p>
<p>You might get clever and say <code class="docutils literal notranslate"><span class="pre">a[3:5]</span></code> indexes from the 3rd element with
0-based indexing to the 5th element with 1-based indexing. Don’t do this. It
is confusing. Not only that, but the rule must necessarily be reversed for
negative indices. <code class="docutils literal notranslate"><span class="pre">a[-5:-3]</span></code> indexes from the (−5)th element with −1-based
indexing to the (−3)rd element with 0-based indexing (and of course, negative
and nonnegative starts and stops can be mixed, like <code class="docutils literal notranslate"><span class="pre">a[3:-3]</span></code>). Don’t get cute
here. It isn’t worth it.</p>
</section>
</section>
<section id="negative-indices">
<span id="id9"></span><h3>Negative Indices<a class="headerlink" href="#negative-indices" title="Permalink to this heading">#</a></h3>
<p>Negative indices in slices work the same way they do with <a class="reference internal" href="#integer-indices"><span class="std std-ref">integer
indices</span></a>.</p>
<blockquote>
<div><p><strong>For <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code>, negative <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> use −1-based indexing
from the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</strong></p>
</div></blockquote>
<p>However, negative <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> does <em>not</em> change the order of the
slicing—only the <a class="reference internal" href="#steps"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">step</span></code></span></a> does that. The other <a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a> of
slicing do not change when the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> is negative. <a class="reference internal" href="#half-open"><span class="std std-ref">The <code class="docutils literal notranslate"><span class="pre">stop</span></code> is
still not included</span></a>, values less than <code class="docutils literal notranslate"><span class="pre">-len(a)</span></code> still
<a class="reference internal" href="#clipping"><span class="std std-ref">clip</span></a>, and so on.</p>
<p>Note that positive and negative indices can be mixed. The following slices of
<code class="docutils literal notranslate"><span class="pre">a</span></code> all produce <code class="docutils literal notranslate"><span class="pre">['d',</span> <span class="pre">'e']</span></code>:</p>
<div style="text-align:center">
<div style="font-size: 16pt;"><code>a[3:5] == a[-4:-2] == a[3:-2] == a[-4:5]
== ['d', 'e']</code></div>
$$
\begin{aligned}
\begin{array}{r c c c c c c c}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{nonnegative index}}
    & \color{#EE0000}{0\phantom{,}}
    & \color{#EE0000}{1\phantom{,}}
    & \color{#EE0000}{\enclose{circle}{2}\phantom{,}}
    & \color{#5E5EFF}{3\phantom{,}}
    & \color{#5E5EFF}{4\phantom{,}}
    & \color{#EE0000}{\enclose{circle}{5}\phantom{,}}
    & \color{#EE0000}{6\phantom{,}}\\
\color{#EE0000}{\text{negative index}}
    & \color{#EE0000}{-7\phantom{,}}
    & \color{#EE0000}{-6\phantom{,}}
    & \color{#EE0000}{\enclose{circle}{-5}\phantom{,}}
    & \color{#5E5EFF}{-4\phantom{,}}
    & \color{#5E5EFF}{-3\phantom{,}}
    & \color{#EE0000}{\enclose{circle}{-2}\phantom{,}}
    & \color{#EE0000}{-1\phantom{,}}\\
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>If a negative <code class="docutils literal notranslate"><span class="pre">stop</span></code> indexes an element on or before a nonnegative <code class="docutils literal notranslate"><span class="pre">start</span></code>, the
slice is empty, the same as if <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">&lt;=</span> <span class="pre">start</span></code> when both are nonnegative.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Similar to integer indices, negative indices <code class="docutils literal notranslate"><span class="pre">-i</span></code> in slices can always be
replaced by adding <code class="docutils literal notranslate"><span class="pre">len(a)</span></code> to <code class="docutils literal notranslate"><span class="pre">-i</span></code> until it is in the range <span class="math notranslate nohighlight">\([0,
\operatorname{len}(a))\)</span> (replacing <code class="docutils literal notranslate"><span class="pre">len(a)</span></code> with the size of the given axis
for NumPy arrays), so they are primarily a syntactic convenience.</p>
<p>The negative indexing behavior is convenient, but it can also lead to subtle
bugs, due to the fundamental discontinuity it produces. This is especially
likely to happen if the slice entries are arithmetical expressions. <strong>One
should always double check if the <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> values of a slice can be
negative, and if they can, if those values produce the correct results.</strong></p>
<p id="negative-indices-example">For example, say you wanted to slice <code class="docutils literal notranslate"><span class="pre">n</span></code> values from the middle of <code class="docutils literal notranslate"><span class="pre">a</span></code>.
Something like the following would work</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>From our <a class="reference internal" href="#sanity-check"><span class="std std-ref">sanity check</span></a>, <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">+</span> <span class="pre">n//2</span> <span class="pre">-</span> <span class="pre">(mid</span> <span class="pre">-</span> <span class="pre">n//2)</span></code> does
equal <code class="docutils literal notranslate"><span class="pre">n</span></code> if <code class="docutils literal notranslate"><span class="pre">n</span></code> is even (we could find a similar expression for <code class="docutils literal notranslate"><span class="pre">n</span></code> odd, but
for now let us assume <code class="docutils literal notranslate"><span class="pre">n</span></code> is even).</p>
<p>However, let’s look at what happens when <code class="docutils literal notranslate"><span class="pre">n</span></code> is larger than the size of <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;g&#39;]</span>
</pre></div>
</div>
<p>This is mostly likely not what we would want. Depending on our use-case, we
would most likely want either an error or the full list <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c',</span> <span class="pre">'d',</span> <span class="pre">'e',</span> <span class="pre">'f',</span> <span class="pre">'g']</span></code>.</p>
<p>What happened here? Let’s look at the slice values:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>
<span class="go">7</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">stop</span></code> slice value is out of bounds for <code class="docutils literal notranslate"><span class="pre">a</span></code>, but this just causes it
to <a class="reference internal" href="#clipping"><span class="std std-ref">clip</span></a> to the end.</p>
<p>But <code class="docutils literal notranslate"><span class="pre">start</span></code> contains a subtraction, which causes it to become negative. Rather
than clipping to the start, it indexes from the end of <code class="docutils literal notranslate"><span class="pre">a</span></code>, producing the
slice <code class="docutils literal notranslate"><span class="pre">a[-1:7]</span></code>. This picks the elements from the last element (<code class="docutils literal notranslate"><span class="pre">'g'</span></code>) up to
but not including the 7th element (0-based). Index <code class="docutils literal notranslate"><span class="pre">7</span></code> is out of bounds for
<code class="docutils literal notranslate"><span class="pre">a</span></code>, so this picks all elements including and after <code class="docutils literal notranslate"><span class="pre">'g'</span></code>, which in this case
is just <code class="docutils literal notranslate"><span class="pre">['g']</span></code>.</p>
<p>Unfortunately, the “correct” fix here depends on the desired behavior for each
individual slice. In some cases, the “slice from the end” behavior of negative
values is in fact what is desired. In others, you might prefer an error, so
should add a value check or assertion. In others, you might want clipping, in
which case you could modify the expression to always be nonnegative. For
example, instead of using <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">-</span> <span class="pre">n//2</span></code>, we could use <code class="docutils literal notranslate"><span class="pre">max(mid</span> <span class="pre">-</span> <span class="pre">n//2,</span> <span class="pre">0)</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
</section>
<section id="clipping">
<span id="id10"></span><h3>Clipping<a class="headerlink" href="#clipping" title="Permalink to this heading">#</a></h3>
<p>Slices can never give an out-of-bounds <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>. This is different from
<a class="reference internal" href="#integer-indices"><span class="std std-ref">integer indices</span></a> which require the index to be in bounds.</p>
<blockquote>
<div><p><strong>If <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> index before the beginning or after the end of the
<code class="docutils literal notranslate"><span class="pre">a</span></code>, they will clip to the bounds of <code class="docutils literal notranslate"><span class="pre">a</span></code></strong>:</p>
</div></blockquote>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>Furthermore, if the <code class="docutils literal notranslate"><span class="pre">start</span></code> is on or after the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, the slice will be
empty.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>For NumPy arrays, a consequence of this is that a slice will always keep the
axis being sliced, even if the size of the resulting axis is 0 or 1.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Integer index removes the first dimension</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Slice preserves the first dimension</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Slice preserves the first dimension as an empty dimension</span>
<span class="go">(0, 2)</span>
</pre></div>
</div>
<p>An important consequence of the clipping behavior of slices is that you cannot
rely on runtime checks for out-of-bounds slices. See the <a class="reference internal" href="#negative-indices-example"><span class="std std-ref">example
above</span></a>. Another consequence is that you can never
rely on the length of a slice being <code class="docutils literal notranslate"><span class="pre">stop</span> <span class="pre">-</span> <span class="pre">start</span></code> (for <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">=</span> <span class="pre">1</span></code> and
<code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code> nonnegative). This is rather the <em>maximum</em> length of the
slice. It could end up slicing something smaller. For example, an empty list
will always slice to an empty list. ndindex can help in calculations here:
<code class="docutils literal notranslate"><span class="pre">len(ndindex.Slice(...))</span></code> can be used to compute the <em>maximum</em> length of a
slice. If the shape of the input is known,
<code class="docutils literal notranslate"><span class="pre">len(ndindex.Slice(...).reduce(shape))</span></code> will compute the true length of the
slice (see <a class="reference internal" href="api.html#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndindex.Slice.__len__()</span></code></a> and <a class="reference internal" href="api.html#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndindex.Slice.reduce()</span></code></a>). Of
course, if you already have a NumPy array, you can just slice the array and
check the shape (slicing a NumPy array always produces a view on the array, so
it is a very inexpensive operation).</p>
</section>
<section id="steps">
<span id="id11"></span><h3>Steps<a class="headerlink" href="#steps" title="Permalink to this heading">#</a></h3>
<p>Thus far, we have only considered slices with the default step size of 1. When
the step is greater than 1, the slice picks every <code class="docutils literal notranslate"><span class="pre">step</span></code> element contained in
the bounds of <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>.</p>
<blockquote>
<div><p><strong>The proper way to think about <code class="docutils literal notranslate"><span class="pre">step</span></code> is that the slice starts at <code class="docutils literal notranslate"><span class="pre">start</span></code>
and successively adds <code class="docutils literal notranslate"><span class="pre">step</span></code> until it reaches an index that is at or past
the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and then stops without including that index.</strong></p>
</div></blockquote>
<p>The important thing to remember about the <code class="docutils literal notranslate"><span class="pre">step</span></code> is that it being non-1 does
not change the fundamental <a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a> of slices that we have learned so
far. <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> still use <a class="reference internal" href="#based"><span class="std std-ref">0-based indexing</span></a>. The <code class="docutils literal notranslate"><span class="pre">stop</span></code> is
<a class="reference internal" href="#half-open"><span class="std std-ref">never included</span></a> in the slice. <a class="reference internal" href="#negative-indices"><span class="std std-ref">Negative</span></a> <code class="docutils literal notranslate"><span class="pre">start</span></code>
and <code class="docutils literal notranslate"><span class="pre">stop</span></code> index from the end of the list. Out-of-bounds <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>
still <a class="reference internal" href="#clipping"><span class="std std-ref">clip</span></a> to the beginning or end of the list.</p>
<p>Let us consider an example where the step size is <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[0:6:3] == ['a', 'd']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#5E5EFF}{\enclose{circle}{0}}
    & \color{#EE0000}{1\phantom{,}}
    & \color{#EE0000}{2\phantom{,}}
    & \color{#5E5EFF}{\enclose{circle}{3}}
    & \color{#EE0000}{4\phantom{,}}
    & \color{#EE0000}{5\phantom{,}}
    & \color{#EE0000}{\enclose{circle}{6}}\\
    & \color{#5E5EFF}{\text{start}}
    &
    & \rightarrow
    & \color{#5E5EFF}{+3}
    &
    & \rightarrow
    & \color{#EE0000}{+3\ (\geq \text{stop})}
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">start</span></code> index, <code class="docutils literal notranslate"><span class="pre">0</span></code>, is included, but the <code class="docutils literal notranslate"><span class="pre">stop</span></code> index, <code class="docutils literal notranslate"><span class="pre">6</span></code>
(corresponding to <code class="docutils literal notranslate"><span class="pre">'g'</span></code>), is <em>not</em> included, even though it is a multiple of
<code class="docutils literal notranslate"><span class="pre">3</span></code> away from the start. This is because the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is <a class="reference internal" href="#half-open"><span class="std std-ref">never
included</span></a>.</p>
<p>It can be tempting to think about the <code class="docutils literal notranslate"><span class="pre">step</span></code> in terms of modular arithmetic.
In fact, it is often the case in practice that you require a <code class="docutils literal notranslate"><span class="pre">step</span></code> greater
than 1 because you are dealing with modular arithmetic in some way. However,
this requires care.</p>
<p>Indeed, we can note that resulting indices <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code> of the above slice
<code class="docutils literal notranslate"><span class="pre">a[0:6:3]</span></code> are all multiples of 3. This is because the <code class="docutils literal notranslate"><span class="pre">start</span></code> index, <code class="docutils literal notranslate"><span class="pre">0</span></code>, is
a multiple of 3. If we instead choose a start index that is <span class="math notranslate nohighlight">\(1 \pmod{3}\)</span> then
all the indices would also be <span class="math notranslate nohighlight">\(1 \pmod{3}\)</span>.</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[1:6:3] == ['b', 'e']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r c c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    & \color{#5E5EFF}{\enclose{circle}{1}}
    & \color{#EE0000}{2\phantom{,}}
    & \color{#EE0000}{3\phantom{,}}
    & \color{#5E5EFF}{\enclose{circle}{4}}
    & \color{#EE0000}{5\phantom{,}}
    & \color{#EE0000}{\underline{6}\phantom{,}}
    & \color{#EE0000}{\enclose{circle}{\phantom{7}}}\\
    &
    & \color{#5E5EFF}{\text{start}}
    &
    & \rightarrow
    & \color{#5E5EFF}{+3}
    &
    & \rightarrow
    & \color{#EE0000}{+3\ (\geq \text{stop})}
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;b&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>However, be careful as this rule is <em>only</em> true for nonnegative <code class="docutils literal notranslate"><span class="pre">start</span></code>. If
<code class="docutils literal notranslate"><span class="pre">start</span></code> is negative, the value of <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">(mod</span> <span class="pre">step)</span></code> has no
bearing on the indices chosen for the slice:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">21</span><span class="p">))[</span><span class="o">-</span><span class="mi">15</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[6, 9, 12, 15, 18]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">22</span><span class="p">))[</span><span class="o">-</span><span class="mi">15</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[7, 10, 13, 16, 19]</span>
</pre></div>
</div>
<p>In the first case, <code class="docutils literal notranslate"><span class="pre">-15</span></code> is divisible by 3 and all the indices chosen by the
slice <code class="docutils literal notranslate"><span class="pre">-15::3</span></code> were also divisible by 3 (remember that indices and values
are the same for simple ranges). But this is only because the length of the
list, <code class="docutils literal notranslate"><span class="pre">21</span></code>, also happened to be a multiple of 3. In the second example it is
<code class="docutils literal notranslate"><span class="pre">22</span></code> and the resulting indices are not multiples of <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
<p>Another thing to be aware of is that if the start is <a class="reference internal" href="#clipping"><span class="std std-ref">clipped</span></a>, the
clipping occurs <em>before</em> the step. That is, if the <code class="docutils literal notranslate"><span class="pre">start</span></code> is less than
<code class="docutils literal notranslate"><span class="pre">len(a)</span></code>, it is the same as <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">0</span></code> regardless of the <code class="docutils literal notranslate"><span class="pre">step</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">101</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p>If you need to think about steps in terms of modular arithmetic,
<a class="reference internal" href="api.html#slice-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">ndindex.Slice()</span></code></span></a> can be used to perform various slice
calculations so that you don’t have to come up with modulo formulas yourself.
If you try to write such formulas yourself, chances are you will get them
wrong, as it is easy to fail to properly account for <a class="reference internal" href="#negative-indices"><span class="std std-ref">negative vs. nonnegative
indices</span></a>, <a class="reference internal" href="#clipping"><span class="std std-ref">clipping</span></a>, and <a class="reference internal" href="#negative-steps"><span class="std std-ref">negative
steps</span></a>. As noted before, any correct “formula” regarding
slices will necessarily have many piecewise conditions.</p>
</section>
<section id="negative-steps">
<span id="id12"></span><h3>Negative Steps<a class="headerlink" href="#negative-steps" title="Permalink to this heading">#</a></h3>
<p>Recall what we said <a class="reference internal" href="#steps"><span class="std std-ref">above</span></a>:</p>
<blockquote>
<div><p><strong>The proper way to think about <code class="docutils literal notranslate"><span class="pre">step</span></code> is that the slice starts at <code class="docutils literal notranslate"><span class="pre">start</span></code>
and successively adds <code class="docutils literal notranslate"><span class="pre">step</span></code> until it reaches an index that is at or past
the <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and then stops without including that index.</strong></p>
</div></blockquote>
<p>The key thing to remember with negative <code class="docutils literal notranslate"><span class="pre">step</span></code> is that this rule still
applies. That is, the index starts at <code class="docutils literal notranslate"><span class="pre">start</span></code> then adds the <code class="docutils literal notranslate"><span class="pre">step</span></code> (which
makes the index smaller), and stops when it is at or past the <code class="docutils literal notranslate"><span class="pre">stop</span></code>. Note the
phrase “at or past”. If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive this means “greater than or
equal to”, but if the <code class="docutils literal notranslate"><span class="pre">step</span></code> is negative this means “less than or equal to”.</p>
<p>Think of a slice as starting at the <code class="docutils literal notranslate"><span class="pre">start</span></code> and sliding along the list,
jumping along by <code class="docutils literal notranslate"><span class="pre">step</span></code>, and spitting out elements. Once you see that you are
at or have gone past the <code class="docutils literal notranslate"><span class="pre">stop</span></code> in the direction you are going (left for
negative <code class="docutils literal notranslate"><span class="pre">step</span></code> and right for positive <code class="docutils literal notranslate"><span class="pre">step</span></code>), you stop.</p>
<p>It’s worth pointing out that unlike all other slices we have seen so far, a
negative <code class="docutils literal notranslate"><span class="pre">step</span></code> reverses the order that the elements are returned relative to
the original list. In fact, one of the most common uses of a negative <code class="docutils literal notranslate"><span class="pre">step</span></code> is
<code class="docutils literal notranslate"><span class="pre">a[::-1]</span></code>, which reverses the list:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
</pre></div>
</div>
<p>It is tempting therefore to think of a negative <code class="docutils literal notranslate"><span class="pre">step</span></code> as a “reversing”
operation. However, this is a bad way of thinking about negative steps. The
reason is that <code class="docutils literal notranslate"><span class="pre">a[i:j:-1]</span></code> is <em>not</em> equivalent to <code class="docutils literal notranslate"><span class="pre">reversed(a[j:i:1])</span></code>. The
reason is basically the same as was described in <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">wrong rule 1</span></a>
above. The issue is that for <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code> is <em>always</em> what is
<a class="reference internal" href="#half-open"><span class="std std-ref">not included</span></a>. Which means if we swap <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>, we go from “<code class="docutils literal notranslate"><span class="pre">j</span></code>
is not included” to “<code class="docutils literal notranslate"><span class="pre">i</span></code> is not included”, producing a wrong result. For
example, as <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">before</span></a>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[&#39;f&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># This is not the same thing</span>
<span class="go">[&#39;e&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<p>In the first case, index <code class="docutils literal notranslate"><span class="pre">3</span></code> is not included. In the second case, index <code class="docutils literal notranslate"><span class="pre">5</span></code> is
not included.</p>
<p>Worse, this way of thinking may even lead one to imagine the completely wrong
idea that <code class="docutils literal notranslate"><span class="pre">a[i:j:-1]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">reversed(a)[j:i]</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">))[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<p>Once <code class="docutils literal notranslate"><span class="pre">a</span></code> is reversed, the indices <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code> have nothing to do with the
original indices <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code>. To see why, consider a much larger list:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))[</span><span class="mi">5</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[5, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)))[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[96, 95]</span>
</pre></div>
</div>
<p>It is much more robust to think about the slice as starting at <code class="docutils literal notranslate"><span class="pre">start</span></code>, then
moving across the list by <code class="docutils literal notranslate"><span class="pre">step</span></code> until reaching <code class="docutils literal notranslate"><span class="pre">stop</span></code>, which is not included.</p>
<p>Negative steps can of course be less than -1 as well, with similar behavior to
steps greater than 1, again, keeping in mind that the <code class="docutils literal notranslate"><span class="pre">stop</span></code> is not included.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;g&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<div style="text-align:center">
<code style="font-size: 16pt;">a[6:0:-3] == ['g', 'd']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, & \mathtt{\textsf{'}b\textsf{'}}, & \mathtt{\textsf{'}c\textsf{'}}, & \mathtt{\textsf{'}d\textsf{'}}, & \mathtt{\textsf{'}e\textsf{'}}, & \mathtt{\textsf{'}f\textsf{'}}, & \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{\enclose{circle}{0}\phantom{,}}
    & \color{#EE0000}{1\phantom{,}}
    & \color{#EE0000}{2\phantom{,}}
    & \color{#5E5EFF}{\enclose{circle}{3}}
    & \color{#EE0000}{4\phantom{,}}
    & \color{#EE0000}{5\phantom{,}}
    & \color{#5E5EFF}{\enclose{circle}{6}}\\
    & \color{#EE0000}{-3}\phantom{\mathtt{\textsf{'},}}
    & \leftarrow
    &
    & \color{#5E5EFF}{-3}\phantom{\mathtt{\textsf{'},}}
    & \leftarrow
    &
    & \color{#5E5EFF}{\text{start}}\\
    &  \color{#EE0000}{(\leq \text{stop})}
\end{array}
\end{aligned}
$$
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">step</span></code> can never be equal to 0. This unconditionally produces an error:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">slice step cannot be zero</span>
</pre></div>
</div>
</section>
<section id="omitted-entries">
<span id="omitted"></span><h3>Omitted Entries<a class="headerlink" href="#omitted-entries" title="Permalink to this heading">#</a></h3>
<p>The final point of confusion is omitted entries.<a class="footnote-reference brackets" href="#omitted-none-footnote" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
<p><strong>The best way to think about omitted entries is just like that, as omitted
entries.</strong> That is, for a slice like <code class="docutils literal notranslate"><span class="pre">a[:i]</span></code>, think of it as the <code class="docutils literal notranslate"><span class="pre">start</span></code> being
omitted, and <code class="docutils literal notranslate"><span class="pre">stop</span></code> equal to <code class="docutils literal notranslate"><span class="pre">i</span></code>. Conversely, <code class="docutils literal notranslate"><span class="pre">a[i:]</span></code> has the <code class="docutils literal notranslate"><span class="pre">start</span></code> as <code class="docutils literal notranslate"><span class="pre">i</span></code>
and the <code class="docutils literal notranslate"><span class="pre">stop</span></code> omitted. The wrong way to think about these is as a colon being
before or after the index <code class="docutils literal notranslate"><span class="pre">i</span></code>. Thinking about it this way will only lead to
confusion, because you won’t be thinking about <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>, but rather
trying to remember some rule based on where a colon is. But the colons in a
slice are not indicators, they are separators.</p>
<p>As to the semantic meaning of omitted entries, the easiest one is the <code class="docutils literal notranslate"><span class="pre">step</span></code>.</p>
<blockquote>
<div><p><strong>If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is omitted, it always defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</strong></p>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">step</span></code> is omitted the second colon before the <code class="docutils literal notranslate"><span class="pre">step</span></code> can also be
omitted. That is to say, the following are completely equivalent:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">:]</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<!-- TODO: Better wording for this rule? -->
<blockquote>
<div><p><strong>For the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code>, the rule is that being omitted extends the
slice all the way to the beginning or end of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the direction being
sliced.</strong></p>
</div></blockquote>
<p>If
the <code class="docutils literal notranslate"><span class="pre">step</span></code> is positive, this means <code class="docutils literal notranslate"><span class="pre">start</span></code> extends to the beginning of <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">stop</span></code> extends to the end. If <code class="docutils literal notranslate"><span class="pre">step</span></code> is negative, it is reversed: <code class="docutils literal notranslate"><span class="pre">start</span></code>
extends to the end of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> extends to the beginning.</p>
<div style="text-align:center">
<code style="font-size: 16pt;">a[:3] == a[:3:1] == ['a', 'b', 'c']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r c c c c c c c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, && \mathtt{\textsf{'}b\textsf{'}}, && \mathtt{\textsf{'}c\textsf{'}}, && \mathtt{\textsf{'}d\textsf{'}}, && \mathtt{\textsf{'}e\textsf{'}}, && \mathtt{\textsf{'}f\textsf{'}}, && \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#5E5EFF}{\enclose{circle}{0}}
    &
    & \color{#5E5EFF}{\enclose{circle}{1}}
    &
    & \color{#5E5EFF}{\enclose{circle}{2}}
    &
    & \color{#EE0000}{\enclose{circle}{3}}
    &
    & \color{#EE0000}{4\phantom{,}}
    &
    & \color{#EE0000}{5\phantom{,}}
    &
    & \color{#EE0000}{6\phantom{,}}\\
    \color{#5E5EFF}{\text{start}}
    & \color{#5E5EFF}{\text{(beginning)}}
    & \rightarrow
    & \color{#5E5EFF}{+1}
    & \rightarrow
    & \color{#5E5EFF}{+1}
    & \rightarrow
    & \color{#EE0000}{\text{stop}}
    &
    & \phantom{\rightarrow}
    &
    & \phantom{\rightarrow}
    &
    & \phantom{\rightarrow}
\end{array}
\end{aligned}
$$
</div>
<div style="text-align:center">
<code style="font-size: 16pt;">a[3:] == a[3::1] == ['d', 'e', 'f', 'g']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r c c c c c c c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, && \mathtt{\textsf{'}b\textsf{'}}, && \mathtt{\textsf{'}c\textsf{'}}, && \mathtt{\textsf{'}d\textsf{'}}, && \mathtt{\textsf{'}e\textsf{'}}, && \mathtt{\textsf{'}f\textsf{'}}, && \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    &
    & \color{#EE0000}{1\phantom{,}}
    &
    & \color{#EE0000}{2\phantom{,}}
    &
    & \color{#5E5EFF}{\enclose{circle}{3}}
    &
    & \color{#5E5EFF}{\enclose{circle}{4}}
    &
    & \color{#5E5EFF}{\enclose{circle}{5}}
    &
    & \color{#5E5EFF}{\enclose{circle}{6}\phantom{,}}\\
    &
    & \phantom{\rightarrow}
    &
    & \phantom{\rightarrow}
    &
    & \phantom{\rightarrow}
    & \color{#5E5EFF}{\text{start}}
    & \rightarrow
    & \color{#5E5EFF}{+1}
    & \rightarrow
    & \color{#5E5EFF}{+1}
    & \rightarrow
    & \color{#5E5EFF}{\text{stop}}
    & \color{#5E5EFF}{\text{(end)}}
\end{array}
\end{aligned}
$$
</div>
<div style="text-align:center">
<code style="font-size: 16pt;">a[:3:-1] == ['g', 'f', 'e']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r c c c c c c c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, && \mathtt{\textsf{'}b\textsf{'}}, && \mathtt{\textsf{'}c\textsf{'}}, && \mathtt{\textsf{'}d\textsf{'}}, && \mathtt{\textsf{'}e\textsf{'}}, && \mathtt{\textsf{'}f\textsf{'}}, && \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#EE0000}{0\phantom{,}}
    &
    & \color{#EE0000}{1\phantom{,}}
    &
    & \color{#EE0000}{2\phantom{,}}
    &
    & \color{#EE0000}{\enclose{circle}{3}}
    &
    & \color{#5E5EFF}{\enclose{circle}{4}}
    &
    & \color{#5E5EFF}{\enclose{circle}{5}}
    &
    & \color{#5E5EFF}{\enclose{circle}{6}\phantom{,}}\\
    &
    & \phantom{\leftarrow}
    &
    & \phantom{\leftarrow}
    &
    & \phantom{\leftarrow}
    & \color{#EE0000}{\text{stop}}
    & \leftarrow
    & \color{#5E5EFF}{-1}
    & \leftarrow
    & \color{#5E5EFF}{-1}
    & \leftarrow
    & \color{#5E5EFF}{\text{start}}
    & \color{#5E5EFF}{\text{(end)}}
\end{array}
\end{aligned}
$$
</div>
<div style="text-align:center">
<code style="font-size: 16pt;">a[3::-1] == ['d', 'c', 'b', 'a']</code>
$$
\require{enclose}
\begin{aligned}
\begin{array}{r r c c c c c c c c c c c c l}
a = & [\mathtt{\textsf{'}a\textsf{'}}, && \mathtt{\textsf{'}b\textsf{'}}, && \mathtt{\textsf{'}c\textsf{'}}, && \mathtt{\textsf{'}d\textsf{'}}, && \mathtt{\textsf{'}e\textsf{'}}, && \mathtt{\textsf{'}f\textsf{'}}, && \mathtt{\textsf{'}g\textsf{'}}]\\
\color{#EE0000}{\text{index}}
    & \color{#5E5EFF}{\enclose{circle}{0}}
    &
    & \color{#5E5EFF}{\enclose{circle}{1}}
    &
    & \color{#5E5EFF}{\enclose{circle}{2}}
    &
    & \color{#5E5EFF}{\enclose{circle}{3}}
    &
    & \color{#EE0000}{4\phantom{,}}
    &
    & \color{#EE0000}{5\phantom{,}}
    &
    & \color{#EE0000}{6\phantom{,}}\\
    \color{#5E5EFF}{\text{stop}}
    & \color{#5E5EFF}{\text{(beginning)}}
    & \leftarrow
    & \color{#5E5EFF}{-1}
    & \leftarrow
    & \color{#5E5EFF}{-1}
    & \leftarrow
    & \color{#5E5EFF}{\text{start}}
    &
    & \phantom{\leftarrow}
    &
    & \phantom{\leftarrow}
    &
    & \phantom{\leftarrow}
\end{array}
\end{aligned}
$$
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># From the beginning to index 3 (but not including index 3)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="c1"># From index 3 to the end</span>
<span class="go">[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># From the end to index 3 (but not including index 3), reversed</span>
<span class="go">[&#39;g&#39;, &#39;f&#39;, &#39;e&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># From index 3 to the beginning, reversed</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
</pre></div>
</div>
</section>
</section>
<section id="soapbox">
<h2>Soapbox<a class="headerlink" href="#soapbox" title="Permalink to this heading">#</a></h2>
<p>While this guide is opinionated about the right and wrong ways to think about
slices in Python, I have tried to stay neutral regarding the merits of the
rules themselves. But I want to take a moment to give my views on them. I have
worked with slice objects quite a bit in building ndindex, as well as just
general usage with Python and NumPy.</p>
<p>Python’s slice syntax is, without a doubt, extremely expressive, and has a
straightforward and simple syntax. However, simply put, the semantic rules for
slices are completely bonkers. They lend themselves to several invalid
interpretations, which I have outlined above, which seem valid at first glance
but fall apart in corner cases. The “correct” ways to think about slices are
very particular. I have tried to <a class="reference internal" href="#rules"><span class="std std-ref">outline</span></a> them carefully, but one gets
the impression that unless one works with slices regularly, it will be hard to
remember the “right” ways and not fallback to thinking about the “wrong” ways,
or, as most Python programmers probably do, simply “guessing and checking”.</p>
<p>Furthermore, the discontinuous nature of the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> parameters not
only makes it hard to remember how slices work, but it makes it <em>extremely</em>
hard to write slice arithmetic. The arithmetic is already hard enough due to
the modular nature of <code class="docutils literal notranslate"><span class="pre">step</span></code>, but the discontinuous aspect of <code class="docutils literal notranslate"><span class="pre">start</span></code> and
<code class="docutils literal notranslate"><span class="pre">stop</span></code> increases this tenfold. If you are unconvinced of this, take a look at
the <a class="reference external" href="https://github.com/Quansight-labs/ndindex/blob/master/ndindex/slice.py">source
code</a> for
<code class="docutils literal notranslate"><span class="pre">ndindex.Slice()</span></code>. You will see lots of nested <code class="docutils literal notranslate"><span class="pre">if</span></code> blocks.<a class="footnote-reference brackets" href="#source-footnote" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>
This is because slices have <em>fundamentally</em> different definitions if the
<code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, negative, or nonnegative. Furthermore, <code class="docutils literal notranslate"><span class="pre">None</span></code> is
not an integer, so one must always be careful to either check for it first or
to be certain that it cannot happen, before performing any arithmetical
operation or numerical comparison. Under each <code class="docutils literal notranslate"><span class="pre">if</span></code> block you will see some
formula or other. Many of these formulas were difficult to come up with. In
many cases they are asymmetrical in surprising ways. It is only through the
rigorous <a class="reference internal" href="index.html#testing"><span class="std std-ref">testing</span></a> that ndindex uses that I can have confidence the
formulas are correct for all corner cases.</p>
<p>It is my opinion that Python’s slicing semantics could be just as expressive,
but much less confusing and difficult to work with, both for end-users of
slices and people writing slice arithmetic (a typical user of ndindex). The
changes I would make to improve the semantics would be</p>
<ol class="arabic simple">
<li><p>Remove the special meaning of negative numbers.</p></li>
<li><p>Use 1-based indexing instead of 0-based indexing.</p></li>
<li><p>Make a slice always include both the start and the stop.</p></li>
</ol>
<p><strong>Negative numbers.</strong> The special meaning of negative numbers, to index from
the end of the list, is by far the biggest problem with Python’s slice
semantics. It is a fundamental discontinuity in the definition of an index.
This makes it completely impossible to write a formula for almost anything
relating to slices that will not end up having branching <code class="docutils literal notranslate"><span class="pre">if</span></code> conditions. But
the problem isn’t just for code that manipulates slices. The <a class="reference internal" href="#negative-indices-example"><span class="std std-ref">example
above</span></a> shows how negative indices can easily lead to
bugs in end-user code. Effectively, any time you have a slice <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code>, if <code class="docutils literal notranslate"><span class="pre">i</span></code>
and <code class="docutils literal notranslate"><span class="pre">j</span></code> are nontrivial expressions, they must be checked to ensure they do not
go negative. If they can be both negative and nonnegative, it is virtually
never the case that the slice will give you what you want in both cases. This
is because the discontinuity inherent in the definition of <a class="reference internal" href="#negative-indices"><span class="std std-ref">negative
indexing</span></a> disagrees with the concept of
<a class="reference internal" href="#clipping"><span class="std std-ref">clipping</span></a>. <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> will slice “as far as it can” if <code class="docutils literal notranslate"><span class="pre">j</span></code> is “too
big” (greater than <code class="docutils literal notranslate"><span class="pre">len(a)</span></code>), but it does something completely different if
<code class="docutils literal notranslate"><span class="pre">i</span></code> is “too small” as soon as “too small” means “negative”. Clipping is a good
idea. It tends to lead to behavior that gives what you would want slices that
go out of bounds.</p>
<p>Negative indexing is, strictly speaking, a syntactic sugar only.
Slicing/indexing from the end of a list can always be done in terms of the
length of the list. <code class="docutils literal notranslate"><span class="pre">a[-x]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">a[len(a)-x]</span></code> (when using 0-based
indexing), but the problem is that it is tedious to write <code class="docutils literal notranslate"><span class="pre">a</span></code> twice, and <code class="docutils literal notranslate"><span class="pre">a</span></code>
may in fact be a larger expression, so writing <code class="docutils literal notranslate"><span class="pre">a[len(a)-x]</span></code> would require
assigning it to a variable. It also becomes more complicated when <code class="docutils literal notranslate"><span class="pre">a</span></code> is a
NumPy array and the slice appears as part of a larger multidimensional (tuple)
index. However, I think it would be possible to introduce a special syntax to
mean “reversed” or “from the end the list” indexing, and leave negative
numbers to simply extend beyond the left side of a list with clipping. For
example, in <a class="reference external" href="https://julialang.org/">Julia</a>, one can use <code class="docutils literal notranslate"><span class="pre">a[end]</span></code> to index the
last element of an array (Julia also uses 1-based indexing). Since this is a
moot point for Python—I don’t expect Python’s indexing semantics to change;
they are already baked into the language—I won’t suggest any syntax. Perhaps
this can inspire people writing new languages or DSLs to come up with better
semantics backed by good syntax (again, I think Python slicing has good
<em>syntax</em>. I only take issue with some of its <em>semantics</em>.).</p>
<p><strong>0-based vs. 1-based indexing.</strong> The second point, on using 1-based indexing
instead of 0-based indexing, will likely be the most controversial. For many
people reading this, the notion that 0-based indexing is superior has been
preached as irreproachable gospel. I encourage you to open your mind and try
to unlearn what you have been taught and take a fresh view of the matter (or
don’t. These are just my opinions after all, and none of it changes the fact
that Python is what it is and isn’t going to change).</p>
<p>0-based indexing certainly has its uses. In C, where an index is literally a
syntactic macro for adding two pointers, 0-based indexing makes sense, since
<code class="docutils literal notranslate"><span class="pre">a[i]</span></code> literally means <code class="docutils literal notranslate"><span class="pre">*(a</span> <span class="pre">+</span> <span class="pre">i)</span></code> under those semantics. However, for higher
level languages such as Python, people think of indexing as pointing to
specific numbered elements of a collection, not as pointer arithmetic. Every
human being is taught from an early age to count from 1. If you show someone
the list “a, b, c”, they will tell you that “a” is the 1st, “b” is the 2nd,
and “c” is the 3rd. <a class="reference internal" href="#fourth-sentence"><span class="std std-ref">Sentences</span></a> in the above guide like
“<code class="docutils literal notranslate"><span class="pre">a[3]</span></code> would pick the fourth element of <code class="docutils literal notranslate"><span class="pre">a</span></code>” sound very off, even for those
of us used to 0-based indexing. 0-based indexing requires a shift in thinking
from the way that you have been taught to count from early childhood. Counting
is a very fundamental thing for any human, but especially so for a programmer.
Forcing someone to learn a new way to do such a foundational thing is a huge
cognitive burden, and so it shouldn’t be done without a very good reason. In a
language like C, one can argue there is a good reason, just as one can argue
that it is beneficial to learn new base number systems like base-2 and base-16
when doing certain kinds of programming.</p>
<p>But for Python, what truly is the benefit of counting starting at 0? The main
benefit is that the implementation is easier, because Python is itself written
in C, which uses 0-based indexing, so Python does not need to handle shifting
in the translation. But this has never been a valid argument for Python
semantics. The whole point of Python is to provide higher level semantics than
C, and leave those hard details of translating them to the interpreter and
library code. In fact, Python’s slices themselves are much more complicated
than what is available in C, and the interpreter code to handle them is more
than just a trivial translation to C. Adding shifts to this translation code
would not be much additional complexity.</p>
<p>Even experienced programmers of languages like Python that use 0-based
indexing must occasionally stop themselves from writing something like <code class="docutils literal notranslate"><span class="pre">a[3]</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">a[2]</span></code> to get the third element of <code class="docutils literal notranslate"><span class="pre">a</span></code>. It is very difficult to
“unlearn” 1-based counting,” which was not only the first way that you learned
to count, but is also the way that you and everyone else around you continues
to count outside of programming contexts.</p>
<p>When you teach a child how to count things, you teach them to enumerate the
items starting at 1 (“1, 2, 3, …”). The number that is enumerated for the
final object is equal to the number of items (the final ordinal is equal to
the cardinal). This only works if you start at 1. If the child instead starts
at 0 (“0, 1, 2, …”) the final ordinal (the last number spoken aloud) would
not match the cardinal (the number of items). The distinction between ordinals
and cardinals is not something most people think about often, because the
convention of counting starting at 1 makes it so that they are equal. But as
programmers in a language that rejects this elegant convention, we are forced
to think about such philosophical distinctions just to solve whatever problem
we are trying to solve.</p>
<p>In most instances (outside of programming) where a reckoning starts at 0
instead of 1, it is because it is measuring a distance. The distance from your
house to the nearest pub may be “2 miles”, but the distance from your house to
itself is “0 miles”. On the other hand, when counting or enumerating
individual objects, counting always starts at 1. The notion of a “zeroth”
object doesn’t make sense when counting say apples, because you are counting
the apples themselves, not some quantity relating them. It doesn’t make sense
to start at 0 with an “un-apple” because you are only counting apples, not
non-apples.</p>
<p>So the question then becomes, should indexing work like a measurement of
distance, which would naturally start at 0, or like an enumeration of distinct
terms, which would naturally start at 0. If we think of an index as a pointer
offset, as C does, then it is indeed a measurement of a distance. But if we
instead think of an indexable list as a discrete ordered collection of items,
then the notion of a measurement of distance is harder to justify. But
enumeration is a natural concept for any ordered discrete collection.</p>
<p>What are the benefits of 0-based indexing?</p>
<ul class="simple">
<li><p>It makes translation to lower level code (like C or machine code) easier.
But as I already argued, this is not a valid argument for Python, which aims
to be high-level and abstract away translation complexities that make coding
more difficult. The translation that necessarily takes place in the
interpreter itself can afford this complexity if it means making the
language itself simpler.</p></li>
<li><p>It makes translation of code written in other languages that use 0-based
indexing simpler. If Python used 1-based indexing, then to translate a C
algorithm to Python, for instance, one would have to adapt all the places
that use indexing, which would be a bug-prone task. But Python’s primary
mantra is having syntax and semantics that make code easy to read and easy
to write. Being similar to other existing languages is second to this, and
should not take priority when it conflicts with it. Translation of code from
other languages to Python does happen, but it is much rarer than novel code
written in Python. Furthermore, automated tooling could be used to avoid
translation bugs. Such tooling would help avoid other translation bugs
unrelated to indexing as well.</p></li>
<li><p>It works nicely with half-open semantics. It is true that half-open
semantics and 0-based indexing, while technically distinct, are virtually
always implemented together because they play so nicely with each other.
However, as I argue below, half-open semantics are just as absurd as 0-based
indexing, and abandoning both for the more standard closed-closed/1-based
semantics is very reasonable.</p></li>
</ul>
<p>To me, the ideal indexing system defaults to 1-based, but allows starting at
any index. That way, if you are dealing with a use-case where 0-based indexing
really does make more sense, you can easily use it. Indices should also be
able to start at any other number, including negative numbers (which is
another reason to remove the special meaning of negative indices). An example
of a use-case where 0-based indexing truly is more natural than 1-based
indexing is polynomials. Say we have a polynomial <span class="math notranslate nohighlight">\(a_0 + a_1x + a_2x^2 +
\cdots\)</span>. Then we can represent the coefficients <span class="math notranslate nohighlight">\(a_0, a_1, a_2, \ldots\)</span> in a
list <code class="docutils literal notranslate"><span class="pre">[a0,</span> <span class="pre">a1,</span> <span class="pre">a2,</span> <span class="pre">...]</span></code>. Since a polynomial naturally has a 0th coefficient,
it makes sense to index the list starting at 0 (and one must still be careful
about off-by-one errors; a degree-<span class="math notranslate nohighlight">\(n\)</span> polynomial has <span class="math notranslate nohighlight">\(n+1\)</span> coefficients).</p>
<p>If this seems like absurd idea, note that this is how Fortran works (see
<a class="reference external" href="https://www.fortran90.org/src/faq.html#what-is-the-most-natural-starting-index-for-numbering">https://www.fortran90.org/src/faq.html#what-is-the-most-natural-starting-index-for-numbering</a>).
In Fortran, arrays index starting at 1 by default, but any integer can be used
as a starting index. Fortran predates Python by many decades, but is still in
use today, particularly in scientific applications, and many Python libraries
themselves such as SciPy are backed by Fortran code. Many other popular
programming languages use 1-based indexing, such as Julia, MATLAB,
Mathematica, R, Lua, and
<a class="reference external" href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)#Array_system_cross-reference_list">others</a>.
In fact, a majority of the popular programming languages that use 1-based
indexing are languages that are primarily used for scientific applications.
Scientific applications tend to make much heavier use of arrays than most
other programming tasks, and hence a heavy use of indexing.</p>
<p><strong>Half-open semantics.</strong> Finally, the idea of half-open semantics, where the
<code class="docutils literal notranslate"><span class="pre">stop</span></code> value of a slice is never included, is bad, for many of the same
reasons that 0-based indexing is bad. In most contexts outside of programming,
including virtually all mathematical contexts, when one sees a range of
values, it is implicitly assumed that both endpoints are included in the
range. For example, if you see a phrase like “ages 7 to 12”, “the letters A to
Z”, or “sum of the numbers from 1 to 10”, without any further qualification
you assume that both endpoints are included in the range. Half-open semantics
also break down when considering non-numeric quantities. For example, one
cannot represent the set of letters “from A to Z” except by including both
endpoints, as there is no letter after Z to not include.</p>
<p>It is simply more natural to think about a range as including both endpoints.
Half-open semantics are often tied to 0-based indexing, since it is a
convenient way to allow the range 0–N to contain N values, by not including
N.<a class="footnote-reference brackets" href="#python-history-footnote" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> I see this as taking a bad decision (0-based
indexing) and putting a bad bandaid on it that makes it worse. But certainly
this argument goes away for 1-based indexing. The range 1–N contains N values
exactly when N <em>is</em> included in the range.</p>
<p>You might argue that there are instances in everyday life where half-open as
well as 0-based semantics are used. For example, in the West, the reckoning of
a person’s age is typically done in a way that matches half-open 0-based
indexing semantics. If has been less than 1 year since a person’s birthdate,
you might say they are “zero years old” (although typically you use a smaller
unit of measure such as months to avoid this). And if tomorrow is my 30th
birthday, then today I will say, “I am 29 years old”, even though I am
actually 29.99 years old (I may continue to say “I am 29 years old” tomorrow,
but at least today no one would accuse me of lying). This matches the
“half-open” semantics used by slices. The end date of an age, the birthday, is
not accounted for until it has passed. This example shows that half-open
semantics do indeed go nicely with 0-based counting, and it’s indeed typically
good to use one when using the other. But age is a distance. It is the
distance in time since a person’s birthdate. So 0-based indexing makes sense
for it. Half-open semantics play nicely with age not just because it lets us
lie to ourselves about being younger than we really are, but because age is a
continuous quantity which is reckoned by integer values for convenience. Since
people rarely concern themselves with fractional ages, they must increment an
age counter at some point, and doing so on a birthday, which leads to a
“half-open” semantic, makes sense. But a collection of items like a list,
array, or string in Python usually does not represent a continuous quantity
which is discretized, but rather a quantity that is naturally discrete. So
while half-open 0-indexed semantics are perfectly reasonable for human ages,
the same argument doesn’t make sense for collections in Python.</p>
<p>When it comes to indexing, half-open semantics are problematic for a few
reasons:</p>
<ul>
<li><p>A commonly touted benefit of half-open slicing semantics is that you can
“glue” half-open intervals together. For example, <code class="docutils literal notranslate"><span class="pre">a[0:N]</span> <span class="pre">+</span> <span class="pre">a[N:M]</span></code> is the
same as <code class="docutils literal notranslate"><span class="pre">a[0:M]</span></code>. But <code class="docutils literal notranslate"><span class="pre">a[1:N]</span> <span class="pre">+</span> <span class="pre">a[N+1:M]</span></code> is just as clear. People are
perfectly used to adding 1 to get to the next term in a sequence, and it is
more natural to see <code class="docutils literal notranslate"><span class="pre">[1:N]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N+1:M]</span></code> as being non-overlapping if they
do not share endpoint values. Ranges that include both endpoints are
standard in both mathematics and everyday language. <span class="math notranslate nohighlight">\(\sum_{i=1}^n\)</span> means a
summation from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span> inclusive. Formulas like <span class="math notranslate nohighlight">\(\sum_{i=1}^n a_i =
\sum_{i=1}^k a_i + \sum_{i=k+1}^n a_i\)</span> are natural to anyone who has studied
enough mathematics. If you were to rewrite the sentences “the first <span class="math notranslate nohighlight">\(n\)</span>
numbers are <span class="math notranslate nohighlight">\(1\ldots n\)</span>; the next <span class="math notranslate nohighlight">\(n\)</span> numbers are <span class="math notranslate nohighlight">\(n+1\ldots 2n\)</span>”, or “‘the
70s’ refers to the years 1970–1979” using half-open semantics, anyone would
tell you they were phrased wrong.</p></li>
<li><p>Another benefit of half-open intervals is that they allow the range <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code>
to contain <span class="math notranslate nohighlight">\(j - i\)</span> elements (assuming <span class="math notranslate nohighlight">\(0 \leq i \leq j\)</span> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is large
enough). I tout this myself in the guide above, since it is a useful <a class="reference internal" href="#sanity-check"><span class="std std-ref">sanity
check</span></a>. However, as useful as it is, it isn’t worth the more
general confusion caused by half-open semantics. I contend people are
perfectly used to the usual <a class="reference internal" href="#fencepost"><span class="std std-ref">fencepost</span></a> offset that a range
<span class="math notranslate nohighlight">\(i\ldots j\)</span> contains <span class="math notranslate nohighlight">\(j - i + 1\)</span> numbers. Half-open semantics replace this
fencepost error with more subtle ones, which arise from forgetting that the
range doesn’t include the endpoint, unlike most natural ranges that occur in
day-to-day life. See <a class="reference internal" href="#wrong-rule-3"><span class="std std-ref">wrong rule 3</span></a> above for an example of how
half-open semantics can lead to subtle fencepost errors.</p>
<p>It is true that including both endpoints in range can lead to <a class="reference internal" href="#fencepost"><span class="std std-ref">fencepost
errors</span></a>. But the fencepost problem is fundamentally unavoidable. A
100 foot fence truly has one more fencepost than fence lengths. The best way
to deal with the fencepost problem is not to try to change the way we count
fenceposts, so that somehow 11 fenceposts is really only
10.<a class="footnote-reference brackets" href="#fencepost-footnote" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> It is rather to reuse the most natural and intuitive
way of thinking about the problem, which occurs both in programming and
non-programming contexts, which is that certain quantities, like the number of
elements in a range <span class="math notranslate nohighlight">\(1\ldots N\)</span> will require an extra “+ 1” to be correct.</p>
</li>
</ul>
<ul class="simple">
<li><p>Half-open semantics become particularly confusing when the step is negative.
This is because one must remember that the end that is not included in the
half-open interval is the second index in the slice, <em>not</em> the larger index
(see wrong rules <a class="reference internal" href="#wrong-rule-1"><span class="std std-ref">1</span></a> and <a class="reference internal" href="#wrong-rule-3"><span class="std std-ref">3</span></a> above). Were both
endpoints included, this confusion would be impossible, because positive and
negative steps would be symmetric in this regard.</p></li>
</ul>
<p>In general, half-open semantics are naively superior because they have some
properties that appear to be nice (easy unions, no +1s in length formulas).
But the “niceness” of these properties ignores the fact that most people are
already used to closed-closed intervals from mathematics and from everyday
life, and so are used to accounting for them already. So while these
properties are nice, they also break the natural intuition of how ranges work.
Half-open semantics are also closely tied to 0-based indexing, which as I
argued above, is itself problematic for many of the same reasons.</p>
<p>Again, there is no way Python itself can change any of these things at this
point. It would be way too big of a change to the language, far bigger than
any change that was made as part of Python 3 (and the Python developers have
already stated that they will never do a big breaking change like Python 3
again). But I hope I can inspire new languages and DSLs that include slicing
semantics to be written in clearer ways. And I also hope that I can break some
of the cognitive dissonance that leads people to believe that the Python
slicing rules are superior, despite the endless confusion that they provide.
Finally, I believe that simply understanding that Python has made these
decisions, whether you agree with them or not, will help you to remember the
slicing <a class="reference internal" href="#rules"><span class="std std-ref">rules</span></a>, and that’s my true goal here.</p>
</section>
<section id="footnotes">
<h2>Footnotes<a class="headerlink" href="#footnotes" title="Permalink to this heading">#</a></h2>
<!-- Footnotes are written inline above but markdown will put them here at the
end of the document. -->
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="dict-footnote" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>If you are looking for something that allows non-integer
indices or that indexes by value, you may want a <code class="docutils literal notranslate"><span class="pre">dict</span></code>. Despite using similar
syntax, <code class="docutils literal notranslate"><span class="pre">dict</span></code>s do not allow slicing.</p>
</aside>
<aside class="footnote brackets" id="numpy-definition-footnote" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p>This formulation actually isn’t particularly
helpful for formulating higher level slice formulas such as the ones used by
ndindex either.</p>
</aside>
<aside class="footnote brackets" id="fencepost-jeff-burbak-footnote" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">3</a><span class="fn-bracket">]</span></span>
<p>Image credit <a class="reference external" href="https://unsplash.com/photos/lPO0VzF_4s8">Jeff Burak via
Unsplash</a>. The image is of
Chautauqua Park in Boulder, Colorado.</p>
</aside>
<aside class="footnote brackets" id="omitted-none-footnote" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">4</a><span class="fn-bracket">]</span></span>
<p><code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>, or <code class="docutils literal notranslate"><span class="pre">step</span></code> may also be <code class="docutils literal notranslate"><span class="pre">None</span></code>, which
is syntactically equivalent to them being omitted. That is to say, <code class="docutils literal notranslate"><span class="pre">a[::]</span></code> is
a syntactic shorthand for <code class="docutils literal notranslate"><span class="pre">a[None:None:None]</span></code>. It is rare to see <code class="docutils literal notranslate"><span class="pre">None</span></code> in a
slice. This is only relevant for code that consumes slices, such as a
<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> method on an object. The <code class="docutils literal notranslate"><span class="pre">slice()</span></code> object corresponding to
<code class="docutils literal notranslate"><span class="pre">a[::]</span></code> is <code class="docutils literal notranslate"><span class="pre">slice(None,</span> <span class="pre">None,</span> <span class="pre">None)</span></code>. <a class="reference internal" href="api.html#slice-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">ndindex.Slice()</span></code></span></a> also uses
<code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate omitted entries in the same way.</p>
</aside>
<aside class="footnote brackets" id="source-footnote" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">5</a><span class="fn-bracket">]</span></span>
<p>To be sure, I make no claims that the source of any
function in ndindex cannot be simplified. In writing ndindex, I have primarily
focused on making the logic correct, and less on making it elegant. I welcome
any pull requests that simplifies the logic of a function. The extensive
<a class="reference internal" href="index.html#testing"><span class="std std-ref">testing</span></a> should ensure that any rewritten function remains correct.</p>
</aside>
<aside class="footnote brackets" id="python-history-footnote" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">6</a><span class="fn-bracket">]</span></span>
<p>In fact, the original reason that Python uses
0-based indexing is that Guido preferred the half-open semantics, which only
work out well when combined with 0-based indexing
(<a class="reference external" href="https://web.archive.org/web/20190321101606/https://plus.google.com/115212051037621986145/posts/YTUxbXYZyfi">reference</a>).</p>
</aside>
<aside class="footnote brackets" id="fencepost-footnote" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://betterexplained.com/articles/learning-how-to-count-avoiding-the-fencepost-problem/">This blog
post</a>
has a nice writeup of <em>why</em> the fencepost problem exists. It’s related to the
difference between measurement and enumeration that I touched on earlier.</p>
</aside>
</aside>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="type-confusion.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Type Confusion</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="api.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">API Reference</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2020, Quansight Labs
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/Quansight-Labs/ndindex" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Slices</a><ul>
<li><a class="reference internal" href="#what-is-a-slice">What is a slice?</a></li>
<li><a class="reference internal" href="#rules">Rules</a></li>
<li><a class="reference internal" href="#integer-indices">Integer indices</a></li>
<li><a class="reference internal" href="#points-of-confusion">Points of Confusion</a><ul>
<li><a class="reference internal" href="#subarray">Subarray</a></li>
<li><a class="reference internal" href="#based">0-based</a></li>
<li><a class="reference internal" href="#half-open">Half-open</a><ul>
<li><a class="reference internal" href="#wrong-ways-of-thinking-about-half-open-semantics">Wrong Ways of Thinking about Half-open Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#negative-indices">Negative Indices</a></li>
<li><a class="reference internal" href="#clipping">Clipping</a></li>
<li><a class="reference internal" href="#steps">Steps</a></li>
<li><a class="reference internal" href="#negative-steps">Negative Steps</a></li>
<li><a class="reference internal" href="#omitted-entries">Omitted Entries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#soapbox">Soapbox</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>window.MathJax = {"TeX": {"equationNumbers": {"autoNumber": "AMS"}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>