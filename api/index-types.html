<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Shape Tools" href="shapetools.html" /><link rel="prev" title="ndindex" href="ndindex.html" />

    <link rel="shortcut icon" href="../_static/favicon.ico"/><!-- Generated with Sphinx 8.0.2 and Furo 2024.08.06 -->
        <title>Index Types - ndindex documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=16cf08d2" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=254c7fb8" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #CCCCCC;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #CCCCCC;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #000000bd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-dark-blue);
  --color-brand-content: var(--color-brand-dark-blue);
  --color-sidebar-background: #EEEEEE;
  --color-sidebar-item-background--hover: var(--color-brand-light-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-light-blue);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --code-font-size: var(--font-size--small);
  --color-highlight-on-target: var(--color-highlighted-background);
  --color-brand-primary: var(--color-brand-light-blue);
  --color-brand-content: var(--color-brand-light-blue);
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-background-primary: black;
  --color-sidebar-background: var(--color-brand-dark-bg);
  --color-sidebar-item-background--hover: var(--color-brand-medium-blue);
  --color-sidebar-item-expander-background--hover: var(--color-brand-medium-blue);
  --color-problematic: #B30000;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ndindex  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../_static/ndindex_logo_white_bg.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../_static/ndindex_logo_dark_bg.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ndindex  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">API Reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ndindex.html">ndindex</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Index Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="shapetools.html">Shape Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="chunking.html">Chunking</a></li>
<li class="toctree-l2"><a class="reference internal" href="internal.html">Internal API</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../indexing-guide/index.html">Guide to NumPy Indexing</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Guide to NumPy Indexing</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../indexing-guide/intro.html">Introduction: What is an Index?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../indexing-guide/integer-indices.html">Integer Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../indexing-guide/slices.html">Slices</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../indexing-guide/multidimensional-indices/index.html">Multidimensional Indices</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Multidimensional Indices</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../indexing-guide/multidimensional-indices/what-is-an-array.html">What is an Array?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../indexing-guide/multidimensional-indices/tuples.html">Tuple Indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../indexing-guide/multidimensional-indices/ellipses.html">Ellipses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../indexing-guide/multidimensional-indices/newaxis.html">newaxis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../indexing-guide/multidimensional-indices/integer-arrays.html">Integer Array Indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../indexing-guide/multidimensional-indices/boolean-arrays.html">Boolean Array Indices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../indexing-guide/other-topics.html">Other Topics Relevant to Indexing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../type-confusion.html">Type Confusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">ndindex Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide.html">Documentation Style Guide</a></li>
</ul>

</div></div><div class="sidebar-tree sidebar-extra">
  <ul>
    <li class="toctree-l1">
      <a class="sidebar-extra"
      href="https://github.com/Quansight-Labs/ndindex">GitHub<svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link-external" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z"></path></svg></a>
    </li>
  </ul>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/blob/main/docs/api/index-types.rst?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/Quansight-Labs/ndindex/edit/main/docs/api/index-types.rst" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="index-types">
<span id="id1"></span><h1>Index Types<a class="headerlink" href="#index-types" title="Link to this heading">¶</a></h1>
<p>The ndindex API consists of classes to represent the different kinds of NumPy
indices, <a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>, <a class="reference internal" href="#ndindex.Slice" title="ndindex.Slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Slice</span></code></a>, <a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ellipsis</span></code></a>,
<a class="reference internal" href="#ndindex.Newaxis" title="ndindex.Newaxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Newaxis</span></code></a>, <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a>, and
<a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a>. Typical usage of ndindex consists of constructing one
of these classes, typically with the <a class="reference internal" href="ndindex.html#ndindex.ndindex" title="ndindex.ndindex"><code class="xref py py-func docutils literal notranslate"><span class="pre">ndindex()</span></code></a> constructor, then using
the methods on the objects. With a few exceptions, all index classes have the
same set of methods, so that they can be used uniformly regardless of the
actual index type. Consequently, many of the method docstrings below are
duplicated across all the classes. For classes where there is are particular
things of note for a given method, the docstring will be different (for
example, <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Slice.reduce()</span></code></a> notes the specific invariants that the
<a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce()</span></code></a> method applies to <a class="reference internal" href="#ndindex.Slice" title="ndindex.Slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Slice</span></code></a> objects). Such
methods will be noted by their “See Also” sections.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ndindex.Integer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ndindex.</span></span><span class="sig-name descname"><span class="pre">Integer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L4-L181"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer" title="Link to this definition">¶</a></dt>
<dd><p>Represents an integer index on an axis of an nd-array.</p>
<p>Any object that implements <code class="code docutils literal notranslate"><span class="pre">__index__</span></code> can be used as an integer index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">][</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">][</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Note that <code class="code docutils literal notranslate"><span class="pre">Integer</span></code> itself implements <code class="code docutils literal notranslate"><span class="pre">__index__</span></code>, so it can be used as an
index directly. However, it is still recommended to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code> for
consistency, as this only works for <code class="code docutils literal notranslate"><span class="pre">Integer</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">Integer</span></code> does <em>not</em> represent an integer, but rather an
<em>integer index</em>. It does not have most methods that <code class="code docutils literal notranslate"><span class="pre">int</span></code> has, and
should not be used in non-indexing contexts. See the document on
<a class="reference internal" href="../type-confusion.html#type-confusion"><span class="std std-ref">Type Confusion</span></a> for more details.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L171-L178"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.__eq__" title="Link to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L180-L181"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.__hash__" title="Link to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L43-L50"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.__len__" title="Link to this definition">¶</a></dt>
<dd><p>Returns the number of elements indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code></p>
<p>Since <code class="code docutils literal notranslate"><span class="pre">self</span></code> is an integer index, this always returns 1. Note that
integer indices always remove an axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.as_subindex">
<span class="sig-name descname"><span class="pre">as_subindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L125-L156"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.as_subindex" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> produces an index <code class="code docutils literal notranslate"><span class="pre">k</span></code> such that <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span></code> gives all of
the elements of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that are also in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> is a subset of <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i]</span></code>. Otherwise,
<code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">&amp;</span> <span class="pre">j]</span></code>, where <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">&amp;</span> <span class="pre">j</span></code> is the intersection of <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>, that is, the elements of <code class="code docutils literal notranslate"><span class="pre">a</span></code> that are indexed by both <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>For example, in the below diagram, <code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> index a subset of the
array <code class="code docutils literal notranslate"><span class="pre">a</span></code>. <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code> is an index on <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that gives the
subset of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> also included in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+------------</span> <span class="bp">self</span> <span class="o">------------+</span>
    <span class="o">|</span>                              <span class="o">|</span>
<span class="o">-------------------</span> <span class="n">a</span> <span class="o">-----------------------</span>
       <span class="o">|</span>                                 <span class="o">|</span>
       <span class="o">+-------------</span> <span class="n">index</span> <span class="o">-------------+</span>
       <span class="o">|</span>                           <span class="o">|</span>
       <span class="o">+-</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-+</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> is currently only implemented when <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a slice
with positive steps and nonnegative start and stop, or a Tuple of the
same. To use it with slices with negative start or stop, call
<a class="reference internal" href="#ndindex.Integer.reduce" title="ndindex.Integer.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce()</span></code></a> with a shape first.</p>
<p><code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> can be seen as the left-inverse of composition, that is,
if <code class="code docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">a[j][k]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">&quot;=&quot;</span>
<span class="pre">(j^-1)[i]</span></code> (this only works as a true inverse if <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a subset of
<code class="code docutils literal notranslate"><span class="pre">i</span></code>).</p>
<p>Note that due to symmetry, <code class="code docutils literal notranslate"><span class="pre">a[j][i.as_subindex(j)]</span></code> and
<code class="code docutils literal notranslate"><span class="pre">a[i][j.as_subindex(i)]</span></code> will give the same subarrays of <code class="code docutils literal notranslate"><span class="pre">a</span></code>, which
will be the array of elements indexed by both <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> may raise <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code> in the case that the indices
<code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> do not intersect at all.</p>
<p class="rubric">Examples</p>
<p>An example usage of <code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> is to split an index up into
subindices of chunks of an array. For example, say a 1-D array
<code class="code docutils literal notranslate"><span class="pre">a</span></code> is chunked up into chunks of size <code class="code docutils literal notranslate"><span class="pre">N</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">a[0:N]</span></code>,
<code class="code docutils literal notranslate"><span class="pre">a[N:2*N]</span></code>, <code class="code docutils literal notranslate"><span class="pre">[2*N:3*N]</span></code>, etc. are stored separately. Then an index
<code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> can be reindexed onto the chunks via <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(0,</span>
<span class="pre">N))</span></code>, <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(N,</span> <span class="pre">2*N))</span></code>, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j2</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span>
<span class="go">Slice(5, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span>
<span class="go">Slice(0, 5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>a high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
<p><a class="reference internal" href="chunking.html#ndindex.ChunkSize.num_subchunks" title="ndindex.ChunkSize.num_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.num_subchunks</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L158-L162"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.isempty" title="Link to this definition">¶</a></dt>
<dd><p>Returns whether self always indexes an empty array</p>
<p>An empty array is an array whose shape contains at least one 0. Note
that scalars (arrays with shape <code class="code docutils literal notranslate"><span class="pre">()</span></code>) are not considered empty.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default), or an array shape. If it is
<code class="code docutils literal notranslate"><span class="pre">None</span></code>, isempty() will return <code class="code docutils literal notranslate"><span class="pre">True</span></code> when <code class="code docutils literal notranslate"><span class="pre">self</span></code> is always empty for
any array shape. However, if it gives <code class="code docutils literal notranslate"><span class="pre">False</span></code>, it could still give an
empty array for some array shapes, but not all. If you know the shape
of the array that will be indexed, use <code class="code docutils literal notranslate"><span class="pre">idx.isempty(shape)</span></code> and the
result will be correct for arrays of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is
given and <code class="code docutils literal notranslate"><span class="pre">self</span></code> would raise an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> on an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>, <code class="code docutils literal notranslate"><span class="pre">isempty()</span></code> also raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.Slice.__len__</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.isvalid">
<span class="sig-name descname"><span class="pre">isvalid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L52-L58"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.isvalid" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a given index is valid on an array of a given shape.</p>
<p>Returns <code class="code docutils literal notranslate"><span class="pre">True</span></code> if an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>
and <code class="code docutils literal notranslate"><span class="pre">False</span></code> if it would raise <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that some indices can never be valid and will raise a
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> or <code class="code docutils literal notranslate"><span class="pre">TypeError</span></code> if you attempt to construct them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">((</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">an index can only have a single ellipsis (&#39;...&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;bool&#39; object cannot be interpreted as an integer</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.newshape</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.newshape">
<span class="sig-name descname"><span class="pre">newshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L118-L123"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.newshape" title="Link to this definition">¶</a></dt>
<dd><p>Returns the shape of <code class="code docutils literal notranslate"><span class="pre">a[idx.raw]</span></code>, assuming <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> should be a tuple of ints, or an int, which is equivalent to a
1-D shape.</p>
<p>Raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if <code class="code docutils literal notranslate"><span class="pre">self</span></code> would be invalid for an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 10 is out of bounds for axis 0 with size 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 2)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.isvalid" title="ndindex.ndindex.NDIndex.isvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.isvalid</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Integer.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#ndindex.Integer.raw" title="Link to this definition">¶</a></dt>
<dd><p>Return the equivalent of <code class="code docutils literal notranslate"><span class="pre">self</span></code> that can be used as an index</p>
<p>NumPy does not allow custom objects to be used as indices, with the
exception of integer indices, so to use an ndindex object as an
index, it is necessary to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axiserror</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L65-L116"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.reduce" title="Link to this definition">¶</a></dt>
<dd><p>Reduce an Integer index on an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result will either be <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if the index is invalid for the
given shape, or an Integer index where the value is nonnegative.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">negative_int</span></code> is <code class="code docutils literal notranslate"><span class="pre">True</span></code> and a <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is provided, then the result
will be an Integer index where the value is negative.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index -5 is out of bounds for axis 0 with size 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">9</span><span class="p">,))</span>
<span class="go">Integer(4)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Slice.reduce</span></code></a>, <a class="reference internal" href="#ndindex.ellipsis.reduce" title="ndindex.ellipsis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellipsis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Newaxis.reduce" title="ndindex.Newaxis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Newaxis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray.reduce" title="ndindex.IntegerArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IntegerArray.reduce</span></code></a>, <a class="reference internal" href="#ndindex.BooleanArray.reduce" title="ndindex.BooleanArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BooleanArray.reduce</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Integer.selected_indices">
<span class="sig-name descname"><span class="pre">selected_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integer.py#L164-L169"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Integer.selected_indices" title="Link to this definition">¶</a></dt>
<dd><p>Return an iterator over all indices that are selected by <code class="code docutils literal notranslate"><span class="pre">self</span></code> on an
array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result is a set of indices <code class="code docutils literal notranslate"><span class="pre">i</span></code> such that <code class="code docutils literal notranslate"><span class="pre">[a[i]</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span>
<span class="pre">idx.selected_indices(a.shape)]</span></code> is all the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>. The
indices are all iterated over in C (i.e., row major) order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[Integer(5), Integer(6), Integer(7), Integer(8), Integer(9)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[Tuple(5, 0), Tuple(5, 1),</span>
<span class="go"> Tuple(6, 0), Tuple(6, 1),</span>
<span class="go"> Tuple(7, 0), Tuple(7, 1),</span>
<span class="go"> Tuple(8, 0), Tuple(8, 1),</span>
<span class="go"> Tuple(9, 0), Tuple(9, 1)]</span>
</pre></div>
</div>
<p>To correspond these indices to the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>, you can use
<code class="code docutils literal notranslate"><span class="pre">iter_indices(idx.newshape(shape))</span></code>, since both iterators iterate the
indices in C order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">iter_indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">new_idx</span><span class="p">,)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">iter_indices</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">))):</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">a_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">new_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">])</span>
<span class="go">Tuple(3, 0) Tuple(0, 0) 15 15</span>
<span class="go">Tuple(3, 1) Tuple(0, 1) 16 16</span>
<span class="go">Tuple(4, 0) Tuple(1, 0) 20 20</span>
<span class="go">Tuple(4, 1) Tuple(1, 1) 21 21</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="shapetools.html#ndindex.iter_indices" title="ndindex.iter_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.iter_indices</span></code></a></dt><dd><p>An iterator of indices to select every element for arrays of a given shape.</p>
</dd>
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>A high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ndindex.Slice">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ndindex.</span></span><span class="sig-name descname"><span class="pre">Slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop=&lt;class</span> <span class="pre">'ndindex.slice.default'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L15-L593"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice" title="Link to this definition">¶</a></dt>
<dd><p>Represents a slice on an axis of an nd-array.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Slice(x)</span></code> with one argument is equivalent to <code class="code docutils literal notranslate"><span class="pre">Slice(None,</span> <span class="pre">x)</span></code>. <code class="code docutils literal notranslate"><span class="pre">Slice(x,</span>
<span class="pre">y)</span></code> with two arguments is equivalent to <code class="code docutils literal notranslate"><span class="pre">Slice(x,</span> <span class="pre">y,</span> <span class="pre">None)</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">start</span></code> and <code class="code docutils literal notranslate"><span class="pre">stop</span></code> can be any integer, or <code class="code docutils literal notranslate"><span class="pre">None</span></code>. <code class="code docutils literal notranslate"><span class="pre">step</span></code> can be any
nonzero integer or <code class="code docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Slice(a,</span> <span class="pre">b)</span></code> is the same as the syntax <code class="code docutils literal notranslate"><span class="pre">a:b</span></code> in an index and <code class="code docutils literal notranslate"><span class="pre">Slice(a,</span> <span class="pre">b,</span>
<span class="pre">c)</span></code> is the same as <code class="code docutils literal notranslate"><span class="pre">a:b:c</span></code>. An argument being <code class="code docutils literal notranslate"><span class="pre">None</span></code> is equivalent to the
syntax where the item is omitted, for example, <code class="code docutils literal notranslate"><span class="pre">Slice(None,</span> <span class="pre">None,</span> <span class="pre">k)</span></code> is
the same as the syntax <code class="code docutils literal notranslate"><span class="pre">::k</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Slice.args</span></code> always has three arguments, and does not make any distinction
between, for instance, <code class="code docutils literal notranslate"><span class="pre">Slice(x,</span> <span class="pre">y)</span></code> and <code class="code docutils literal notranslate"><span class="pre">Slice(x,</span> <span class="pre">y,</span> <span class="pre">None)</span></code>. This is
because Python itself does not make the distinction between <code class="code docutils literal notranslate"><span class="pre">x:y</span></code> and
<code class="code docutils literal notranslate"><span class="pre">x:y:</span></code> syntactically.</p>
<p>See <a class="reference internal" href="../indexing-guide/slices.html"><span class="doc">Slices</span></a> for a description of the semantic
meaning of slices on arrays.</p>
<p>Slice has attributes <code class="code docutils literal notranslate"><span class="pre">start</span></code>, <code class="code docutils literal notranslate"><span class="pre">stop</span></code>, and <code class="code docutils literal notranslate"><span class="pre">step</span></code> to access the
corresponding attributes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">Slice(None, 10, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">args</span>
<span class="go">(None, 10, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">raw</span>
<span class="go">slice(None, 10, None)</span>
</pre></div>
</div>
<p>For most use cases, it’s more convenient to create Slice objects using
<code class="code docutils literal notranslate"><span class="pre">ndindex[slice]</span></code>, which allows using <code class="code docutils literal notranslate"><span class="pre">a:b</span></code> slicing syntax:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">Slice(0, 10, None)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L580-L585"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.__eq__" title="Link to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L85-L90"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.__hash__" title="Link to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L123-L210"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.__len__" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">len()</span></code> gives the maximum size of an axis sliced with <code class="code docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>An actual array may produce a smaller size if it is smaller than the
bounds of the slice. For instance, <code class="code docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2][2:4]</span></code> only has 1 element
but the maximum length of the slice <code class="code docutils literal notranslate"><span class="pre">2:4</span></code> is 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[2, 3]</span>
</pre></div>
</div>
<p>If there is no such maximum, it raises <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># From the second element to the end, which could have any size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Cannot determine max length of slice</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Slice.reduce()</span></code></a> method with a <code class="code docutils literal notranslate"><span class="pre">shape</span></code> argument returns a
<code class="code docutils literal notranslate"><span class="pre">Slice</span></code> that always has a correct <code class="code docutils literal notranslate"><span class="pre">len</span></code> which doesn’t raise
<code class="code docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Slice(2, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Be aware that <code class="code docutils literal notranslate"><span class="pre">len(Slice)</span></code> only gives the size of the axis being
sliced. It does not say anything about the total shape of the array.
In particular, the array may be empty after slicing if one of its
dimensions is 0, but the other dimensions may be nonzero. To check if
an array will empty after indexing, use <a class="reference internal" href="#ndindex.Slice.isempty" title="ndindex.Slice.isempty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isempty()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.isempty" title="ndindex.Slice.isempty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isempty</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.as_subindex">
<span class="sig-name descname"><span class="pre">as_subindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L501-L568"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.as_subindex" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> produces an index <code class="code docutils literal notranslate"><span class="pre">k</span></code> such that <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span></code> gives all of
the elements of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that are also in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> is a subset of <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i]</span></code>. Otherwise,
<code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">&amp;</span> <span class="pre">j]</span></code>, where <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">&amp;</span> <span class="pre">j</span></code> is the intersection of <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>, that is, the elements of <code class="code docutils literal notranslate"><span class="pre">a</span></code> that are indexed by both <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>For example, in the below diagram, <code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> index a subset of the
array <code class="code docutils literal notranslate"><span class="pre">a</span></code>. <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code> is an index on <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that gives the
subset of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> also included in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+------------</span> <span class="bp">self</span> <span class="o">------------+</span>
    <span class="o">|</span>                              <span class="o">|</span>
<span class="o">-------------------</span> <span class="n">a</span> <span class="o">-----------------------</span>
       <span class="o">|</span>                                 <span class="o">|</span>
       <span class="o">+-------------</span> <span class="n">index</span> <span class="o">-------------+</span>
       <span class="o">|</span>                           <span class="o">|</span>
       <span class="o">+-</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-+</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> is currently only implemented when <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a slice
with positive steps and nonnegative start and stop, or a Tuple of the
same. To use it with slices with negative start or stop, call
<a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce()</span></code></a> with a shape first.</p>
<p><code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> can be seen as the left-inverse of composition, that is,
if <code class="code docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">a[j][k]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">&quot;=&quot;</span>
<span class="pre">(j^-1)[i]</span></code> (this only works as a true inverse if <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a subset of
<code class="code docutils literal notranslate"><span class="pre">i</span></code>).</p>
<p>Note that due to symmetry, <code class="code docutils literal notranslate"><span class="pre">a[j][i.as_subindex(j)]</span></code> and
<code class="code docutils literal notranslate"><span class="pre">a[i][j.as_subindex(i)]</span></code> will give the same subarrays of <code class="code docutils literal notranslate"><span class="pre">a</span></code>, which
will be the array of elements indexed by both <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> may raise <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code> in the case that the indices
<code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> do not intersect at all.</p>
<p class="rubric">Examples</p>
<p>An example usage of <code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> is to split an index up into
subindices of chunks of an array. For example, say a 1-D array
<code class="code docutils literal notranslate"><span class="pre">a</span></code> is chunked up into chunks of size <code class="code docutils literal notranslate"><span class="pre">N</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">a[0:N]</span></code>,
<code class="code docutils literal notranslate"><span class="pre">a[N:2*N]</span></code>, <code class="code docutils literal notranslate"><span class="pre">[2*N:3*N]</span></code>, etc. are stored separately. Then an index
<code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> can be reindexed onto the chunks via <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(0,</span>
<span class="pre">N))</span></code>, <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(N,</span> <span class="pre">2*N))</span></code>, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j2</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span>
<span class="go">Slice(5, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span>
<span class="go">Slice(0, 5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>a high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
<p><a class="reference internal" href="chunking.html#ndindex.ChunkSize.num_subchunks" title="ndindex.ChunkSize.num_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.num_subchunks</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L570-L578"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.isempty" title="Link to this definition">¶</a></dt>
<dd><p>Returns whether self always indexes an empty array</p>
<p>An empty array is an array whose shape contains at least one 0. Note
that scalars (arrays with shape <code class="code docutils literal notranslate"><span class="pre">()</span></code>) are not considered empty.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default), or an array shape. If it is
<code class="code docutils literal notranslate"><span class="pre">None</span></code>, isempty() will return <code class="code docutils literal notranslate"><span class="pre">True</span></code> when <code class="code docutils literal notranslate"><span class="pre">self</span></code> is always empty for
any array shape. However, if it gives <code class="code docutils literal notranslate"><span class="pre">False</span></code>, it could still give an
empty array for some array shapes, but not all. If you know the shape
of the array that will be indexed, use <code class="code docutils literal notranslate"><span class="pre">idx.isempty(shape)</span></code> and the
result will be correct for arrays of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is
given and <code class="code docutils literal notranslate"><span class="pre">self</span></code> would raise an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> on an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>, <code class="code docutils literal notranslate"><span class="pre">isempty()</span></code> also raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.Slice.__len__</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.isvalid">
<span class="sig-name descname"><span class="pre">isvalid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L484-L489"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.isvalid" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a given index is valid on an array of a given shape.</p>
<p>Returns <code class="code docutils literal notranslate"><span class="pre">True</span></code> if an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>
and <code class="code docutils literal notranslate"><span class="pre">False</span></code> if it would raise <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that some indices can never be valid and will raise a
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> or <code class="code docutils literal notranslate"><span class="pre">TypeError</span></code> if you attempt to construct them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">((</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">an index can only have a single ellipsis (&#39;...&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;bool&#39; object cannot be interpreted as an integer</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.newshape</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.newshape">
<span class="sig-name descname"><span class="pre">newshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L491-L498"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.newshape" title="Link to this definition">¶</a></dt>
<dd><p>Returns the shape of <code class="code docutils literal notranslate"><span class="pre">a[idx.raw]</span></code>, assuming <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> should be a tuple of ints, or an int, which is equivalent to a
1-D shape.</p>
<p>Raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if <code class="code docutils literal notranslate"><span class="pre">self</span></code> would be invalid for an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 10 is out of bounds for axis 0 with size 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 2)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.isvalid" title="ndindex.ndindex.NDIndex.isvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.isvalid</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Slice.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#ndindex.Slice.raw" title="Link to this definition">¶</a></dt>
<dd><p>Return the equivalent of <code class="code docutils literal notranslate"><span class="pre">self</span></code> that can be used as an index</p>
<p>NumPy does not allow custom objects to be used as indices, with the
exception of integer indices, so to use an ndindex object as an
index, it is necessary to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L212-L482"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.reduce" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">Slice.reduce</span></code> returns a slice that is canonicalized for an array of the
given shape, or for any shape if <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default).</p>
<p><code class="code docutils literal notranslate"><span class="pre">Slice.reduce</span></code> is a perfect canonicalization, meaning that two slices
are equal—for all array shapes if <code class="code docutils literal notranslate"><span class="pre">shape=None</span></code> or for arrays of
shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code> otherwise—if and only if they <code class="code docutils literal notranslate"><span class="pre">reduce</span></code> to the same
<code class="code docutils literal notranslate"><span class="pre">Slice</span></code> object. Note that ndindex objects do not simplify
automatically, and <code class="code docutils literal notranslate"><span class="pre">==</span></code> only does exact equality comparison, so to
test that two slices are equal, use <code class="code docutils literal notranslate"><span class="pre">slice1.reduce(shape)</span> <span class="pre">==</span>
<span class="pre">slice2.reduce(shape)</span></code>.</p>
<ul>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is <code class="code docutils literal notranslate"><span class="pre">None</span></code>, the following properties hold after calling
<code class="code docutils literal notranslate"><span class="pre">reduce()</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">start</span></code> is not <code class="code docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">stop</span></code> is not <code class="code docutils literal notranslate"><span class="pre">None</span></code>, when possible. The reduced <code class="code docutils literal notranslate"><span class="pre">stop</span></code> can only
be <code class="code docutils literal notranslate"><span class="pre">None</span></code> if the original <code class="code docutils literal notranslate"><span class="pre">stop</span></code> is.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">step</span></code> is not <code class="code docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">step</span></code> is as close to 0 as possible.</p></li>
<li><p>If the slice is always empty, the resulting slice will be
<code class="code docutils literal notranslate"><span class="pre">Slice(0,</span> <span class="pre">0,</span> <span class="pre">1)</span></code>. However, one should prefer the <a class="reference internal" href="#ndindex.Slice.isempty" title="ndindex.Slice.isempty"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">isempty</span></code></a>
method to test if a slice is always empty.</p></li>
</ul>
<p>In particular, <code class="code docutils literal notranslate"><span class="pre">stop</span></code> may be <code class="code docutils literal notranslate"><span class="pre">None</span></code>, even after canonicalization
with <code class="code docutils literal notranslate"><span class="pre">reduce()</span></code> with no <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. This is because some slices are
impossible to represent without <code class="code docutils literal notranslate"><span class="pre">None</span></code> without making assumptions
about the array shape. For example, <code class="code docutils literal notranslate"><span class="pre">Slice(0,</span> <span class="pre">None)</span></code> cannot be
equivalent to a slice with <code class="code docutils literal notranslate"><span class="pre">stop</span> <span class="pre">!=</span> <span class="pre">None</span></code> for all array shapes. To
get a slice where the <code class="code docutils literal notranslate"><span class="pre">start</span></code>, <code class="code docutils literal notranslate"><span class="pre">stop</span></code>, and <code class="code docutils literal notranslate"><span class="pre">step</span></code> are always
integers, use <code class="code docutils literal notranslate"><span class="pre">reduce(shape)</span></code> with an explicit array shape.</p>
<p>Note that <code class="code docutils literal notranslate"><span class="pre">Slice</span></code> objects that index a single element are not
canonicalized to <code class="code docutils literal notranslate"><span class="pre">Integer</span></code>, because integer indices always remove an
axis whereas slices keep the axis. Furthermore, slices cannot raise
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> except on arrays with shape equal to <code class="code docutils literal notranslate"><span class="pre">()</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">Slice(0, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">Slice(1, 2, 1)</span>
</pre></div>
</div>
</li>
<li><p>If an explicit shape is given, the following properties are true
after calling <code class="code docutils literal notranslate"><span class="pre">Slice.reduce(shape)</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">start</span></code>, <code class="code docutils literal notranslate"><span class="pre">stop</span></code>, and <code class="code docutils literal notranslate"><span class="pre">step</span></code> are not <code class="code docutils literal notranslate"><span class="pre">None</span></code>,</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">start</span></code> is nonnegative.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">stop</span></code> is nonnegative whenever possible. In particular, <code class="code docutils literal notranslate"><span class="pre">stop</span></code> is
only negative when it has to be to represent the given slice,
i.e., a slice with negative <code class="code docutils literal notranslate"><span class="pre">step</span></code> that indexes more than 1
element and indexes the first (index <code class="code docutils literal notranslate"><span class="pre">0</span></code>) element (in this case,
it will be <code class="code docutils literal notranslate"><span class="pre">-n</span> <span class="pre">-</span> <span class="pre">1</span></code> where <code class="code docutils literal notranslate"><span class="pre">n</span></code> is the size of the axis being
sliced).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">stop</span></code> is as small as possible for positive <code class="code docutils literal notranslate"><span class="pre">step</span></code> or large as
possible for negative <code class="code docutils literal notranslate"><span class="pre">step</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">step</span></code> is as close to 0 as possible.</p></li>
<li><p>If the slice is empty for the given shape, the resulting slice
will be <code class="code docutils literal notranslate"><span class="pre">Slice(0,</span> <span class="pre">0,</span> <span class="pre">1)</span></code>. However, one should prefer the
<a class="reference internal" href="#ndindex.Slice.isempty" title="ndindex.Slice.isempty"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">isempty</span></code></a> method to test if a slice is always empty.</p></li>
<li><p>If the slice indexes a single element, the resulting slice will be
of the form <code class="code docutils literal notranslate"><span class="pre">Slice(i,</span> <span class="pre">i+1,</span> <span class="pre">1)</span></code>. However, one should prefer using
<code class="code docutils literal notranslate"><span class="pre">len(s.reduce(shape))</span> <span class="pre">==</span> <span class="pre">1</span></code> to test if a slice indexes exactly 1
element.</p></li>
<li><p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">len()</span></code></a> gives the true size of the axis for a
sliced array of the given shape, and never raises <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code>.</p></li>
</ul>
<p>The <code class="code docutils literal notranslate"><span class="pre">axis</span></code> argument can be used to specify an axis of the shape (by
default, <code class="code docutils literal notranslate"><span class="pre">axis=0</span></code>). For convenience, <code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be passed as an integer
for a single dimension.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Slice(1, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Slice(3, 4, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Slice(1, 2, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Slice(1, 5, 3)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Cannot determine max length of slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">5</span><span class="p">,))</span>
<span class="go">Slice(2, 5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Integer.reduce" title="ndindex.Integer.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integer.reduce</span></code></a>, <a class="reference internal" href="#ndindex.ellipsis.reduce" title="ndindex.ellipsis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellipsis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Newaxis.reduce" title="ndindex.Newaxis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Newaxis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray.reduce" title="ndindex.IntegerArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IntegerArray.reduce</span></code></a>, <a class="reference internal" href="#ndindex.BooleanArray.reduce" title="ndindex.BooleanArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BooleanArray.reduce</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Slice.selected_indices">
<span class="sig-name descname"><span class="pre">selected_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/slice.py#L587-L593"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Slice.selected_indices" title="Link to this definition">¶</a></dt>
<dd><p>Return an iterator over all indices that are selected by <code class="code docutils literal notranslate"><span class="pre">self</span></code> on an
array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result is a set of indices <code class="code docutils literal notranslate"><span class="pre">i</span></code> such that <code class="code docutils literal notranslate"><span class="pre">[a[i]</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span>
<span class="pre">idx.selected_indices(a.shape)]</span></code> is all the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>. The
indices are all iterated over in C (i.e., row major) order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[Integer(5), Integer(6), Integer(7), Integer(8), Integer(9)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[Tuple(5, 0), Tuple(5, 1),</span>
<span class="go"> Tuple(6, 0), Tuple(6, 1),</span>
<span class="go"> Tuple(7, 0), Tuple(7, 1),</span>
<span class="go"> Tuple(8, 0), Tuple(8, 1),</span>
<span class="go"> Tuple(9, 0), Tuple(9, 1)]</span>
</pre></div>
</div>
<p>To correspond these indices to the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>, you can use
<code class="code docutils literal notranslate"><span class="pre">iter_indices(idx.newshape(shape))</span></code>, since both iterators iterate the
indices in C order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">iter_indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">new_idx</span><span class="p">,)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">iter_indices</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">))):</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">a_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">new_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">])</span>
<span class="go">Tuple(3, 0) Tuple(0, 0) 15 15</span>
<span class="go">Tuple(3, 1) Tuple(0, 1) 16 16</span>
<span class="go">Tuple(4, 0) Tuple(1, 0) 20 20</span>
<span class="go">Tuple(4, 1) Tuple(1, 1) 21 21</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="shapetools.html#ndindex.iter_indices" title="ndindex.iter_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.iter_indices</span></code></a></dt><dd><p>An iterator of indices to select every element for arrays of a given shape.</p>
</dd>
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>A high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Slice.start">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">start</span></span><a class="headerlink" href="#ndindex.Slice.start" title="Link to this definition">¶</a></dt>
<dd><p>The start value of the slice.</p>
<p>Note that this may be an integer or <code class="code docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Slice.step">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">step</span></span><a class="headerlink" href="#ndindex.Slice.step" title="Link to this definition">¶</a></dt>
<dd><p>The step of the slice.</p>
<p>Note that this may be a nonzero integer or <code class="code docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Slice.stop">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stop</span></span><a class="headerlink" href="#ndindex.Slice.stop" title="Link to this definition">¶</a></dt>
<dd><p>The stop of the slice.</p>
<p>Note that this may be an integer or <code class="code docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ndindex.ellipsis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ndindex.</span></span><span class="sig-name descname"><span class="pre">ellipsis</span></span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ellipsis.py#L5-L102"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.ellipsis" title="Link to this definition">¶</a></dt>
<dd><p>Represents an ellipsis index, i.e., <code class="code docutils literal notranslate"><span class="pre">...</span></code> (or <code class="code docutils literal notranslate"><span class="pre">Ellipsis</span></code>).</p>
<p>Ellipsis indices by themselves return the full array. Inside of a tuple
index, an ellipsis skips 0 or more axes of the array so that everything
after the ellipsis indexes the last axes of the array. A tuple index can
have at most one ellipsis.</p>
<p>For example <code class="code docutils literal notranslate"><span class="pre">a[(0,</span> <span class="pre">...,</span> <span class="pre">-2)]</span></code> would index the first element on the first
axis, the second-to-last element in the last axis, and include all the
axes in between.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arange</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([ 2,  6, 10])</span>
</pre></div>
</div>
<p>An ellipsis can go at the beginning of end of a tuple index, and is
allowed to match 0 axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the standard Python <code class="code docutils literal notranslate"><span class="pre">Ellipsis</span></code>, <code class="code docutils literal notranslate"><span class="pre">ellipsis</span></code> is the type, not the
object (the name is lowercase to avoid conflicting with the built-in).
Use <code class="code docutils literal notranslate"><span class="pre">ellipsis()</span></code> or <code class="code docutils literal notranslate"><span class="pre">ndindex(...)</span></code> to create the object. In most
ndindex contexts, <code class="code docutils literal notranslate"><span class="pre">...</span></code> can be used instead of <code class="code docutils literal notranslate"><span class="pre">ellipsis()</span></code>, for
instance, when creating a <code class="code docutils literal notranslate"><span class="pre">Tuple</span></code> object. Also unlike <code class="code docutils literal notranslate"><span class="pre">Ellipsis</span></code>,
<code class="code docutils literal notranslate"><span class="pre">ellipsis()</span></code> is not singletonized, so you should not use <code class="code docutils literal notranslate"><span class="pre">is</span></code> to
compare it. See the document on <a class="reference internal" href="../type-confusion.html#type-confusion-ellipsis"><span class="std std-ref">type confusion</span></a> for more details.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ndindex.ellipsis.as_subindex">
<span class="sig-name descname"><span class="pre">as_subindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ellipsis.py#L92-L93"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.ellipsis.as_subindex" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> produces an index <code class="code docutils literal notranslate"><span class="pre">k</span></code> such that <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span></code> gives all of
the elements of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that are also in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> is a subset of <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i]</span></code>. Otherwise,
<code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">&amp;</span> <span class="pre">j]</span></code>, where <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">&amp;</span> <span class="pre">j</span></code> is the intersection of <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>, that is, the elements of <code class="code docutils literal notranslate"><span class="pre">a</span></code> that are indexed by both <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>For example, in the below diagram, <code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> index a subset of the
array <code class="code docutils literal notranslate"><span class="pre">a</span></code>. <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code> is an index on <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that gives the
subset of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> also included in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+------------</span> <span class="bp">self</span> <span class="o">------------+</span>
    <span class="o">|</span>                              <span class="o">|</span>
<span class="o">-------------------</span> <span class="n">a</span> <span class="o">-----------------------</span>
       <span class="o">|</span>                                 <span class="o">|</span>
       <span class="o">+-------------</span> <span class="n">index</span> <span class="o">-------------+</span>
       <span class="o">|</span>                           <span class="o">|</span>
       <span class="o">+-</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-+</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> is currently only implemented when <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a slice
with positive steps and nonnegative start and stop, or a Tuple of the
same. To use it with slices with negative start or stop, call
<a class="reference internal" href="#ndindex.ellipsis.reduce" title="ndindex.ellipsis.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce()</span></code></a> with a shape first.</p>
<p><code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> can be seen as the left-inverse of composition, that is,
if <code class="code docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">a[j][k]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">&quot;=&quot;</span>
<span class="pre">(j^-1)[i]</span></code> (this only works as a true inverse if <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a subset of
<code class="code docutils literal notranslate"><span class="pre">i</span></code>).</p>
<p>Note that due to symmetry, <code class="code docutils literal notranslate"><span class="pre">a[j][i.as_subindex(j)]</span></code> and
<code class="code docutils literal notranslate"><span class="pre">a[i][j.as_subindex(i)]</span></code> will give the same subarrays of <code class="code docutils literal notranslate"><span class="pre">a</span></code>, which
will be the array of elements indexed by both <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> may raise <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code> in the case that the indices
<code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> do not intersect at all.</p>
<p class="rubric">Examples</p>
<p>An example usage of <code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> is to split an index up into
subindices of chunks of an array. For example, say a 1-D array
<code class="code docutils literal notranslate"><span class="pre">a</span></code> is chunked up into chunks of size <code class="code docutils literal notranslate"><span class="pre">N</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">a[0:N]</span></code>,
<code class="code docutils literal notranslate"><span class="pre">a[N:2*N]</span></code>, <code class="code docutils literal notranslate"><span class="pre">[2*N:3*N]</span></code>, etc. are stored separately. Then an index
<code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> can be reindexed onto the chunks via <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(0,</span>
<span class="pre">N))</span></code>, <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(N,</span> <span class="pre">2*N))</span></code>, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j2</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span>
<span class="go">Slice(5, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span>
<span class="go">Slice(0, 5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>a high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
<p><a class="reference internal" href="chunking.html#ndindex.ChunkSize.num_subchunks" title="ndindex.ChunkSize.num_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.num_subchunks</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.ellipsis.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ellipsis.py#L95-L96"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.ellipsis.isempty" title="Link to this definition">¶</a></dt>
<dd><p>Returns whether self always indexes an empty array</p>
<p>An empty array is an array whose shape contains at least one 0. Note
that scalars (arrays with shape <code class="code docutils literal notranslate"><span class="pre">()</span></code>) are not considered empty.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default), or an array shape. If it is
<code class="code docutils literal notranslate"><span class="pre">None</span></code>, isempty() will return <code class="code docutils literal notranslate"><span class="pre">True</span></code> when <code class="code docutils literal notranslate"><span class="pre">self</span></code> is always empty for
any array shape. However, if it gives <code class="code docutils literal notranslate"><span class="pre">False</span></code>, it could still give an
empty array for some array shapes, but not all. If you know the shape
of the array that will be indexed, use <code class="code docutils literal notranslate"><span class="pre">idx.isempty(shape)</span></code> and the
result will be correct for arrays of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is
given and <code class="code docutils literal notranslate"><span class="pre">self</span></code> would raise an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> on an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>, <code class="code docutils literal notranslate"><span class="pre">isempty()</span></code> also raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.Slice.__len__</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.ellipsis.isvalid">
<span class="sig-name descname"><span class="pre">isvalid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ellipsis.py#L82-L84"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.ellipsis.isvalid" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a given index is valid on an array of a given shape.</p>
<p>Returns <code class="code docutils literal notranslate"><span class="pre">True</span></code> if an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>
and <code class="code docutils literal notranslate"><span class="pre">False</span></code> if it would raise <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that some indices can never be valid and will raise a
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> or <code class="code docutils literal notranslate"><span class="pre">TypeError</span></code> if you attempt to construct them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">((</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">an index can only have a single ellipsis (&#39;...&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;bool&#39; object cannot be interpreted as an integer</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.newshape</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.ellipsis.newshape">
<span class="sig-name descname"><span class="pre">newshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ellipsis.py#L86-L90"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.ellipsis.newshape" title="Link to this definition">¶</a></dt>
<dd><p>Returns the shape of <code class="code docutils literal notranslate"><span class="pre">a[idx.raw]</span></code>, assuming <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> should be a tuple of ints, or an int, which is equivalent to a
1-D shape.</p>
<p>Raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if <code class="code docutils literal notranslate"><span class="pre">self</span></code> would be invalid for an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 10 is out of bounds for axis 0 with size 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 2)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.isvalid" title="ndindex.ndindex.NDIndex.isvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.isvalid</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.ellipsis.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#ndindex.ellipsis.raw" title="Link to this definition">¶</a></dt>
<dd><p>Return the equivalent of <code class="code docutils literal notranslate"><span class="pre">self</span></code> that can be used as an index</p>
<p>NumPy does not allow custom objects to be used as indices, with the
exception of integer indices, so to use an ndindex object as an
index, it is necessary to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.ellipsis.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ellipsis.py#L50-L76"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.ellipsis.reduce" title="Link to this definition">¶</a></dt>
<dd><p>Reduce an ellipsis index</p>
<p>Since an ellipsis by itself always returns the full array unchanged,
<code class="code docutils literal notranslate"><span class="pre">ellipsis().reduce()</span></code> returns <code class="code docutils literal notranslate"><span class="pre">Tuple()</span></code> as a canonical form (the index
<code class="code docutils literal notranslate"><span class="pre">()</span></code> also always returns an array unchanged).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ellipsis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipsis</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">Tuple()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Slice.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Newaxis.reduce" title="ndindex.Newaxis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Newaxis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Integer.reduce" title="ndindex.Integer.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integer.reduce</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray.reduce" title="ndindex.IntegerArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IntegerArray.reduce</span></code></a>, <a class="reference internal" href="#ndindex.BooleanArray.reduce" title="ndindex.BooleanArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BooleanArray.reduce</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ndindex.Newaxis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ndindex.</span></span><span class="sig-name descname"><span class="pre">Newaxis</span></span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/newaxis.py#L4-L96"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Newaxis" title="Link to this definition">¶</a></dt>
<dd><p>Represents a <code class="code docutils literal notranslate"><span class="pre">np.newaxis</span></code> (i.e., <code class="code docutils literal notranslate"><span class="pre">None</span></code>) index.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Newaxis</span></code> adds a shape 1 dimension to the array. If a <code class="code docutils literal notranslate"><span class="pre">Newaxis</span></code> is inside
of a tuple index, it adds a shape 1 dimension at that location in the
index.</p>
<p>For example, if <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[newaxis]</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">(1,</span>
<span class="pre">2,</span> <span class="pre">3)</span></code>, <code class="code docutils literal notranslate"><span class="pre">a[:,</span> <span class="pre">newaxis]</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">1,</span> <span class="pre">3)</span></code>, and so on.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Newaxis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arange</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">Newaxis</span><span class="p">()</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,</span> <span class="n">Newaxis</span><span class="p">()</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3)</span>
</pre></div>
</div>
<p>Using <code class="code docutils literal notranslate"><span class="pre">Newaxis().raw</span></code> as an index is equivalent to using <code class="code docutils literal notranslate"><span class="pre">numpy.newaxis</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the NumPy <code class="code docutils literal notranslate"><span class="pre">newaxis</span></code>, <code class="code docutils literal notranslate"><span class="pre">Newaxis</span></code> is the type, not the object (the
name is uppercase to avoid conflicting with the NumPy type). Use
<code class="code docutils literal notranslate"><span class="pre">Newaxis()</span></code>, <code class="code docutils literal notranslate"><span class="pre">ndindex(np.newaxis)</span></code>, or <code class="code docutils literal notranslate"><span class="pre">ndindex(None)</span></code> to create the
object. In most ndindex contexts, <code class="code docutils literal notranslate"><span class="pre">np.newaxis</span></code> or <code class="code docutils literal notranslate"><span class="pre">None</span></code> can be used
instead of <code class="code docutils literal notranslate"><span class="pre">Newaxis()</span></code>, for instance, when creating a <code class="code docutils literal notranslate"><span class="pre">Tuple</span></code> object.
Also unlike <code class="code docutils literal notranslate"><span class="pre">None</span></code>, <code class="code docutils literal notranslate"><span class="pre">Newaxis()</span></code> is not singletonized, so you should not
use <code class="code docutils literal notranslate"><span class="pre">is</span></code> to compare it. See the document on <a class="reference internal" href="../type-confusion.html#type-confusion"><span class="std std-ref">Type Confusion</span></a> for
more details.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Newaxis.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/newaxis.py#L86-L90"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Newaxis.isempty" title="Link to this definition">¶</a></dt>
<dd><p>Returns whether self always indexes an empty array</p>
<p>An empty array is an array whose shape contains at least one 0. Note
that scalars (arrays with shape <code class="code docutils literal notranslate"><span class="pre">()</span></code>) are not considered empty.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default), or an array shape. If it is
<code class="code docutils literal notranslate"><span class="pre">None</span></code>, isempty() will return <code class="code docutils literal notranslate"><span class="pre">True</span></code> when <code class="code docutils literal notranslate"><span class="pre">self</span></code> is always empty for
any array shape. However, if it gives <code class="code docutils literal notranslate"><span class="pre">False</span></code>, it could still give an
empty array for some array shapes, but not all. If you know the shape
of the array that will be indexed, use <code class="code docutils literal notranslate"><span class="pre">idx.isempty(shape)</span></code> and the
result will be correct for arrays of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is
given and <code class="code docutils literal notranslate"><span class="pre">self</span></code> would raise an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> on an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>, <code class="code docutils literal notranslate"><span class="pre">isempty()</span></code> also raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.Slice.__len__</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Newaxis.isvalid">
<span class="sig-name descname"><span class="pre">isvalid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/newaxis.py#L73-L75"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Newaxis.isvalid" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a given index is valid on an array of a given shape.</p>
<p>Returns <code class="code docutils literal notranslate"><span class="pre">True</span></code> if an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>
and <code class="code docutils literal notranslate"><span class="pre">False</span></code> if it would raise <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that some indices can never be valid and will raise a
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> or <code class="code docutils literal notranslate"><span class="pre">TypeError</span></code> if you attempt to construct them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">((</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">an index can only have a single ellipsis (&#39;...&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;bool&#39; object cannot be interpreted as an integer</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.newshape</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Newaxis.newshape">
<span class="sig-name descname"><span class="pre">newshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/newaxis.py#L77-L84"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Newaxis.newshape" title="Link to this definition">¶</a></dt>
<dd><p>Returns the shape of <code class="code docutils literal notranslate"><span class="pre">a[idx.raw]</span></code>, assuming <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> should be a tuple of ints, or an int, which is equivalent to a
1-D shape.</p>
<p>Raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if <code class="code docutils literal notranslate"><span class="pre">self</span></code> would be invalid for an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 10 is out of bounds for axis 0 with size 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 2)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.isvalid" title="ndindex.ndindex.NDIndex.isvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.isvalid</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Newaxis.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#ndindex.Newaxis.raw" title="Link to this definition">¶</a></dt>
<dd><p>Return the equivalent of <code class="code docutils literal notranslate"><span class="pre">self</span></code> that can be used as an index</p>
<p>NumPy does not allow custom objects to be used as indices, with the
exception of integer indices, so to use an ndindex object as an
index, it is necessary to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Newaxis.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/newaxis.py#L46-L71"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Newaxis.reduce" title="Link to this definition">¶</a></dt>
<dd><p>Reduce a <code class="code docutils literal notranslate"><span class="pre">Newaxis</span></code> index</p>
<p>There is no other index that is equivalent to a newaxis index by
itself, so <code class="code docutils literal notranslate"><span class="pre">Newaxis().reduce()</span></code> always returns <code class="code docutils literal notranslate"><span class="pre">Newaxis()</span></code> unchanged.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Newaxis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Newaxis</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">Newaxis()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Slice.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Integer.reduce" title="ndindex.Integer.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integer.reduce</span></code></a>, <a class="reference internal" href="#ndindex.ellipsis.reduce" title="ndindex.ellipsis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellipsis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray.reduce" title="ndindex.IntegerArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IntegerArray.reduce</span></code></a>, <a class="reference internal" href="#ndindex.BooleanArray.reduce" title="ndindex.BooleanArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BooleanArray.reduce</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ndindex.Tuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ndindex.</span></span><span class="sig-name descname"><span class="pre">Tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L8-L791"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple" title="Link to this definition">¶</a></dt>
<dd><p>Represents a tuple of single-axis indices.</p>
<p>Valid single axis indices are</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a></p></li>
<li><p><a class="reference internal" href="#ndindex.Slice" title="ndindex.Slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Slice</span></code></a></p></li>
<li><p><a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ellipsis</span></code></a></p></li>
<li><p><a class="reference internal" href="#ndindex.Newaxis" title="ndindex.Newaxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Newaxis</span></code></a></p></li>
<li><p><a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a></p></li>
<li><p><a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a></p></li>
</ul>
<p>(some of the above are not yet implemented)</p>
<p><code class="code docutils literal notranslate"><span class="pre">Tuple(x1,</span> <span class="pre">x2,</span> <span class="pre">…,</span> <span class="pre">xn)</span></code> represents the index <code class="code docutils literal notranslate"><span class="pre">a[x1,</span> <span class="pre">x2,</span> <span class="pre">…,</span> <span class="pre">xn]</span></code> or,
equivalently, <code class="code docutils literal notranslate"><span class="pre">a[(x1,</span> <span class="pre">x2,</span> <span class="pre">…,</span> <span class="pre">xn)]</span></code>. <code class="code docutils literal notranslate"><span class="pre">Tuple()</span></code> with no arguments is the
empty tuple index, <code class="code docutils literal notranslate"><span class="pre">a[()]</span></code>, which returns <code class="code docutils literal notranslate"><span class="pre">a</span></code> unchanged.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">Tuple</span></code> does <em>not</em> represent a tuple, but rather an <em>tuple index</em>. It
does not have most methods that <code class="code docutils literal notranslate"><span class="pre">tuple</span></code> has, and should not be used in
non-indexing contexts. See the document on <a class="reference internal" href="../type-confusion.html#type-confusion"><span class="std std-ref">Type Confusion</span></a> for
more details.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Tuple.as_subindex">
<span class="sig-name descname"><span class="pre">as_subindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L627-L737"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple.as_subindex" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> produces an index <code class="code docutils literal notranslate"><span class="pre">k</span></code> such that <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span></code> gives all of
the elements of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that are also in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> is a subset of <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i]</span></code>. Otherwise,
<code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">&amp;</span> <span class="pre">j]</span></code>, where <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">&amp;</span> <span class="pre">j</span></code> is the intersection of <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>, that is, the elements of <code class="code docutils literal notranslate"><span class="pre">a</span></code> that are indexed by both <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>For example, in the below diagram, <code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> index a subset of the
array <code class="code docutils literal notranslate"><span class="pre">a</span></code>. <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code> is an index on <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that gives the
subset of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> also included in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+------------</span> <span class="bp">self</span> <span class="o">------------+</span>
    <span class="o">|</span>                              <span class="o">|</span>
<span class="o">-------------------</span> <span class="n">a</span> <span class="o">-----------------------</span>
       <span class="o">|</span>                                 <span class="o">|</span>
       <span class="o">+-------------</span> <span class="n">index</span> <span class="o">-------------+</span>
       <span class="o">|</span>                           <span class="o">|</span>
       <span class="o">+-</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-+</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> is currently only implemented when <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a slice
with positive steps and nonnegative start and stop, or a Tuple of the
same. To use it with slices with negative start or stop, call
<a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce()</span></code></a> with a shape first.</p>
<p><code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> can be seen as the left-inverse of composition, that is,
if <code class="code docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">a[j][k]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">&quot;=&quot;</span>
<span class="pre">(j^-1)[i]</span></code> (this only works as a true inverse if <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a subset of
<code class="code docutils literal notranslate"><span class="pre">i</span></code>).</p>
<p>Note that due to symmetry, <code class="code docutils literal notranslate"><span class="pre">a[j][i.as_subindex(j)]</span></code> and
<code class="code docutils literal notranslate"><span class="pre">a[i][j.as_subindex(i)]</span></code> will give the same subarrays of <code class="code docutils literal notranslate"><span class="pre">a</span></code>, which
will be the array of elements indexed by both <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> may raise <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code> in the case that the indices
<code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> do not intersect at all.</p>
<p class="rubric">Examples</p>
<p>An example usage of <code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> is to split an index up into
subindices of chunks of an array. For example, say a 1-D array
<code class="code docutils literal notranslate"><span class="pre">a</span></code> is chunked up into chunks of size <code class="code docutils literal notranslate"><span class="pre">N</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">a[0:N]</span></code>,
<code class="code docutils literal notranslate"><span class="pre">a[N:2*N]</span></code>, <code class="code docutils literal notranslate"><span class="pre">[2*N:3*N]</span></code>, etc. are stored separately. Then an index
<code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> can be reindexed onto the chunks via <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(0,</span>
<span class="pre">N))</span></code>, <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(N,</span> <span class="pre">2*N))</span></code>, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j2</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span>
<span class="go">Slice(5, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span>
<span class="go">Slice(0, 5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>a high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
<p><a class="reference internal" href="chunking.html#ndindex.ChunkSize.num_subchunks" title="ndindex.ChunkSize.num_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.num_subchunks</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Tuple.broadcast_arrays">
<span class="sig-name descname"><span class="pre">broadcast_arrays</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L398-L451"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple.broadcast_arrays" title="Link to this definition">¶</a></dt>
<dd><p>Broadcast all the array indices in self to a common shape and convert
boolean array indices into integer array indices.</p>
<p>The resulting index is equivalent in all contexts where the original
index is allowed. However, it is possible for the original index to
give an IndexError but for the new index to not, since integer array
indices have less stringent shape requirements than boolean array
indices. There are also some instances for empty indices
(<a class="reference internal" href="#ndindex.Tuple.isempty" title="ndindex.Tuple.isempty"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">isempty</span></code></a> is True) where bounds would be checked before
broadcasting but not after.</p>
<p>Any <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> indices are converted to
<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices. Furthermore, if there are
<a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> or <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices, then any
<a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> indices are also converted into scalar
<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices and broadcast. Furthermore, if there are
multiple boolean scalar indices (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>), they are combined
into a single one.</p>
<p>Note that array broadcastability is checked in the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>
constructor, so this method will not raise any exceptions.</p>
<p>This is part of what is performed by <a class="reference internal" href="#ndindex.Tuple.expand" title="ndindex.Tuple.expand"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">expand</span></code></a>, but unlike
<a class="reference internal" href="#ndindex.Tuple.expand" title="ndindex.Tuple.expand"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">expand</span></code></a>, this method does not do any other manipulations, and it
does not require a shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">())</span>
<span class="go">Tuple(IntegerArray([[1 2] [1 2] [1 2]]),</span>
<span class="go">      IntegerArray([[0 0] [0 0] [0 0]]),</span>
<span class="go">      IntegerArray([[4 4] [5 5] [5 5]]),</span>
<span class="go">      IntegerArray([[-1 -1] [-1 -1] [-1 -1]]))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Tuple.expand" title="ndindex.Tuple.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Tuple.ellipsis_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ellipsis_index</span></span><a class="headerlink" href="#ndindex.Tuple.ellipsis_index" title="Link to this definition">¶</a></dt>
<dd><p>Give the index i of <code class="code docutils literal notranslate"><span class="pre">self.args</span></code> where the ellipsis is.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">self</span></code> doesn’t have an ellipsis, it gives <code class="code docutils literal notranslate"><span class="pre">len(self.args)</span></code>, since
tuple indices without an ellipsis always implicitly end in an
ellipsis.</p>
<p>The resulting value <code class="code docutils literal notranslate"><span class="pre">i</span></code> is such that <code class="code docutils literal notranslate"><span class="pre">self.args[:i]</span></code> indexes the
beginning axes of an array and <code class="code docutils literal notranslate"><span class="pre">self.args[i+1:]</span></code> indexes the end axes
of an array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">ellipsis_index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
<span class="go">(Integer(0), Integer(1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">(Integer(2), Integer(3))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ellipsis_index</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Tuple.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L453-L582"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple.expand" title="Link to this definition">¶</a></dt>
<dd><p>Expand a Tuple index on an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code></p>
<p>An expanded index is as explicit as possible. Unlike <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce</span></code></a>, which tries to simplify an index
and remove redundancies, <code class="code docutils literal notranslate"><span class="pre">expand()</span></code> typically makes an index larger.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">self</span></code> is invalid for the given shape, an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> is raised.
Otherwise, the returned index satisfies the following:</p>
<ul class="simple">
<li><p>It is always a <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>.</p></li>
<li><p>All the elements of the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> are recursively <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">reduced</span></code></a>.</p></li>
<li><p>The length of the <code class="code docutils literal notranslate"><span class="pre">.args</span></code> is equal to the length of the shape plus
the number of <a class="reference internal" href="#ndindex.Newaxis" title="ndindex.Newaxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Newaxis</span></code></a> indices in <code class="code docutils literal notranslate"><span class="pre">self</span></code> plus 1 if there
is a scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p>The resulting <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> has no <a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ellipses</span></code></a>. If there are axes that would be matched by an
ellipsis or an implicit ellipsis at the end of the tuple, <code class="code docutils literal notranslate"><span class="pre">Slice(0,</span>
<span class="pre">n,</span> <span class="pre">1)</span></code> indices are inserted, where <code class="code docutils literal notranslate"><span class="pre">n</span></code> is the corresponding axis of
the <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p></li>
<li><p>Any array indices in <code class="code docutils literal notranslate"><span class="pre">self</span></code> are broadcast together. If <code class="code docutils literal notranslate"><span class="pre">self</span></code>
contains array indices (<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> or
<a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a>), then any <a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> indices are
converted into <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices of shape <code class="code docutils literal notranslate"><span class="pre">()</span></code> and
broadcast. Note that broadcasting is done in a memory efficient way
so that even if the broadcasted shape is large it will not take up
more memory than the original.</p></li>
<li><p>Scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> arguments (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>) are
combined into a single term (the same as with <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Tuple.reduce()</span></code></a>).</p></li>
<li><p>Non-scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a>s are all converted into
equivalent <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a>s via <code class="code docutils literal notranslate"><span class="pre">nonzero()</span></code> and
broadcasted.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 2, 1), slice(0, 3, 1))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 5, 1), None, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 1, 1), slice(0, 2, 1), None, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">too many indices for array: array is 1-dimensional, but 2 were indexed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index -3 is out of bounds for axis 1 with size 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 1, 1), [0, 1], [2, 2])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Tuple.broadcast_arrays" title="ndindex.Tuple.broadcast_arrays"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_arrays</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Tuple.has_ellipsis">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_ellipsis</span></span><a class="headerlink" href="#ndindex.Tuple.has_ellipsis" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if self has an ellipsis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Tuple.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L739-L743"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple.isempty" title="Link to this definition">¶</a></dt>
<dd><p>Returns whether self always indexes an empty array</p>
<p>An empty array is an array whose shape contains at least one 0. Note
that scalars (arrays with shape <code class="code docutils literal notranslate"><span class="pre">()</span></code>) are not considered empty.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default), or an array shape. If it is
<code class="code docutils literal notranslate"><span class="pre">None</span></code>, isempty() will return <code class="code docutils literal notranslate"><span class="pre">True</span></code> when <code class="code docutils literal notranslate"><span class="pre">self</span></code> is always empty for
any array shape. However, if it gives <code class="code docutils literal notranslate"><span class="pre">False</span></code>, it could still give an
empty array for some array shapes, but not all. If you know the shape
of the array that will be indexed, use <code class="code docutils literal notranslate"><span class="pre">idx.isempty(shape)</span></code> and the
result will be correct for arrays of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is
given and <code class="code docutils literal notranslate"><span class="pre">self</span></code> would raise an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> on an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>, <code class="code docutils literal notranslate"><span class="pre">isempty()</span></code> also raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.Slice.__len__</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Tuple.newshape">
<span class="sig-name descname"><span class="pre">newshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L584-L625"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple.newshape" title="Link to this definition">¶</a></dt>
<dd><p>Returns the shape of <code class="code docutils literal notranslate"><span class="pre">a[idx.raw]</span></code>, assuming <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> should be a tuple of ints, or an int, which is equivalent to a
1-D shape.</p>
<p>Raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if <code class="code docutils literal notranslate"><span class="pre">self</span></code> would be invalid for an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 10 is out of bounds for axis 0 with size 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 2)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.isvalid" title="ndindex.ndindex.NDIndex.isvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.isvalid</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.Tuple.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#ndindex.Tuple.raw" title="Link to this definition">¶</a></dt>
<dd><p>Return the equivalent of <code class="code docutils literal notranslate"><span class="pre">self</span></code> that can be used as an index</p>
<p>NumPy does not allow custom objects to be used as indices, with the
exception of integer indices, so to use an ndindex object as an
index, it is necessary to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Tuple.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L185-L396"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple.reduce" title="Link to this definition">¶</a></dt>
<dd><p>Reduce a Tuple index on an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code></p>
<p>A <code class="code docutils literal notranslate"><span class="pre">Tuple</span></code> with a single argument is always reduced to that single
argument (because <code class="code docutils literal notranslate"><span class="pre">a[idx,]</span></code> is the same as <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">Slice(2, 4, 1)</span>
</pre></div>
</div>
<p>If an explicit array shape is given, the result will either be
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if the index is invalid for the given shape, or an index
that is as simple as possible:</p>
<ul class="simple">
<li><p>All the elements of the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> are recursively <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">reduced</span></code></a>.</p></li>
<li><p>Any axes that can be merged into an <a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ellipsis</span></code></a> are removed.
This includes the implicit ellipsis at the end of a Tuple that
doesn’t contain any explicit ellipses.</p></li>
<li><p><a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Ellipses</span></code></a> that don’t match any axes are removed.</p></li>
<li><p>An <a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ellipsis</span></code></a> at the end of the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> is removed.</p></li>
<li><p>Scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> arguments (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>) are
combined into a single term (the first boolean scalar is replaced
with the AND of all the boolean scalars).</p></li>
<li><p>If the resulting <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> would have a single argument, that
argument is returned.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">Tuple(0, slice(0, 3, 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Integer(0)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">5</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">too many indices for array: array is 1-dimensional, but 2 were indexed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index -3 is out of bounds for axis 1 with size 2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>ndindex presently does not distinguish between scalar objects and
0-D arrays. It is possible for the original index to produce one
and the reduced index to produce the other. In particular, the
presence of a redundant ellipsis forces NumPy to return a 0-D array
instead of a scalar.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">Integer(1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array(1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
<span class="go">np.int64(1)</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/Quansight-Labs/ndindex/issues/22">https://github.com/Quansight-Labs/ndindex/issues/22</a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Tuple.expand" title="ndindex.Tuple.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.expand</span></code></a>, <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Slice.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Integer.reduce" title="ndindex.Integer.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integer.reduce</span></code></a>, <a class="reference internal" href="#ndindex.ellipsis.reduce" title="ndindex.ellipsis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellipsis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Newaxis.reduce" title="ndindex.Newaxis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Newaxis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray.reduce" title="ndindex.IntegerArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IntegerArray.reduce</span></code></a>, <a class="reference internal" href="#ndindex.BooleanArray.reduce" title="ndindex.BooleanArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BooleanArray.reduce</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.Tuple.selected_indices">
<span class="sig-name descname"><span class="pre">selected_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/tuple.py#L745-L791"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.Tuple.selected_indices" title="Link to this definition">¶</a></dt>
<dd><p>Return an iterator over all indices that are selected by <code class="code docutils literal notranslate"><span class="pre">self</span></code> on an
array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result is a set of indices <code class="code docutils literal notranslate"><span class="pre">i</span></code> such that <code class="code docutils literal notranslate"><span class="pre">[a[i]</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span>
<span class="pre">idx.selected_indices(a.shape)]</span></code> is all the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>. The
indices are all iterated over in C (i.e., row major) order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[Integer(5), Integer(6), Integer(7), Integer(8), Integer(9)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[Tuple(5, 0), Tuple(5, 1),</span>
<span class="go"> Tuple(6, 0), Tuple(6, 1),</span>
<span class="go"> Tuple(7, 0), Tuple(7, 1),</span>
<span class="go"> Tuple(8, 0), Tuple(8, 1),</span>
<span class="go"> Tuple(9, 0), Tuple(9, 1)]</span>
</pre></div>
</div>
<p>To correspond these indices to the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>, you can use
<code class="code docutils literal notranslate"><span class="pre">iter_indices(idx.newshape(shape))</span></code>, since both iterators iterate the
indices in C order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">iter_indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">new_idx</span><span class="p">,)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">iter_indices</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">))):</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">a_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">new_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">])</span>
<span class="go">Tuple(3, 0) Tuple(0, 0) 15 15</span>
<span class="go">Tuple(3, 1) Tuple(0, 1) 16 16</span>
<span class="go">Tuple(4, 0) Tuple(1, 0) 20 20</span>
<span class="go">Tuple(4, 1) Tuple(1, 1) 21 21</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="shapetools.html#ndindex.iter_indices" title="ndindex.iter_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.iter_indices</span></code></a></dt><dd><p>An iterator of indices to select every element for arrays of a given shape.</p>
</dd>
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>A high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ndindex.IntegerArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ndindex.</span></span><span class="sig-name descname"><span class="pre">IntegerArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integerarray.py#L5-L204"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray" title="Link to this definition">¶</a></dt>
<dd><p>Represents an integer array index.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">idx</span></code> is an n-dimensional integer array with shape <code class="code docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">(s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>
and <code class="code docutils literal notranslate"><span class="pre">a</span></code> is any array, <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code> replaces the first dimension of <code class="code docutils literal notranslate"><span class="pre">a</span></code> with
dimensions of size <code class="code docutils literal notranslate"><span class="pre">s1,</span> <span class="pre">...,</span> <span class="pre">sn</span></code>, where each entry is indexed according to
the entry in <code class="code docutils literal notranslate"><span class="pre">idx</span></code> as an integer index.</p>
<p>Integer arrays can also appear as part of tuple indices. In that case,
they replace the axis being indexed. If more than one integer array
appears inside of a tuple index, they are broadcast together and iterated
as one. Furthermore, if an integer array appears in a tuple index, all
integer indices in the tuple are treated as scalar integer arrays and are
also broadcast. In general, an <a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> index semantically behaves
the same as a scalar (<code class="code docutils literal notranslate"><span class="pre">shape=()</span></code>) <code class="code docutils literal notranslate"><span class="pre">IntegerArray</span></code>.</p>
<p>A list of integers may also be used in place of an integer array. Note
that NumPy treats a direct list of integers as a tuple index, but this
behavior is deprecated and will be replaced with integer array indexing in
the future. ndindex always treats lists as arrays.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">IntegerArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 2]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">IntegerArray</span></code> does <em>not</em> represent an array, but rather an <em>array
index</em>. It does not have most methods that <code class="code docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> has, and
should not be used in array contexts. See the document on
<a class="reference internal" href="../type-confusion.html#type-confusion"><span class="std std-ref">Type Confusion</span></a> for more details.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ndindex.IntegerArray.dtype">
<span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#ndindex.IntegerArray.dtype" title="Link to this definition">¶</a></dt>
<dd><p>The dtype of <code class="code docutils literal notranslate"><span class="pre">IntegerArray</span></code> is <code class="code docutils literal notranslate"><span class="pre">np.intp</span></code>, which is typically either
<code class="code docutils literal notranslate"><span class="pre">np.int32</span></code> or <code class="code docutils literal notranslate"><span class="pre">np.int64</span></code> depending on the platform.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ndindex.IntegerArray.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#ndindex.IntegerArray.args" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">idx.args</span></code> contains the arguments needed to create <code class="code docutils literal notranslate"><span class="pre">idx</span></code>.</p>
<p>For an ndindex object <code class="code docutils literal notranslate"><span class="pre">idx</span></code>, <code class="code docutils literal notranslate"><span class="pre">idx.args</span></code> is always a tuple such that</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)(</span><span class="o">*</span><span class="n">idx</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="n">idx</span>
</pre></div>
</div>
<p>For <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> indices, the elements of <code class="code docutils literal notranslate"><span class="pre">.args</span></code> are themselves
ndindex types. For other types, <code class="code docutils literal notranslate"><span class="pre">.args</span></code> contains raw Python types.
Note that <code class="code docutils literal notranslate"><span class="pre">.args</span></code> contains NumPy arrays for <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a>
and <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> types, so one should always do equality
testing or hashing on the ndindex type itself, not its <code class="code docutils literal notranslate"><span class="pre">.args</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.IntegerArray.array">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">array</span></span><a class="headerlink" href="#ndindex.IntegerArray.array" title="Link to this definition">¶</a></dt>
<dd><p>Return the NumPy array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.args[0]</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">array</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span><span class="o">.</span><span class="n">array</span>
<span class="go">array([False, True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.as_subindex">
<span class="sig-name descname"><span class="pre">as_subindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integerarray.py#L127-L176"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.as_subindex" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> produces an index <code class="code docutils literal notranslate"><span class="pre">k</span></code> such that <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span></code> gives all of
the elements of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that are also in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> is a subset of <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i]</span></code>. Otherwise,
<code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">&amp;</span> <span class="pre">j]</span></code>, where <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">&amp;</span> <span class="pre">j</span></code> is the intersection of <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>, that is, the elements of <code class="code docutils literal notranslate"><span class="pre">a</span></code> that are indexed by both <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>For example, in the below diagram, <code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> index a subset of the
array <code class="code docutils literal notranslate"><span class="pre">a</span></code>. <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code> is an index on <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that gives the
subset of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> also included in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+------------</span> <span class="bp">self</span> <span class="o">------------+</span>
    <span class="o">|</span>                              <span class="o">|</span>
<span class="o">-------------------</span> <span class="n">a</span> <span class="o">-----------------------</span>
       <span class="o">|</span>                                 <span class="o">|</span>
       <span class="o">+-------------</span> <span class="n">index</span> <span class="o">-------------+</span>
       <span class="o">|</span>                           <span class="o">|</span>
       <span class="o">+-</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-+</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> is currently only implemented when <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a slice
with positive steps and nonnegative start and stop, or a Tuple of the
same. To use it with slices with negative start or stop, call
<a class="reference internal" href="#ndindex.IntegerArray.reduce" title="ndindex.IntegerArray.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce()</span></code></a> with a shape first.</p>
<p><code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> can be seen as the left-inverse of composition, that is,
if <code class="code docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">a[j][k]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">&quot;=&quot;</span>
<span class="pre">(j^-1)[i]</span></code> (this only works as a true inverse if <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a subset of
<code class="code docutils literal notranslate"><span class="pre">i</span></code>).</p>
<p>Note that due to symmetry, <code class="code docutils literal notranslate"><span class="pre">a[j][i.as_subindex(j)]</span></code> and
<code class="code docutils literal notranslate"><span class="pre">a[i][j.as_subindex(i)]</span></code> will give the same subarrays of <code class="code docutils literal notranslate"><span class="pre">a</span></code>, which
will be the array of elements indexed by both <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> may raise <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code> in the case that the indices
<code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> do not intersect at all.</p>
<p class="rubric">Examples</p>
<p>An example usage of <code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> is to split an index up into
subindices of chunks of an array. For example, say a 1-D array
<code class="code docutils literal notranslate"><span class="pre">a</span></code> is chunked up into chunks of size <code class="code docutils literal notranslate"><span class="pre">N</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">a[0:N]</span></code>,
<code class="code docutils literal notranslate"><span class="pre">a[N:2*N]</span></code>, <code class="code docutils literal notranslate"><span class="pre">[2*N:3*N]</span></code>, etc. are stored separately. Then an index
<code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> can be reindexed onto the chunks via <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(0,</span>
<span class="pre">N))</span></code>, <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(N,</span> <span class="pre">2*N))</span></code>, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j2</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span>
<span class="go">Slice(5, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span>
<span class="go">Slice(0, 5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>a high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
<p><a class="reference internal" href="chunking.html#ndindex.ChunkSize.num_subchunks" title="ndindex.ChunkSize.num_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.num_subchunks</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.broadcast_arrays">
<span class="sig-name descname"><span class="pre">broadcast_arrays</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ndindex.py#L587-L629"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.broadcast_arrays" title="Link to this definition">¶</a></dt>
<dd><p>Broadcast all the array indices in self to a common shape and convert
boolean array indices into integer array indices.</p>
<p>The resulting index is equivalent in all contexts where the original
index is allowed. However, it is possible for the original index to
give an IndexError but for the new index to not, since integer array
indices have less stringent shape requirements than boolean array
indices. There are also some instances for empty indices
(<a class="reference internal" href="#ndindex.IntegerArray.isempty" title="ndindex.IntegerArray.isempty"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">isempty</span></code></a> is True) where bounds would be checked before
broadcasting but not after.</p>
<p>Any <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> indices are converted to
<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices. Furthermore, if there are
<a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> or <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices, then any
<a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> indices are also converted into scalar
<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices and broadcast. Furthermore, if there are
multiple boolean scalar indices (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>), they are combined
into a single one.</p>
<p>Note that array broadcastability is checked in the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>
constructor, so this method will not raise any exceptions.</p>
<p>This is part of what is performed by <a class="reference internal" href="#ndindex.IntegerArray.expand" title="ndindex.IntegerArray.expand"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">expand</span></code></a>, but unlike
<a class="reference internal" href="#ndindex.IntegerArray.expand" title="ndindex.IntegerArray.expand"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">expand</span></code></a>, this method does not do any other manipulations, and it
does not require a shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">())</span>
<span class="go">Tuple(IntegerArray([[1 2] [1 2] [1 2]]),</span>
<span class="go">      IntegerArray([[0 0] [0 0] [0 0]]),</span>
<span class="go">      IntegerArray([[4 4] [5 5] [5 5]]),</span>
<span class="go">      IntegerArray([[-1 -1] [-1 -1] [-1 -1]]))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.IntegerArray.expand" title="ndindex.IntegerArray.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ndindex.py#L366-L438"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.expand" title="Link to this definition">¶</a></dt>
<dd><p>Expand a Tuple index on an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code></p>
<p>An expanded index is as explicit as possible. Unlike <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce</span></code></a>, which tries to simplify an index
and remove redundancies, <code class="code docutils literal notranslate"><span class="pre">expand()</span></code> typically makes an index larger.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">self</span></code> is invalid for the given shape, an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> is raised.
Otherwise, the returned index satisfies the following:</p>
<ul class="simple">
<li><p>It is always a <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>.</p></li>
<li><p>All the elements of the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> are recursively <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">reduced</span></code></a>.</p></li>
<li><p>The length of the <code class="code docutils literal notranslate"><span class="pre">.args</span></code> is equal to the length of the shape plus
the number of <a class="reference internal" href="#ndindex.Newaxis" title="ndindex.Newaxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Newaxis</span></code></a> indices in <code class="code docutils literal notranslate"><span class="pre">self</span></code> plus 1 if there
is a scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p>The resulting <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> has no <a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ellipses</span></code></a>. If there are axes that would be matched by an
ellipsis or an implicit ellipsis at the end of the tuple, <code class="code docutils literal notranslate"><span class="pre">Slice(0,</span>
<span class="pre">n,</span> <span class="pre">1)</span></code> indices are inserted, where <code class="code docutils literal notranslate"><span class="pre">n</span></code> is the corresponding axis of
the <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p></li>
<li><p>Any array indices in <code class="code docutils literal notranslate"><span class="pre">self</span></code> are broadcast together. If <code class="code docutils literal notranslate"><span class="pre">self</span></code>
contains array indices (<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> or
<a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a>), then any <a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> indices are
converted into <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices of shape <code class="code docutils literal notranslate"><span class="pre">()</span></code> and
broadcast. Note that broadcasting is done in a memory efficient way
so that even if the broadcasted shape is large it will not take up
more memory than the original.</p></li>
<li><p>Scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> arguments (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>) are
combined into a single term (the same as with <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Tuple.reduce()</span></code></a>).</p></li>
<li><p>Non-scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a>s are all converted into
equivalent <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a>s via <code class="code docutils literal notranslate"><span class="pre">nonzero()</span></code> and
broadcasted.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 2, 1), slice(0, 3, 1))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 5, 1), None, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 1, 1), slice(0, 2, 1), None, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">too many indices for array: array is 1-dimensional, but 2 were indexed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index -3 is out of bounds for axis 1 with size 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 1, 1), [0, 1], [2, 2])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray.broadcast_arrays" title="ndindex.IntegerArray.broadcast_arrays"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_arrays</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integerarray.py#L121-L125"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.isempty" title="Link to this definition">¶</a></dt>
<dd><p>Returns whether self always indexes an empty array</p>
<p>An empty array is an array whose shape contains at least one 0. Note
that scalars (arrays with shape <code class="code docutils literal notranslate"><span class="pre">()</span></code>) are not considered empty.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default), or an array shape. If it is
<code class="code docutils literal notranslate"><span class="pre">None</span></code>, isempty() will return <code class="code docutils literal notranslate"><span class="pre">True</span></code> when <code class="code docutils literal notranslate"><span class="pre">self</span></code> is always empty for
any array shape. However, if it gives <code class="code docutils literal notranslate"><span class="pre">False</span></code>, it could still give an
empty array for some array shapes, but not all. If you know the shape
of the array that will be indexed, use <code class="code docutils literal notranslate"><span class="pre">idx.isempty(shape)</span></code> and the
result will be correct for arrays of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is
given and <code class="code docutils literal notranslate"><span class="pre">self</span></code> would raise an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> on an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>, <code class="code docutils literal notranslate"><span class="pre">isempty()</span></code> also raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.Slice.__len__</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.isvalid">
<span class="sig-name descname"><span class="pre">isvalid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/array.py#L171-L180"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.isvalid" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a given index is valid on an array of a given shape.</p>
<p>Returns <code class="code docutils literal notranslate"><span class="pre">True</span></code> if an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>
and <code class="code docutils literal notranslate"><span class="pre">False</span></code> if it would raise <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that some indices can never be valid and will raise a
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> or <code class="code docutils literal notranslate"><span class="pre">TypeError</span></code> if you attempt to construct them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">((</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">an index can only have a single ellipsis (&#39;...&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;bool&#39; object cannot be interpreted as an integer</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.newshape</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.IntegerArray.ndim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ndim</span></span><a class="headerlink" href="#ndindex.IntegerArray.ndim" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of dimensions of the array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.array.ndim</span></code>. Note that this is <strong>not</strong> the
same as the number of dimensions of an array that is indexed by
<code class="code docutils literal notranslate"><span class="pre">self</span></code>. Use <code class="code docutils literal notranslate"><span class="pre">len</span></code> on <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">newshape()</span></code></a> to get that.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]])</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.newshape">
<span class="sig-name descname"><span class="pre">newshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integerarray.py#L114-L119"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.newshape" title="Link to this definition">¶</a></dt>
<dd><p>Returns the shape of <code class="code docutils literal notranslate"><span class="pre">a[idx.raw]</span></code>, assuming <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> should be a tuple of ints, or an int, which is equivalent to a
1-D shape.</p>
<p>Raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if <code class="code docutils literal notranslate"><span class="pre">self</span></code> would be invalid for an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 10 is out of bounds for axis 0 with size 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 2)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.isvalid" title="ndindex.ndindex.NDIndex.isvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.isvalid</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.IntegerArray.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#ndindex.IntegerArray.raw" title="Link to this definition">¶</a></dt>
<dd><p>Return the equivalent of <code class="code docutils literal notranslate"><span class="pre">self</span></code> that can be used as an index</p>
<p>NumPy does not allow custom objects to be used as indices, with the
exception of integer indices, so to use an ndindex object as an
index, it is necessary to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integerarray.py#L60-L112"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.reduce" title="Link to this definition">¶</a></dt>
<dd><p>Reduce an <code class="code docutils literal notranslate"><span class="pre">IntegerArray</span></code> index on an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result will either be <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if the index is invalid for the
given shape, an <code class="code docutils literal notranslate"><span class="pre">IntegerArray</span></code> index where the values are all
nonnegative, or, if <code class="code docutils literal notranslate"><span class="pre">self</span></code> is a scalar array index (<code class="code docutils literal notranslate"><span class="pre">self.shape</span> <span class="pre">==</span>
<span class="pre">()</span></code>), an <code class="code docutils literal notranslate"><span class="pre">Integer</span></code> whose value is nonnegative.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">negative_int</span></code> is <code class="code docutils literal notranslate"><span class="pre">True</span></code> and a <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is provided, the result will
be an <code class="code docutils literal notranslate"><span class="pre">IntegerArray</span></code> with negative entries instead of positive
entries.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">IntegerArray</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index -5 is out of bounds for axis 0 with size 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">9</span><span class="p">,))</span>
<span class="go">IntegerArray([4, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">9</span><span class="p">,),</span> <span class="n">negative_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">IntegerArray([-5, -7])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Slice.reduce</span></code></a>, <a class="reference internal" href="#ndindex.ellipsis.reduce" title="ndindex.ellipsis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellipsis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Newaxis.reduce" title="ndindex.Newaxis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Newaxis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Integer.reduce" title="ndindex.Integer.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integer.reduce</span></code></a>, <a class="reference internal" href="#ndindex.BooleanArray.reduce" title="ndindex.BooleanArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BooleanArray.reduce</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.IntegerArray.selected_indices">
<span class="sig-name descname"><span class="pre">selected_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/integerarray.py#L178-L184"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.IntegerArray.selected_indices" title="Link to this definition">¶</a></dt>
<dd><p>Return an iterator over all indices that are selected by <code class="code docutils literal notranslate"><span class="pre">self</span></code> on an
array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result is a set of indices <code class="code docutils literal notranslate"><span class="pre">i</span></code> such that <code class="code docutils literal notranslate"><span class="pre">[a[i]</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span>
<span class="pre">idx.selected_indices(a.shape)]</span></code> is all the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>. The
indices are all iterated over in C (i.e., row major) order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[Integer(5), Integer(6), Integer(7), Integer(8), Integer(9)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[Tuple(5, 0), Tuple(5, 1),</span>
<span class="go"> Tuple(6, 0), Tuple(6, 1),</span>
<span class="go"> Tuple(7, 0), Tuple(7, 1),</span>
<span class="go"> Tuple(8, 0), Tuple(8, 1),</span>
<span class="go"> Tuple(9, 0), Tuple(9, 1)]</span>
</pre></div>
</div>
<p>To correspond these indices to the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>, you can use
<code class="code docutils literal notranslate"><span class="pre">iter_indices(idx.newshape(shape))</span></code>, since both iterators iterate the
indices in C order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">iter_indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">new_idx</span><span class="p">,)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">iter_indices</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">))):</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">a_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">new_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">])</span>
<span class="go">Tuple(3, 0) Tuple(0, 0) 15 15</span>
<span class="go">Tuple(3, 1) Tuple(0, 1) 16 16</span>
<span class="go">Tuple(4, 0) Tuple(1, 0) 20 20</span>
<span class="go">Tuple(4, 1) Tuple(1, 1) 21 21</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="shapetools.html#ndindex.iter_indices" title="ndindex.iter_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.iter_indices</span></code></a></dt><dd><p>An iterator of indices to select every element for arrays of a given shape.</p>
</dd>
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>A high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.IntegerArray.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#ndindex.IntegerArray.shape" title="Link to this definition">¶</a></dt>
<dd><p>Return the shape of the array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.array.shape</span></code>. Note that this is <strong>not</strong> the
same as the shape of an array that is indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>. Use
<a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">newshape()</span></code></a> to get that.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.IntegerArray.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#ndindex.IntegerArray.size" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of elements of the array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.array.size</span></code>. Note that this is <strong>not</strong> the
same as the number of elements of an array that is indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>.
Use <code class="code docutils literal notranslate"><span class="pre">np.prod</span></code> on <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">newshape()</span></code></a> to get that.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">size</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]])</span><span class="o">.</span><span class="n">size</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ndindex.BooleanArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ndindex.</span></span><span class="sig-name descname"><span class="pre">BooleanArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/booleanarray.py#L4-L189"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray" title="Link to this definition">¶</a></dt>
<dd><p>Represents a boolean array index (also known as a mask).</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">idx</span></code> is an n-dimensional boolean array with shape <code class="code docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">(s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>
and <code class="code docutils literal notranslate"><span class="pre">a</span></code> is an array of shape <code class="code docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">(s1,</span> <span class="pre">...,</span> <span class="pre">sn,</span> <span class="pre">...,</span> <span class="pre">sm)</span></code>, <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>
replaces the first <code class="code docutils literal notranslate"><span class="pre">n</span></code> dimensions of <code class="code docutils literal notranslate"><span class="pre">a</span></code> with a single dimensions of size
<code class="code docutils literal notranslate"><span class="pre">np.nonzero(idx)</span></code>, where each entry is included if the corresponding
element of <code class="code docutils literal notranslate"><span class="pre">idx</span></code> is True. The axes in the index shape should match the
corresponding axes in the array shape or be 0, or the index produces
IndexError.</p>
<p>The typical way of creating a mask is to use boolean operations on an
array, then index the array with that. For example, if <code class="code docutils literal notranslate"><span class="pre">a</span></code> is an array of
integers, <code class="code docutils literal notranslate"><span class="pre">a[a</span> <span class="pre">&gt;</span> <span class="pre">0]</span></code> will produces a flat array of the elements of <code class="code docutils literal notranslate"><span class="pre">a</span></code>
that are positive.</p>
<p>Some important things to note about boolean array index semantics:</p>
<ol class="arabic simple">
<li><p>A boolean array index will remove as many dimensions as the index has,
and replace them with a single flat dimension which is the size of the
number of <code class="code docutils literal notranslate"><span class="pre">True</span></code> elements in the index.</p></li>
<li><p>A boolean array index <code class="code docutils literal notranslate"><span class="pre">idx</span></code> works the same as the integer array index
<code class="code docutils literal notranslate"><span class="pre">np.nonzero(idx)</span></code>. In particular, the elements of the index are always
iterated in row-major, C-style order. This does not apply to
0-dimensional boolean indices.</p></li>
<li><p>A 0-dimensional boolean index (i.e., just the scalar <code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>)
can still be thought of as removing 0 dimensions and adding a single
dimension of length 1 for True or 0 for False. Hence, if <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape
<code class="code docutils literal notranslate"><span class="pre">(s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[True]</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>, and
<code class="code docutils literal notranslate"><span class="pre">a[False]</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">s1,</span> <span class="pre">...,</span> <span class="pre">sn)</span></code>.</p></li>
<li><p>If a tuple index has multiple boolean arrays, they are broadcast
together and iterated as a single array, similar to
<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a>. If a boolean array index <code class="code docutils literal notranslate"><span class="pre">idx</span></code> is mixed with an
integer array index in a tuple index, it is treated like
<code class="code docutils literal notranslate"><span class="pre">np.nonzero(idx)</span></code>.</p></li>
</ol>
<p>A list of booleans may also be used in place of a boolean array. Note
that NumPy treats a direct list of integers as a tuple index, but this
behavior is deprecated and will be replaced with integer array indexing in
the future. ndindex always treats lists as arrays.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">BooleanArray</span><span class="p">([[</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 7])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">BooleanArray</span></code> does <em>not</em> represent an array, but rather an <em>array
index</em>. It does not have most methods that <code class="code docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> has, and
should not be used in array contexts. See the document on
<a class="reference internal" href="../type-confusion.html#type-confusion"><span class="std std-ref">Type Confusion</span></a> for more details.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ndindex.BooleanArray.dtype">
<span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#ndindex.BooleanArray.dtype" title="Link to this definition">¶</a></dt>
<dd><p>The dtype of <code class="code docutils literal notranslate"><span class="pre">BooleanArray</span></code> is <code class="code docutils literal notranslate"><span class="pre">np.bool_</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ndindex.BooleanArray.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#ndindex.BooleanArray.args" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">idx.args</span></code> contains the arguments needed to create <code class="code docutils literal notranslate"><span class="pre">idx</span></code>.</p>
<p>For an ndindex object <code class="code docutils literal notranslate"><span class="pre">idx</span></code>, <code class="code docutils literal notranslate"><span class="pre">idx.args</span></code> is always a tuple such that</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)(</span><span class="o">*</span><span class="n">idx</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="n">idx</span>
</pre></div>
</div>
<p>For <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> indices, the elements of <code class="code docutils literal notranslate"><span class="pre">.args</span></code> are themselves
ndindex types. For other types, <code class="code docutils literal notranslate"><span class="pre">.args</span></code> contains raw Python types.
Note that <code class="code docutils literal notranslate"><span class="pre">.args</span></code> contains NumPy arrays for <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a>
and <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> types, so one should always do equality
testing or hashing on the ndindex type itself, not its <code class="code docutils literal notranslate"><span class="pre">.args</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.BooleanArray.array">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">array</span></span><a class="headerlink" href="#ndindex.BooleanArray.array" title="Link to this definition">¶</a></dt>
<dd><p>Return the NumPy array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.args[0]</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">array</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span><span class="o">.</span><span class="n">array</span>
<span class="go">array([False, True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.as_subindex">
<span class="sig-name descname"><span class="pre">as_subindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/booleanarray.py#L164-L167"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.as_subindex" title="Link to this definition">¶</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> produces an index <code class="code docutils literal notranslate"><span class="pre">k</span></code> such that <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span></code> gives all of
the elements of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that are also in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> is a subset of <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i]</span></code>. Otherwise,
<code class="code docutils literal notranslate"><span class="pre">a[j][k]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">&amp;</span> <span class="pre">j]</span></code>, where <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">&amp;</span> <span class="pre">j</span></code> is the intersection of <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>, that is, the elements of <code class="code docutils literal notranslate"><span class="pre">a</span></code> that are indexed by both <code class="code docutils literal notranslate"><span class="pre">i</span></code> and
<code class="code docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>For example, in the below diagram, <code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> index a subset of the
array <code class="code docutils literal notranslate"><span class="pre">a</span></code>. <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code> is an index on <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> that gives the
subset of <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code> also included in <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+------------</span> <span class="bp">self</span> <span class="o">------------+</span>
    <span class="o">|</span>                              <span class="o">|</span>
<span class="o">-------------------</span> <span class="n">a</span> <span class="o">-----------------------</span>
       <span class="o">|</span>                                 <span class="o">|</span>
       <span class="o">+-------------</span> <span class="n">index</span> <span class="o">-------------+</span>
       <span class="o">|</span>                           <span class="o">|</span>
       <span class="o">+-</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-+</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> is currently only implemented when <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a slice
with positive steps and nonnegative start and stop, or a Tuple of the
same. To use it with slices with negative start or stop, call
<a class="reference internal" href="#ndindex.BooleanArray.reduce" title="ndindex.BooleanArray.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce()</span></code></a> with a shape first.</p>
<p><code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> can be seen as the left-inverse of composition, that is,
if <code class="code docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">a[j][k]</span></code>, then <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">i.as_subindex(j)</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">k</span> <span class="pre">&quot;=&quot;</span>
<span class="pre">(j^-1)[i]</span></code> (this only works as a true inverse if <code class="code docutils literal notranslate"><span class="pre">j</span></code> is a subset of
<code class="code docutils literal notranslate"><span class="pre">i</span></code>).</p>
<p>Note that due to symmetry, <code class="code docutils literal notranslate"><span class="pre">a[j][i.as_subindex(j)]</span></code> and
<code class="code docutils literal notranslate"><span class="pre">a[i][j.as_subindex(i)]</span></code> will give the same subarrays of <code class="code docutils literal notranslate"><span class="pre">a</span></code>, which
will be the array of elements indexed by both <code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="code docutils literal notranslate"><span class="pre">a[j]</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">i.as_subindex(j)</span></code> may raise <code class="code docutils literal notranslate"><span class="pre">ValueError</span></code> in the case that the indices
<code class="code docutils literal notranslate"><span class="pre">i</span></code> and <code class="code docutils literal notranslate"><span class="pre">j</span></code> do not intersect at all.</p>
<p class="rubric">Examples</p>
<p>An example usage of <code class="code docutils literal notranslate"><span class="pre">as_subindex</span></code> is to split an index up into
subindices of chunks of an array. For example, say a 1-D array
<code class="code docutils literal notranslate"><span class="pre">a</span></code> is chunked up into chunks of size <code class="code docutils literal notranslate"><span class="pre">N</span></code>, so that <code class="code docutils literal notranslate"><span class="pre">a[0:N]</span></code>,
<code class="code docutils literal notranslate"><span class="pre">a[N:2*N]</span></code>, <code class="code docutils literal notranslate"><span class="pre">[2*N:3*N]</span></code>, etc. are stored separately. Then an index
<code class="code docutils literal notranslate"><span class="pre">a[i]</span></code> can be reindexed onto the chunks via <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(0,</span>
<span class="pre">N))</span></code>, <code class="code docutils literal notranslate"><span class="pre">i.as_subindex(Slice(N,</span> <span class="pre">2*N))</span></code>, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j2</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span>
<span class="go">Slice(5, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_subindex</span><span class="p">(</span><span class="n">j2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span>
<span class="go">Slice(0, 5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k1</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">k2</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">[10, 11, 12, 13, 14]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>a high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
<p><a class="reference internal" href="chunking.html#ndindex.ChunkSize.num_subchunks" title="ndindex.ChunkSize.num_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.num_subchunks</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.broadcast_arrays">
<span class="sig-name descname"><span class="pre">broadcast_arrays</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/booleanarray.py#L169-L170"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.broadcast_arrays" title="Link to this definition">¶</a></dt>
<dd><p>Broadcast all the array indices in self to a common shape and convert
boolean array indices into integer array indices.</p>
<p>The resulting index is equivalent in all contexts where the original
index is allowed. However, it is possible for the original index to
give an IndexError but for the new index to not, since integer array
indices have less stringent shape requirements than boolean array
indices. There are also some instances for empty indices
(<a class="reference internal" href="#ndindex.BooleanArray.isempty" title="ndindex.BooleanArray.isempty"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">isempty</span></code></a> is True) where bounds would be checked before
broadcasting but not after.</p>
<p>Any <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> indices are converted to
<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices. Furthermore, if there are
<a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> or <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices, then any
<a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> indices are also converted into scalar
<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices and broadcast. Furthermore, if there are
multiple boolean scalar indices (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>), they are combined
into a single one.</p>
<p>Note that array broadcastability is checked in the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>
constructor, so this method will not raise any exceptions.</p>
<p>This is part of what is performed by <a class="reference internal" href="#ndindex.BooleanArray.expand" title="ndindex.BooleanArray.expand"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">expand</span></code></a>, but unlike
<a class="reference internal" href="#ndindex.BooleanArray.expand" title="ndindex.BooleanArray.expand"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">expand</span></code></a>, this method does not do any other manipulations, and it
does not require a shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">())</span>
<span class="go">Tuple(IntegerArray([[1 2] [1 2] [1 2]]),</span>
<span class="go">      IntegerArray([[0 0] [0 0] [0 0]]),</span>
<span class="go">      IntegerArray([[4 4] [5 5] [5 5]]),</span>
<span class="go">      IntegerArray([[-1 -1] [-1 -1] [-1 -1]]))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.BooleanArray.expand" title="ndindex.BooleanArray.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.BooleanArray.count_nonzero">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">count_nonzero</span></span><a class="headerlink" href="#ndindex.BooleanArray.count_nonzero" title="Link to this definition">¶</a></dt>
<dd><p>Returns the number of elements indexed by self.</p>
<p>In general, if shapes match, when indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>, the first <em>n</em>
dimensions of an array are replaced with a single dimension of size
<code class="code docutils literal notranslate"><span class="pre">count_nonzero</span></code>, where <em>n</em> is <code class="code docutils literal notranslate"><span class="pre">self.shape</span></code>.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">np.count_nonzero(self.array)</span></code>. Note, to get the
shape of an array indexed by self, use <a class="reference internal" href="#ndindex.BooleanArray.newshape" title="ndindex.BooleanArray.newshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">newshape()</span></code></a>, not this
method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span><span class="o">.</span><span class="n">count_nonzero</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ndindex.py#L366-L438"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.expand" title="Link to this definition">¶</a></dt>
<dd><p>Expand a Tuple index on an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code></p>
<p>An expanded index is as explicit as possible. Unlike <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduce</span></code></a>, which tries to simplify an index
and remove redundancies, <code class="code docutils literal notranslate"><span class="pre">expand()</span></code> typically makes an index larger.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">self</span></code> is invalid for the given shape, an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> is raised.
Otherwise, the returned index satisfies the following:</p>
<ul class="simple">
<li><p>It is always a <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>.</p></li>
<li><p>All the elements of the <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> are recursively <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">reduced</span></code></a>.</p></li>
<li><p>The length of the <code class="code docutils literal notranslate"><span class="pre">.args</span></code> is equal to the length of the shape plus
the number of <a class="reference internal" href="#ndindex.Newaxis" title="ndindex.Newaxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Newaxis</span></code></a> indices in <code class="code docutils literal notranslate"><span class="pre">self</span></code> plus 1 if there
is a scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p>The resulting <a class="reference internal" href="#ndindex.Tuple" title="ndindex.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a> has no <a class="reference internal" href="#ndindex.ellipsis" title="ndindex.ellipsis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ellipses</span></code></a>. If there are axes that would be matched by an
ellipsis or an implicit ellipsis at the end of the tuple, <code class="code docutils literal notranslate"><span class="pre">Slice(0,</span>
<span class="pre">n,</span> <span class="pre">1)</span></code> indices are inserted, where <code class="code docutils literal notranslate"><span class="pre">n</span></code> is the corresponding axis of
the <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p></li>
<li><p>Any array indices in <code class="code docutils literal notranslate"><span class="pre">self</span></code> are broadcast together. If <code class="code docutils literal notranslate"><span class="pre">self</span></code>
contains array indices (<a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> or
<a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a>), then any <a class="reference internal" href="#ndindex.Integer" title="ndindex.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> indices are
converted into <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a> indices of shape <code class="code docutils literal notranslate"><span class="pre">()</span></code> and
broadcast. Note that broadcasting is done in a memory efficient way
so that even if the broadcasted shape is large it will not take up
more memory than the original.</p></li>
<li><p>Scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a> arguments (<code class="code docutils literal notranslate"><span class="pre">True</span></code> or <code class="code docutils literal notranslate"><span class="pre">False</span></code>) are
combined into a single term (the same as with <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Tuple.reduce()</span></code></a>).</p></li>
<li><p>Non-scalar <a class="reference internal" href="#ndindex.BooleanArray" title="ndindex.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanArray</span></code></a>s are all converted into
equivalent <a class="reference internal" href="#ndindex.IntegerArray" title="ndindex.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerArray</span></code></a>s via <code class="code docutils literal notranslate"><span class="pre">nonzero()</span></code> and
broadcasted.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 2, 1), slice(0, 3, 1))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 5, 1), None, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 1, 1), slice(0, 2, 1), None, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">too many indices for array: array is 1-dimensional, but 2 were indexed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index -3 is out of bounds for axis 1 with size 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">Tuple(slice(0, 1, 1), [0, 1], [2, 2])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.BooleanArray.broadcast_arrays" title="ndindex.BooleanArray.broadcast_arrays"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_arrays</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/booleanarray.py#L158-L162"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.isempty" title="Link to this definition">¶</a></dt>
<dd><p>Returns whether self always indexes an empty array</p>
<p>An empty array is an array whose shape contains at least one 0. Note
that scalars (arrays with shape <code class="code docutils literal notranslate"><span class="pre">()</span></code>) are not considered empty.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be <code class="code docutils literal notranslate"><span class="pre">None</span></code> (the default), or an array shape. If it is
<code class="code docutils literal notranslate"><span class="pre">None</span></code>, isempty() will return <code class="code docutils literal notranslate"><span class="pre">True</span></code> when <code class="code docutils literal notranslate"><span class="pre">self</span></code> is always empty for
any array shape. However, if it gives <code class="code docutils literal notranslate"><span class="pre">False</span></code>, it could still give an
empty array for some array shapes, but not all. If you know the shape
of the array that will be indexed, use <code class="code docutils literal notranslate"><span class="pre">idx.isempty(shape)</span></code> and the
result will be correct for arrays of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>. If <code class="code docutils literal notranslate"><span class="pre">shape</span></code> is
given and <code class="code docutils literal notranslate"><span class="pre">self</span></code> would raise an <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> on an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>, <code class="code docutils literal notranslate"><span class="pre">isempty()</span></code> also raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ndindex.Slice.__len__" title="ndindex.Slice.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.Slice.__len__</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.isvalid">
<span class="sig-name descname"><span class="pre">isvalid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/array.py#L171-L180"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.isvalid" title="Link to this definition">¶</a></dt>
<dd><p>Check whether a given index is valid on an array of a given shape.</p>
<p>Returns <code class="code docutils literal notranslate"><span class="pre">True</span></code> if an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code> can be indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>
and <code class="code docutils literal notranslate"><span class="pre">False</span></code> if it would raise <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">isvalid</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that some indices can never be valid and will raise a
<code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> or <code class="code docutils literal notranslate"><span class="pre">TypeError</span></code> if you attempt to construct them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">((</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">an index can only have a single ellipsis (&#39;...&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndindex</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;bool&#39; object cannot be interpreted as an integer</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.newshape</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.BooleanArray.ndim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ndim</span></span><a class="headerlink" href="#ndindex.BooleanArray.ndim" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of dimensions of the array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.array.ndim</span></code>. Note that this is <strong>not</strong> the
same as the number of dimensions of an array that is indexed by
<code class="code docutils literal notranslate"><span class="pre">self</span></code>. Use <code class="code docutils literal notranslate"><span class="pre">len</span></code> on <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">newshape()</span></code></a> to get that.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]])</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.newshape">
<span class="sig-name descname"><span class="pre">newshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/booleanarray.py#L151-L156"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.newshape" title="Link to this definition">¶</a></dt>
<dd><p>Returns the shape of <code class="code docutils literal notranslate"><span class="pre">a[idx.raw]</span></code>, assuming <code class="code docutils literal notranslate"><span class="pre">a</span></code> has shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">shape</span></code> should be a tuple of ints, or an int, which is equivalent to a
1-D shape.</p>
<p>Raises <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if <code class="code docutils literal notranslate"><span class="pre">self</span></code> would be invalid for an array of shape
<code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">index 10 is out of bounds for axis 0 with size 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(7, 2)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.isvalid" title="ndindex.ndindex.NDIndex.isvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.isvalid</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.BooleanArray.raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#ndindex.BooleanArray.raw" title="Link to this definition">¶</a></dt>
<dd><p>Return the equivalent of <code class="code docutils literal notranslate"><span class="pre">self</span></code> that can be used as an index</p>
<p>NumPy does not allow custom objects to be used as indices, with the
exception of integer indices, so to use an ndindex object as an
index, it is necessary to use <code class="code docutils literal notranslate"><span class="pre">raw</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">raw</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/booleanarray.py#L113-L149"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.reduce" title="Link to this definition">¶</a></dt>
<dd><p>Reduce a <code class="code docutils literal notranslate"><span class="pre">BooleanArray</span></code> index on an array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result will either be <code class="code docutils literal notranslate"><span class="pre">IndexError</span></code> if the index is invalid for the
given shape, or a <code class="code docutils literal notranslate"><span class="pre">BooleanArray</span></code> index. Presently, no simplifications
are done for BooleanArray: if <code class="code docutils literal notranslate"><span class="pre">reduce()</span></code> does not produce an
<code class="code docutils literal notranslate"><span class="pre">IndexArray</span></code> the index returned will be the same as <code class="code docutils literal notranslate"><span class="pre">self</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">BooleanArray</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">boolean index did not match indexed array along axis 0; size of axis is 3 but size of corresponding boolean axis is 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">BooleanArray([True, False])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.reduce" title="ndindex.ndindex.NDIndex.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NDIndex.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Tuple.reduce" title="ndindex.Tuple.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tuple.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Slice.reduce" title="ndindex.Slice.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Slice.reduce</span></code></a>, <a class="reference internal" href="#ndindex.ellipsis.reduce" title="ndindex.ellipsis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellipsis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Newaxis.reduce" title="ndindex.Newaxis.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Newaxis.reduce</span></code></a>, <a class="reference internal" href="#ndindex.Integer.reduce" title="ndindex.Integer.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integer.reduce</span></code></a>, <a class="reference internal" href="#ndindex.IntegerArray.reduce" title="ndindex.IntegerArray.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IntegerArray.reduce</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ndindex.BooleanArray.selected_indices">
<span class="sig-name descname"><span class="pre">selected_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Quansight-Labs/ndindex/blob/f905510f1df7bbf1b33c3b9a0c4faa88bbb54c51/ndindex/ndindex.py#L631-L679"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ndindex.BooleanArray.selected_indices" title="Link to this definition">¶</a></dt>
<dd><p>Return an iterator over all indices that are selected by <code class="code docutils literal notranslate"><span class="pre">self</span></code> on an
array of shape <code class="code docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The result is a set of indices <code class="code docutils literal notranslate"><span class="pre">i</span></code> such that <code class="code docutils literal notranslate"><span class="pre">[a[i]</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span>
<span class="pre">idx.selected_indices(a.shape)]</span></code> is all the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>. The
indices are all iterated over in C (i.e., row major) order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[Integer(5), Integer(6), Integer(7), Integer(8), Integer(9)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[Tuple(5, 0), Tuple(5, 1),</span>
<span class="go"> Tuple(6, 0), Tuple(6, 1),</span>
<span class="go"> Tuple(7, 0), Tuple(7, 1),</span>
<span class="go"> Tuple(8, 0), Tuple(8, 1),</span>
<span class="go"> Tuple(9, 0), Tuple(9, 1)]</span>
</pre></div>
</div>
<p>To correspond these indices to the elements of <code class="code docutils literal notranslate"><span class="pre">a[idx]</span></code>, you can use
<code class="code docutils literal notranslate"><span class="pre">iter_indices(idx.newshape(shape))</span></code>, since both iterators iterate the
indices in C order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">iter_indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">new_idx</span><span class="p">,)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">idx</span><span class="o">.</span><span class="n">selected_indices</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">iter_indices</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">newshape</span><span class="p">(</span><span class="n">shape</span><span class="p">))):</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">a_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">raw</span><span class="p">][</span><span class="n">new_idx</span><span class="o">.</span><span class="n">raw</span><span class="p">])</span>
<span class="go">Tuple(3, 0) Tuple(0, 0) 15 15</span>
<span class="go">Tuple(3, 1) Tuple(0, 1) 16 16</span>
<span class="go">Tuple(4, 0) Tuple(1, 0) 20 20</span>
<span class="go">Tuple(4, 1) Tuple(1, 1) 21 21</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="shapetools.html#ndindex.iter_indices" title="ndindex.iter_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.iter_indices</span></code></a></dt><dd><p>An iterator of indices to select every element for arrays of a given shape.</p>
</dd>
<dt><a class="reference internal" href="chunking.html#ndindex.ChunkSize.as_subchunks" title="ndindex.ChunkSize.as_subchunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex.ChunkSize.as_subchunks</span></code></a></dt><dd><p>A high-level iterator that efficiently gives only those chunks that intersect with a given index</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.BooleanArray.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#ndindex.BooleanArray.shape" title="Link to this definition">¶</a></dt>
<dd><p>Return the shape of the array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.array.shape</span></code>. Note that this is <strong>not</strong> the
same as the shape of an array that is indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>. Use
<a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">newshape()</span></code></a> to get that.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ndindex.BooleanArray.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#ndindex.BooleanArray.size" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of elements of the array of self.</p>
<p>This is the same as <code class="code docutils literal notranslate"><span class="pre">self.array.size</span></code>. Note that this is <strong>not</strong> the
same as the number of elements of an array that is indexed by <code class="code docutils literal notranslate"><span class="pre">self</span></code>.
Use <code class="code docutils literal notranslate"><span class="pre">np.prod</span></code> on <a class="reference internal" href="internal.html#ndindex.ndindex.NDIndex.newshape" title="ndindex.ndindex.NDIndex.newshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">newshape()</span></code></a> to get that.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ndindex</span> <span class="kn">import</span> <span class="n">IntegerArray</span><span class="p">,</span> <span class="n">BooleanArray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntegerArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">size</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BooleanArray</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]])</span><span class="o">.</span><span class="n">size</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="shapetools.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Shape Tools</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="ndindex.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">ndindex</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2020, Quansight Labs
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/Quansight-Labs/ndindex" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Index Types</a><ul>
<li><a class="reference internal" href="#ndindex.Integer"><code class="docutils literal notranslate"><span class="pre">Integer</span></code></a><ul>
<li><a class="reference internal" href="#ndindex.Integer.__eq__"><code class="docutils literal notranslate"><span class="pre">Integer.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.__hash__"><code class="docutils literal notranslate"><span class="pre">Integer.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.__len__"><code class="docutils literal notranslate"><span class="pre">Integer.__len__()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.as_subindex"><code class="docutils literal notranslate"><span class="pre">Integer.as_subindex()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.isempty"><code class="docutils literal notranslate"><span class="pre">Integer.isempty()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.isvalid"><code class="docutils literal notranslate"><span class="pre">Integer.isvalid()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.newshape"><code class="docutils literal notranslate"><span class="pre">Integer.newshape()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.raw"><code class="docutils literal notranslate"><span class="pre">Integer.raw</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.reduce"><code class="docutils literal notranslate"><span class="pre">Integer.reduce()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Integer.selected_indices"><code class="docutils literal notranslate"><span class="pre">Integer.selected_indices()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ndindex.Slice"><code class="docutils literal notranslate"><span class="pre">Slice</span></code></a><ul>
<li><a class="reference internal" href="#ndindex.Slice.__eq__"><code class="docutils literal notranslate"><span class="pre">Slice.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.__hash__"><code class="docutils literal notranslate"><span class="pre">Slice.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.__len__"><code class="docutils literal notranslate"><span class="pre">Slice.__len__()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.as_subindex"><code class="docutils literal notranslate"><span class="pre">Slice.as_subindex()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.isempty"><code class="docutils literal notranslate"><span class="pre">Slice.isempty()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.isvalid"><code class="docutils literal notranslate"><span class="pre">Slice.isvalid()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.newshape"><code class="docutils literal notranslate"><span class="pre">Slice.newshape()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.raw"><code class="docutils literal notranslate"><span class="pre">Slice.raw</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.reduce"><code class="docutils literal notranslate"><span class="pre">Slice.reduce()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.selected_indices"><code class="docutils literal notranslate"><span class="pre">Slice.selected_indices()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.start"><code class="docutils literal notranslate"><span class="pre">Slice.start</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.step"><code class="docutils literal notranslate"><span class="pre">Slice.step</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Slice.stop"><code class="docutils literal notranslate"><span class="pre">Slice.stop</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ndindex.ellipsis"><code class="docutils literal notranslate"><span class="pre">ellipsis</span></code></a><ul>
<li><a class="reference internal" href="#ndindex.ellipsis.as_subindex"><code class="docutils literal notranslate"><span class="pre">ellipsis.as_subindex()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.ellipsis.isempty"><code class="docutils literal notranslate"><span class="pre">ellipsis.isempty()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.ellipsis.isvalid"><code class="docutils literal notranslate"><span class="pre">ellipsis.isvalid()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.ellipsis.newshape"><code class="docutils literal notranslate"><span class="pre">ellipsis.newshape()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.ellipsis.raw"><code class="docutils literal notranslate"><span class="pre">ellipsis.raw</span></code></a></li>
<li><a class="reference internal" href="#ndindex.ellipsis.reduce"><code class="docutils literal notranslate"><span class="pre">ellipsis.reduce()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ndindex.Newaxis"><code class="docutils literal notranslate"><span class="pre">Newaxis</span></code></a><ul>
<li><a class="reference internal" href="#ndindex.Newaxis.isempty"><code class="docutils literal notranslate"><span class="pre">Newaxis.isempty()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Newaxis.isvalid"><code class="docutils literal notranslate"><span class="pre">Newaxis.isvalid()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Newaxis.newshape"><code class="docutils literal notranslate"><span class="pre">Newaxis.newshape()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Newaxis.raw"><code class="docutils literal notranslate"><span class="pre">Newaxis.raw</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Newaxis.reduce"><code class="docutils literal notranslate"><span class="pre">Newaxis.reduce()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ndindex.Tuple"><code class="docutils literal notranslate"><span class="pre">Tuple</span></code></a><ul>
<li><a class="reference internal" href="#ndindex.Tuple.as_subindex"><code class="docutils literal notranslate"><span class="pre">Tuple.as_subindex()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.broadcast_arrays"><code class="docutils literal notranslate"><span class="pre">Tuple.broadcast_arrays()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.ellipsis_index"><code class="docutils literal notranslate"><span class="pre">Tuple.ellipsis_index</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.expand"><code class="docutils literal notranslate"><span class="pre">Tuple.expand()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.has_ellipsis"><code class="docutils literal notranslate"><span class="pre">Tuple.has_ellipsis</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.isempty"><code class="docutils literal notranslate"><span class="pre">Tuple.isempty()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.newshape"><code class="docutils literal notranslate"><span class="pre">Tuple.newshape()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.raw"><code class="docutils literal notranslate"><span class="pre">Tuple.raw</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.reduce"><code class="docutils literal notranslate"><span class="pre">Tuple.reduce()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.Tuple.selected_indices"><code class="docutils literal notranslate"><span class="pre">Tuple.selected_indices()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ndindex.IntegerArray"><code class="docutils literal notranslate"><span class="pre">IntegerArray</span></code></a><ul>
<li><a class="reference internal" href="#ndindex.IntegerArray.dtype"><code class="docutils literal notranslate"><span class="pre">IntegerArray.dtype</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.args"><code class="docutils literal notranslate"><span class="pre">IntegerArray.args</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.array"><code class="docutils literal notranslate"><span class="pre">IntegerArray.array</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.as_subindex"><code class="docutils literal notranslate"><span class="pre">IntegerArray.as_subindex()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.broadcast_arrays"><code class="docutils literal notranslate"><span class="pre">IntegerArray.broadcast_arrays()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.expand"><code class="docutils literal notranslate"><span class="pre">IntegerArray.expand()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.isempty"><code class="docutils literal notranslate"><span class="pre">IntegerArray.isempty()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.isvalid"><code class="docutils literal notranslate"><span class="pre">IntegerArray.isvalid()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.ndim"><code class="docutils literal notranslate"><span class="pre">IntegerArray.ndim</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.newshape"><code class="docutils literal notranslate"><span class="pre">IntegerArray.newshape()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.raw"><code class="docutils literal notranslate"><span class="pre">IntegerArray.raw</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.reduce"><code class="docutils literal notranslate"><span class="pre">IntegerArray.reduce()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.selected_indices"><code class="docutils literal notranslate"><span class="pre">IntegerArray.selected_indices()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.shape"><code class="docutils literal notranslate"><span class="pre">IntegerArray.shape</span></code></a></li>
<li><a class="reference internal" href="#ndindex.IntegerArray.size"><code class="docutils literal notranslate"><span class="pre">IntegerArray.size</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ndindex.BooleanArray"><code class="docutils literal notranslate"><span class="pre">BooleanArray</span></code></a><ul>
<li><a class="reference internal" href="#ndindex.BooleanArray.dtype"><code class="docutils literal notranslate"><span class="pre">BooleanArray.dtype</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.args"><code class="docutils literal notranslate"><span class="pre">BooleanArray.args</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.array"><code class="docutils literal notranslate"><span class="pre">BooleanArray.array</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.as_subindex"><code class="docutils literal notranslate"><span class="pre">BooleanArray.as_subindex()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.broadcast_arrays"><code class="docutils literal notranslate"><span class="pre">BooleanArray.broadcast_arrays()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.count_nonzero"><code class="docutils literal notranslate"><span class="pre">BooleanArray.count_nonzero</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.expand"><code class="docutils literal notranslate"><span class="pre">BooleanArray.expand()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.isempty"><code class="docutils literal notranslate"><span class="pre">BooleanArray.isempty()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.isvalid"><code class="docutils literal notranslate"><span class="pre">BooleanArray.isvalid()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.ndim"><code class="docutils literal notranslate"><span class="pre">BooleanArray.ndim</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.newshape"><code class="docutils literal notranslate"><span class="pre">BooleanArray.newshape()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.raw"><code class="docutils literal notranslate"><span class="pre">BooleanArray.raw</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.reduce"><code class="docutils literal notranslate"><span class="pre">BooleanArray.reduce()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.selected_indices"><code class="docutils literal notranslate"><span class="pre">BooleanArray.selected_indices()</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.shape"><code class="docutils literal notranslate"><span class="pre">BooleanArray.shape</span></code></a></li>
<li><a class="reference internal" href="#ndindex.BooleanArray.size"><code class="docutils literal notranslate"><span class="pre">BooleanArray.size</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    </body>
</html>